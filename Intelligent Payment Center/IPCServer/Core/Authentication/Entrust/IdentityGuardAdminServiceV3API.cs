//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace IdentityGuardAdminServiceV3API {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml;
    using System.Xml.Serialization;
    
    
    /// <summary>
    ///   The port type for the administration service, through which all of the 
    ///   administrative operations are performed. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AdminServiceBinding", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class AdminService : System.Web.Services.Protocols.SoapHttpClientProtocol {
	private bool useKeepAlive = false;

        /// <summary>
        /// Allow overriding of the socket keep alive behavior.
        /// The default is not to use keep alive, which is more
        /// reliable, but synchronizing socket keep alive times
        /// with the server and turning on keep alive may improve
        /// performance.
        /// </summary>
        public bool UseKeepAlive
        {
            get { return useKeepAlive; }
            set { useKeepAlive = value; }
        }

        /// <summary>
        /// Overrides the GetWebRequest method to allow setting of the
        /// socket keep alive behavior. See http://blogs.msdn.com/engelsr/articles/497902.aspx
        /// and http://seroter.wordpress.com/2007/08/06/troubleshooting-canceled-web-request/
        /// for details. The UseKeepAlive property can be used to control whether or
        /// not socket keep alive is used or not.
        /// </summary>
        protected override System.Net.WebRequest GetWebRequest(Uri uri)
        {
            System.Net.HttpWebRequest webRequest = (System.Net.HttpWebRequest)base.GetWebRequest(uri);

            if (this.UseKeepAlive)
            {
                webRequest.KeepAlive = true;
            }
            else
            {
                webRequest.KeepAlive = false;
            }
            return webRequest;
        }

       /// <summary>
       ///   Convert a SoapException to an AdminServiceFault.
       ///   Return null if the conversion fails.
       /// </summary>
       /// <param name="soapEx">
       ///   the SoapException returned by IG server
       /// </param>
       /// <returns type="AdminServiceFault">
       ///   the AdminServiceFault
       /// </returns>
       public static AdminServiceFault getFault(SoapException soapEx)
       {
          XmlDocument doc = new XmlDocument();
          if (soapEx.Detail == null)
          {
             return null;
          }
          doc.LoadXml(soapEx.Detail.OuterXml);
          if (!doc.FirstChild.HasChildNodes)
          {
             return null;
          }
          XmlNode node = doc.FirstChild.FirstChild;
          string name = node.Name;
          AdminServiceFault fault = null;
          if (name.Contains("AdminServiceFault"))
          {
             fault = new AdminServiceFault();
          }
          else if (name.Contains("AdminPasswordChangeRequiredFault"))
          {
             fault = new AdminPasswordChangeRequiredFault();
          }

          if (fault != null)
          {
             if (fault is AdminPasswordChangeRequiredFault)
             {
                AdminPasswordChangeRequiredFault pswdFault =
                    (AdminPasswordChangeRequiredFault)fault;
                pswdFault.PasswordRules = getPasswordRulesFromFault(node);

                pswdFault.errorMessage = getValueFromFault(node, "errorMessage");
                pswdFault.id = getValueFromFault(node, "id");
                pswdFault.InternalCode = getValueFromFault(node, "InternalCode");
                pswdFault.ErrorCode = getErrorCodeFromFault(node);

                return pswdFault;
             }
             else
             {
                fault.errorMessage = getValueFromFault(node, "errorMessage");
                fault.id = getValueFromFault(node, "id");
                fault.InternalCode = getValueFromFault(node, "InternalCode");
                fault.ErrorCode = getErrorCodeFromFault(node);

                return fault;
             }
          }
          return null;
       }

       private static string getValueFromFault(XmlNode node, string tag)
       {
          if (node.SelectSingleNode(tag) != null)
          {
             return node.SelectSingleNode(tag).InnerText;
          }
          else
          {
             return null;
          }
       }

       private static PasswordRulesInfo getPasswordRulesFromFault(XmlNode node)
       {
          string passwordRulesTag = "PasswordRules";
          if (node.SelectSingleNode(passwordRulesTag) == null)
          {
             return null;
          }
          // construct PasswordRules
          PasswordRulesInfo rules = new PasswordRulesInfo();
          XmlDocument rulesDoc = new XmlDocument();
          rulesDoc.LoadXml(node.SelectSingleNode(passwordRulesTag).OuterXml);
          if (!rulesDoc.HasChildNodes)
          {
             return null;
          }

          XmlNode rulesNode = rulesDoc.FirstChild;

          rules.comment = getValueFromFault(rulesNode, "comment");
          rules.history = Int32.Parse(getValueFromFault(rulesNode, "history"));
          rules.idleTimeout = Int32.Parse(getValueFromFault(rulesNode, "idleTimeout"));
          rules.lifetime = Int32.Parse(getValueFromFault(rulesNode, "lifetime"));
          rules.lowercase = Boolean.Parse(getValueFromFault(rulesNode, "lowercase"));
          rules.minLength = Int32.Parse(getValueFromFault(rulesNode, "minLength"));
          rules.minLifetime = Int32.Parse(getValueFromFault(rulesNode, "minLifetime"));
          rules.name = getValueFromFault(rulesNode, "name");
          rules.number = Boolean.Parse(getValueFromFault(rulesNode, "number"));
          //      rules.secondAuth = getValueFromFault(rulesNode, "secondAuth");
          rules.special = Boolean.Parse(getValueFromFault(rulesNode, "special"));
          rules.uppercase = Boolean.Parse(getValueFromFault(rulesNode, "uppercase"));

          return rules;
       }




       private static ErrorCode getErrorCodeFromFault(XmlNode node)
       {
          string errroCodeTag = "ErrorCode";
          if (node.SelectSingleNode(errroCodeTag) == null)
          {
             return ErrorCode.MISC;
          }
          string errorCodeString = node.SelectSingleNode(errroCodeTag).InnerText;

          if (errorCodeString == null)
          {
             return ErrorCode.MISC;
          }
          else if (errorCodeString.Equals("USER_NOT_EXIST"))
          {
             return ErrorCode.USER_NOT_EXIST;
          }
          else if (errorCodeString.Equals("USER_EXIST"))
          {
             return ErrorCode.USER_EXIST;
          }
          else if (errorCodeString.Equals("USERNAME_NOT_UNIQUE"))
          {
             return ErrorCode.USERNAME_NOT_UNIQUE;
          }
          else if (errorCodeString.Equals("CARD_NOT_EXIST"))
          {
             return ErrorCode.CARD_NOT_EXIST;
          }
          else if (errorCodeString.Equals("CARD_EXIST"))
          {
             return ErrorCode.CARD_EXIST;
          }
          else if (errorCodeString.Equals("PIN_NOT_EXIST"))
          {
             return ErrorCode.PIN_NOT_EXIST;
          }
          else if (errorCodeString.Equals("PIN_EXIST"))
          {
             return ErrorCode.PIN_EXIST;
          }
          else if (errorCodeString.Equals("PVN_CHANGE_REQUIRED"))
          {
             return ErrorCode.PVN_CHANGE_REQUIRED;
          }
          else if (errorCodeString.Equals("PVN_INVALID"))
          {
             return ErrorCode.PVN_INVALID;
          }
          else if (errorCodeString.Equals("TOKEN_NOT_EXIST"))
          {
             return ErrorCode.TOKEN_NOT_EXIST;
          }
          else if (errorCodeString.Equals("TOKEN_EXIST"))
          {
             return ErrorCode.TOKEN_EXIST;
          }
          else if (errorCodeString.Equals("OBJECT_NOT_EXIST"))
          {
             return ErrorCode.OBJECT_NOT_EXIST;
          }
          else if (errorCodeString.Equals("OBJECT_EXIST"))
          {
             return ErrorCode.OBJECT_EXIST;
          }
          else if (errorCodeString.Equals("INVALID_CARD_STATE"))
          {
             return ErrorCode.INVALID_CARD_STATE;
          }
          else if (errorCodeString.Equals("INVALID_TOKEN_STATE"))
          {
             return ErrorCode.INVALID_TOKEN_STATE;
          }
          else if (errorCodeString.Equals("INVALID_ARGUMENT"))
          {
             return ErrorCode.INVALID_ARGUMENT;
          }
          else if (errorCodeString.Equals("CHALLENGE_NOT_EXIST"))
          {
             return ErrorCode.CHALLENGE_NOT_EXIST;
          }
          else if (errorCodeString.Equals("INVALID_RESPONSE"))
          {
             return ErrorCode.INVALID_RESPONSE;
          }
          else if (errorCodeString.Equals("NOT_LOGGED_IN"))
          {
             return ErrorCode.NOT_LOGGED_IN;
          }
          else if (errorCodeString.Equals("INVALID_USERID_PASSWORD"))
          {
             return ErrorCode.INVALID_USERID_PASSWORD;
          }
          else if (errorCodeString.Equals("ADMIN_LOCKED"))
          {
             return ErrorCode.ADMIN_LOCKED;
          }
          else if (errorCodeString.Equals("PASSWORD_CHANGE_REQUIRED"))
          {
             return ErrorCode.PASSWORD_CHANGE_REQUIRED;
          }
          else if (errorCodeString.Equals("SESSION_EXPIRED"))
          {
             return ErrorCode.SESSION_EXPIRED;
          }
          else if (errorCodeString.Equals("ADMIN_INACTIVE"))
          {
             return ErrorCode.ADMIN_INACTIVE;
          }
          else if (errorCodeString.Equals("LOGIN_FAILED_ADMIN_LOCKED"))
          {
             return ErrorCode.LOGIN_FAILED_ADMIN_LOCKED;
          }
          else if (errorCodeString.Equals("MISC"))
          {
             return ErrorCode.MISC;
          }
          else if (errorCodeString.Equals("NOT_PERMITTED"))
          {
             return ErrorCode.NOT_PERMITTED;
          }
          else if (errorCodeString.Equals("INVALID_LICENSE"))
          {
             return ErrorCode.INVALID_LICENSE;
          }
          else if (errorCodeString.Equals("NOT_SUPPORTED"))
          {
             return ErrorCode.NOT_SUPPORTED;
          }
          else if (errorCodeString.Equals("USER_LOCKED"))
          {
             return ErrorCode.USER_LOCKED;
          }
          else if (errorCodeString.Equals("AUTH_FAILED_USER_LOCKED"))
          {
             return ErrorCode.AUTH_FAILED_USER_LOCKED;
          }
          else
          {
             return ErrorCode.MISC;
          }
       }
    

        
        private System.Threading.SendOrPostCallback loginOperationCompleted;
        
        private System.Threading.SendOrPostCallback logoutOperationCompleted;
        
        private System.Threading.SendOrPostCallback changePasswordOperationCompleted;
        
        private System.Threading.SendOrPostCallback keepAliveOperationCompleted;
        
        private System.Threading.SendOrPostCallback pingOperationCompleted;
        
        private System.Threading.SendOrPostCallback licenseGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback licenseSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback licenseCheckOperationCompleted;
        
        private System.Threading.SendOrPostCallback ipLocationGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback countryGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback countryListOperationCompleted;
        
        private System.Threading.SendOrPostCallback regionGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback regionListOperationCompleted;
        
        private System.Threading.SendOrPostCallback tokenVendorGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback tokenVendorListOperationCompleted;
        
        private System.Threading.SendOrPostCallback policyCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback policyDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback policyGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback policySetOperationCompleted;
        
        private System.Threading.SendOrPostCallback policyListOperationCompleted;
        
        private System.Threading.SendOrPostCallback userSpecGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback cardSpecGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback pinSpecGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback passwordRulesGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback permissionListOperationCompleted;
        
        private System.Threading.SendOrPostCallback ownRoleGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback roleCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback roleDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback roleGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback roleSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback roleListOperationCompleted;
        
        private System.Threading.SendOrPostCallback groupCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback groupDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback groupGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback groupSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback groupListOperationCompleted;
        
        private System.Threading.SendOrPostCallback repositoryGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback repositoryListOperationCompleted;
        
        private System.Threading.SendOrPostCallback userCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback userGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userGetOriginalIdOperationCompleted;
        
        private System.Threading.SendOrPostCallback userSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userListOperationCompleted;
        
        private System.Threading.SendOrPostCallback deliveryConfigListOperationCompleted;
        
        private System.Threading.SendOrPostCallback userContactInfoCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userContactInfoDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback userContactInfoGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userContactInfoSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPINCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPINDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPINGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPINSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userMachineSecretCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userMachineSecretDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback userMachineSecretGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userMachineSecretSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userMachineSecretListOperationCompleted;
        
        private System.Threading.SendOrPostCallback userOTPCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userOTPDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback userOTPDeliverOperationCompleted;
        
        private System.Threading.SendOrPostCallback userOTPGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPasswordCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPasswordSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPasswordGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPasswordDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPVNCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPVNSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPVNDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback userPVNGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userCardCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userCardDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback userCardGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userCardSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userCardUnassignOperationCompleted;
        
        private System.Threading.SendOrPostCallback userCardListOperationCompleted;
        
        private System.Threading.SendOrPostCallback userCardExportOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenAssignOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenUnassignOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenChallengeGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenAuthenticateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenChallengeAuthenticateOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenUnlockOperationCompleted;
        
        private System.Threading.SendOrPostCallback userTokenListOperationCompleted;
        
        private System.Threading.SendOrPostCallback preproducedCardCreateOperationCompleted;
        
        private System.Threading.SendOrPostCallback preproducedCardDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback preproducedCardGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback preproducedCardSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback preproducedCardListOperationCompleted;
        
        private System.Threading.SendOrPostCallback preproducedCardExportOperationCompleted;
        
        private System.Threading.SendOrPostCallback tokenLoadOperationCompleted;
        
        private System.Threading.SendOrPostCallback tokenDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback tokenGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback tokenSetOperationCompleted;
        
        private System.Threading.SendOrPostCallback tokenListOperationCompleted;
        
        private System.Threading.SendOrPostCallback challengeGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback challengeAuthenticateOperationCompleted;
        
        private System.Threading.SendOrPostCallback ipListAddOperationCompleted;
        
        private System.Threading.SendOrPostCallback ipListDeleteOperationCompleted;
        
        private System.Threading.SendOrPostCallback ipListGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback ipListListOperationCompleted;
        
    /// <summary>
    ///   Default constructor
    /// </summary>
        public AdminService() {
            this.Url = "https://localhost:8444/IdentityGuardAdminService/services/AdminServiceV3";
        }
        
    ///  <remarks/>
        public event loginCompletedEventHandler loginCompleted;
        
    ///  <remarks/>
        public event logoutCompletedEventHandler logoutCompleted;
        
    ///  <remarks/>
        public event changePasswordCompletedEventHandler changePasswordCompleted;
        
    ///  <remarks/>
        public event keepAliveCompletedEventHandler keepAliveCompleted;
        
    ///  <remarks/>
        public event pingCompletedEventHandler pingCompleted;
        
    ///  <remarks/>
        public event licenseGetCompletedEventHandler licenseGetCompleted;
        
    ///  <remarks/>
        public event licenseSetCompletedEventHandler licenseSetCompleted;
        
    ///  <remarks/>
        public event licenseCheckCompletedEventHandler licenseCheckCompleted;
        
    ///  <remarks/>
        public event ipLocationGetCompletedEventHandler ipLocationGetCompleted;
        
    ///  <remarks/>
        public event countryGetCompletedEventHandler countryGetCompleted;
        
    ///  <remarks/>
        public event countryListCompletedEventHandler countryListCompleted;
        
    ///  <remarks/>
        public event regionGetCompletedEventHandler regionGetCompleted;
        
    ///  <remarks/>
        public event regionListCompletedEventHandler regionListCompleted;
        
    ///  <remarks/>
        public event tokenVendorGetCompletedEventHandler tokenVendorGetCompleted;
        
    ///  <remarks/>
        public event tokenVendorListCompletedEventHandler tokenVendorListCompleted;
        
    ///  <remarks/>
        public event policyCreateCompletedEventHandler policyCreateCompleted;
        
    ///  <remarks/>
        public event policyDeleteCompletedEventHandler policyDeleteCompleted;
        
    ///  <remarks/>
        public event policyGetCompletedEventHandler policyGetCompleted;
        
    ///  <remarks/>
        public event policySetCompletedEventHandler policySetCompleted;
        
    ///  <remarks/>
        public event policyListCompletedEventHandler policyListCompleted;
        
    ///  <remarks/>
        public event userSpecGetCompletedEventHandler userSpecGetCompleted;
        
    ///  <remarks/>
        public event cardSpecGetCompletedEventHandler cardSpecGetCompleted;
        
    ///  <remarks/>
        public event pinSpecGetCompletedEventHandler pinSpecGetCompleted;
        
    ///  <remarks/>
        public event passwordRulesGetCompletedEventHandler passwordRulesGetCompleted;
        
    ///  <remarks/>
        public event permissionListCompletedEventHandler permissionListCompleted;
        
    ///  <remarks/>
        public event ownRoleGetCompletedEventHandler ownRoleGetCompleted;
        
    ///  <remarks/>
        public event roleCreateCompletedEventHandler roleCreateCompleted;
        
    ///  <remarks/>
        public event roleDeleteCompletedEventHandler roleDeleteCompleted;
        
    ///  <remarks/>
        public event roleGetCompletedEventHandler roleGetCompleted;
        
    ///  <remarks/>
        public event roleSetCompletedEventHandler roleSetCompleted;
        
    ///  <remarks/>
        public event roleListCompletedEventHandler roleListCompleted;
        
    ///  <remarks/>
        public event groupCreateCompletedEventHandler groupCreateCompleted;
        
    ///  <remarks/>
        public event groupDeleteCompletedEventHandler groupDeleteCompleted;
        
    ///  <remarks/>
        public event groupGetCompletedEventHandler groupGetCompleted;
        
    ///  <remarks/>
        public event groupSetCompletedEventHandler groupSetCompleted;
        
    ///  <remarks/>
        public event groupListCompletedEventHandler groupListCompleted;
        
    ///  <remarks/>
        public event repositoryGetCompletedEventHandler repositoryGetCompleted;
        
    ///  <remarks/>
        public event repositoryListCompletedEventHandler repositoryListCompleted;
        
    ///  <remarks/>
        public event userCreateCompletedEventHandler userCreateCompleted;
        
    ///  <remarks/>
        public event userDeleteCompletedEventHandler userDeleteCompleted;
        
    ///  <remarks/>
        public event userGetCompletedEventHandler userGetCompleted;
        
    ///  <remarks/>
        public event userGetOriginalIdCompletedEventHandler userGetOriginalIdCompleted;
        
    ///  <remarks/>
        public event userSetCompletedEventHandler userSetCompleted;
        
    ///  <remarks/>
        public event userListCompletedEventHandler userListCompleted;
        
    ///  <remarks/>
        public event deliveryConfigListCompletedEventHandler deliveryConfigListCompleted;
        
    ///  <remarks/>
        public event userContactInfoCreateCompletedEventHandler userContactInfoCreateCompleted;
        
    ///  <remarks/>
        public event userContactInfoDeleteCompletedEventHandler userContactInfoDeleteCompleted;
        
    ///  <remarks/>
        public event userContactInfoGetCompletedEventHandler userContactInfoGetCompleted;
        
    ///  <remarks/>
        public event userContactInfoSetCompletedEventHandler userContactInfoSetCompleted;
        
    ///  <remarks/>
        public event userPINCreateCompletedEventHandler userPINCreateCompleted;
        
    ///  <remarks/>
        public event userPINDeleteCompletedEventHandler userPINDeleteCompleted;
        
    ///  <remarks/>
        public event userPINGetCompletedEventHandler userPINGetCompleted;
        
    ///  <remarks/>
        public event userPINSetCompletedEventHandler userPINSetCompleted;
        
    ///  <remarks/>
        public event userMachineSecretCreateCompletedEventHandler userMachineSecretCreateCompleted;
        
    ///  <remarks/>
        public event userMachineSecretDeleteCompletedEventHandler userMachineSecretDeleteCompleted;
        
    ///  <remarks/>
        public event userMachineSecretGetCompletedEventHandler userMachineSecretGetCompleted;
        
    ///  <remarks/>
        public event userMachineSecretSetCompletedEventHandler userMachineSecretSetCompleted;
        
    ///  <remarks/>
        public event userMachineSecretListCompletedEventHandler userMachineSecretListCompleted;
        
    ///  <remarks/>
        public event userOTPCreateCompletedEventHandler userOTPCreateCompleted;
        
    ///  <remarks/>
        public event userOTPDeleteCompletedEventHandler userOTPDeleteCompleted;
        
    ///  <remarks/>
        public event userOTPDeliverCompletedEventHandler userOTPDeliverCompleted;
        
    ///  <remarks/>
        public event userOTPGetCompletedEventHandler userOTPGetCompleted;
        
    ///  <remarks/>
        public event userPasswordCreateCompletedEventHandler userPasswordCreateCompleted;
        
    ///  <remarks/>
        public event userPasswordSetCompletedEventHandler userPasswordSetCompleted;
        
    ///  <remarks/>
        public event userPasswordGetCompletedEventHandler userPasswordGetCompleted;
        
    ///  <remarks/>
        public event userPasswordDeleteCompletedEventHandler userPasswordDeleteCompleted;
        
    ///  <remarks/>
        public event userPVNCreateCompletedEventHandler userPVNCreateCompleted;
        
    ///  <remarks/>
        public event userPVNSetCompletedEventHandler userPVNSetCompleted;
        
    ///  <remarks/>
        public event userPVNDeleteCompletedEventHandler userPVNDeleteCompleted;
        
    ///  <remarks/>
        public event userPVNGetCompletedEventHandler userPVNGetCompleted;
        
    ///  <remarks/>
        public event userCardCreateCompletedEventHandler userCardCreateCompleted;
        
    ///  <remarks/>
        public event userCardDeleteCompletedEventHandler userCardDeleteCompleted;
        
    ///  <remarks/>
        public event userCardGetCompletedEventHandler userCardGetCompleted;
        
    ///  <remarks/>
        public event userCardSetCompletedEventHandler userCardSetCompleted;
        
    ///  <remarks/>
        public event userCardUnassignCompletedEventHandler userCardUnassignCompleted;
        
    ///  <remarks/>
        public event userCardListCompletedEventHandler userCardListCompleted;
        
    ///  <remarks/>
        public event userCardExportCompletedEventHandler userCardExportCompleted;
        
    ///  <remarks/>
        public event userTokenAssignCompletedEventHandler userTokenAssignCompleted;
        
    ///  <remarks/>
        public event userTokenDeleteCompletedEventHandler userTokenDeleteCompleted;
        
    ///  <remarks/>
        public event userTokenGetCompletedEventHandler userTokenGetCompleted;
        
    ///  <remarks/>
        public event userTokenSetCompletedEventHandler userTokenSetCompleted;
        
    ///  <remarks/>
        public event userTokenUnassignCompletedEventHandler userTokenUnassignCompleted;
        
    ///  <remarks/>
        public event userTokenChallengeGetCompletedEventHandler userTokenChallengeGetCompleted;
        
    ///  <remarks/>
        public event userTokenAuthenticateCompletedEventHandler userTokenAuthenticateCompleted;
        
    ///  <remarks/>
        public event userTokenChallengeAuthenticateCompletedEventHandler userTokenChallengeAuthenticateCompleted;
        
    ///  <remarks/>
        public event userTokenUnlockCompletedEventHandler userTokenUnlockCompleted;
        
    ///  <remarks/>
        public event userTokenListCompletedEventHandler userTokenListCompleted;
        
    ///  <remarks/>
        public event preproducedCardCreateCompletedEventHandler preproducedCardCreateCompleted;
        
    ///  <remarks/>
        public event preproducedCardDeleteCompletedEventHandler preproducedCardDeleteCompleted;
        
    ///  <remarks/>
        public event preproducedCardGetCompletedEventHandler preproducedCardGetCompleted;
        
    ///  <remarks/>
        public event preproducedCardSetCompletedEventHandler preproducedCardSetCompleted;
        
    ///  <remarks/>
        public event preproducedCardListCompletedEventHandler preproducedCardListCompleted;
        
    ///  <remarks/>
        public event preproducedCardExportCompletedEventHandler preproducedCardExportCompleted;
        
    ///  <remarks/>
        public event tokenLoadCompletedEventHandler tokenLoadCompleted;
        
    ///  <remarks/>
        public event tokenDeleteCompletedEventHandler tokenDeleteCompleted;
        
    ///  <remarks/>
        public event tokenGetCompletedEventHandler tokenGetCompleted;
        
    ///  <remarks/>
        public event tokenSetCompletedEventHandler tokenSetCompleted;
        
    ///  <remarks/>
        public event tokenListCompletedEventHandler tokenListCompleted;
        
    ///  <remarks/>
        public event challengeGetCompletedEventHandler challengeGetCompleted;
        
    ///  <remarks/>
        public event challengeAuthenticateCompletedEventHandler challengeAuthenticateCompleted;
        
    ///  <remarks/>
        public event ipListAddCompletedEventHandler ipListAddCompleted;
        
    ///  <remarks/>
        public event ipListDeleteCompletedEventHandler ipListDeleteCompleted;
        
    ///  <remarks/>
        public event ipListGetCompletedEventHandler ipListGetCompleted;
        
    ///  <remarks/>
        public event ipListListCompletedEventHandler ipListListCompleted;
        
    /// <summary>
    ///   Login to the Administration service, returning a response indicating 
    ///   if the login is complete or a second factor of authentication is 
    ///   required. This is the first call that must be made before any other 
    ///   operations are permitted. To log in, a valid user ID and password must be 
    ///   supplied, and the user must have been assigned an administrative role 
    ///   to make them an administrator. 
    ///   <p>
    ///   If the user's password requires updating, this call will not log the 
    ///   user in, and will instead result in an 
    ///   AdminPasswordChangeRequiredFault. 
    ///   If this happens, a new password for the user should be obtained, then 
    ///   the changePassword operation should be called, which will change the 
    ///   password and perform the login at the same time. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with an 
    ///   INVALID_USERID_PASSWORD error code, if either the user ID or password given 
    ///   during login are invalid. 
    ///   2. A fault with an ADMIN_LOCKED error code, if the caller has entered 
    ///   the wrong user ID and password too many times, and is locked out. 
    ///   3. A fault with an LOGIN_FAILED_ADMIN_LOCKED error code, if the caller 
    ///   has now entered the wrong user ID and password too many times, 
    ///   causing the administrator account to be locked out. 
    ///   Subsequent calls with the same user ID and password will return a 
    ///   fault with an ADMIN_LOCKED error code. 
    ///   </p>
    /// </summary>
    /// <param name="loginCallParms">
    ///   loginCallParms
    /// </param>
    /// <returns type="LoginResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("loginReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public LoginResult login([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] LoginCallParms loginCallParms) {
            object[] results = this.Invoke("login", new object[] {
                        loginCallParms});
            return ((LoginResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult Beginlogin(LoginCallParms loginCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("login", new object[] {
                        loginCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public LoginResult Endlogin(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LoginResult)(results[0]));
        }
        
    ///  <remarks/>
        public void loginAsync(LoginCallParms loginCallParms) {
            this.loginAsync(loginCallParms, null);
        }
        
    ///  <remarks/>
        public void loginAsync(LoginCallParms loginCallParms, object userState) {
            if ((this.loginOperationCompleted == null)) {
                this.loginOperationCompleted = new System.Threading.SendOrPostCallback(this.OnloginOperationCompleted);
            }
            this.InvokeAsync("login", new object[] {
                        loginCallParms}, this.loginOperationCompleted, userState);
        }
        
        private void OnloginOperationCompleted(object arg) {
            if ((this.loginCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.loginCompleted(this, new loginCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Logout from the Administration service.
    /// </summary>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void logout() {
            this.Invoke("logout", new object[0]);
        }
        
    ///  <remarks/>
        public System.IAsyncResult Beginlogout(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("logout", new object[0], callback, asyncState);
        }
        
    ///  <remarks/>
        public void Endlogout(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void logoutAsync() {
            this.logoutAsync(null);
        }
        
    ///  <remarks/>
        public void logoutAsync(object userState) {
            if ((this.logoutOperationCompleted == null)) {
                this.logoutOperationCompleted = new System.Threading.SendOrPostCallback(this.OnlogoutOperationCompleted);
            }
            this.InvokeAsync("logout", new object[0], this.logoutOperationCompleted, userState);
        }
        
        private void OnlogoutOperationCompleted(object arg) {
            if ((this.logoutCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.logoutCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Change the password for the administrator ID specified in the 
    ///   parameters. 
    ///   Other than login, this is the one request that doesn't require that 
    ///   the administrator be logged in already. After this command successfully 
    ///   completes, the administrator will be logged in. 
    ///   <p>
    ///   If second factor authentication is required, the second call to this 
    ///   operation must include the response to the challenge issued in the 
    ///   first call, and the new password must be specified in both calls. 
    ///   </p>
    /// </summary>
    /// <param name="changePasswordCallParms">
    ///   changePasswordCallParms
    /// </param>
    /// <returns type="LoginResult">
    ///   a response indicating if the operation is complete or a second factor 
    ///   of authentication is required. 
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("changePasswordReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public LoginResult changePassword([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] ChangePasswordCallParms changePasswordCallParms) {
            object[] results = this.Invoke("changePassword", new object[] {
                        changePasswordCallParms});
            return ((LoginResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginchangePassword(ChangePasswordCallParms changePasswordCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("changePassword", new object[] {
                        changePasswordCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public LoginResult EndchangePassword(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LoginResult)(results[0]));
        }
        
    ///  <remarks/>
        public void changePasswordAsync(ChangePasswordCallParms changePasswordCallParms) {
            this.changePasswordAsync(changePasswordCallParms, null);
        }
        
    ///  <remarks/>
        public void changePasswordAsync(ChangePasswordCallParms changePasswordCallParms, object userState) {
            if ((this.changePasswordOperationCompleted == null)) {
                this.changePasswordOperationCompleted = new System.Threading.SendOrPostCallback(this.OnchangePasswordOperationCompleted);
            }
            this.InvokeAsync("changePassword", new object[] {
                        changePasswordCallParms}, this.changePasswordOperationCompleted, userState);
        }
        
        private void OnchangePasswordOperationCompleted(object arg) {
            if ((this.changePasswordCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.changePasswordCompleted(this, new changePasswordCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Ping the Entrust IdentityGuard Server so that its idle timer doesn't 
    ///   expire. An administrator must be logged in to call this method. 
    ///   <p>
    ///    This call is not restricted by role permissions.
    ///   </p>
    ///   <p>
    ///   Any parameters passed to this call are ignored, but null is not an 
    ///   acceptable value. A zero-length array is acceptable. 
    ///   </p>
    /// </summary>
    /// <param name="keepAliveCallParms">
    ///   keepAliveCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void keepAlive([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] keepAliveCallParms) {
            this.Invoke("keepAlive", new object[] {
                        keepAliveCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginkeepAlive(NameValue[] keepAliveCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("keepAlive", new object[] {
                        keepAliveCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndkeepAlive(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void keepAliveAsync(NameValue[] keepAliveCallParms) {
            this.keepAliveAsync(keepAliveCallParms, null);
        }
        
    ///  <remarks/>
        public void keepAliveAsync(NameValue[] keepAliveCallParms, object userState) {
            if ((this.keepAliveOperationCompleted == null)) {
                this.keepAliveOperationCompleted = new System.Threading.SendOrPostCallback(this.OnkeepAliveOperationCompleted);
            }
            this.InvokeAsync("keepAlive", new object[] {
                        keepAliveCallParms}, this.keepAliveOperationCompleted, userState);
        }
        
        private void OnkeepAliveOperationCompleted(object arg) {
            if ((this.keepAliveCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.keepAliveCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Ping the Entrust IdentityGuard Administration Service to see if it is 
    ///   alive. An administrator does not have to be logged in to call this 
    ///   method. 
    ///   <p>
    ///    This call is not restricted by role permissions.
    ///   </p>
    ///   <p>
    ///   Any parameters passed to this call are ignored, but null is not an 
    ///   acceptable value. A zero-length array is acceptable. 
    ///   </p>
    /// </summary>
    /// <param name="pingCallParms">
    ///   pingCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void ping([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] pingCallParms) {
            this.Invoke("ping", new object[] {
                        pingCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult Beginping(NameValue[] pingCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ping", new object[] {
                        pingCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void Endping(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void pingAsync(NameValue[] pingCallParms) {
            this.pingAsync(pingCallParms, null);
        }
        
    ///  <remarks/>
        public void pingAsync(NameValue[] pingCallParms, object userState) {
            if ((this.pingOperationCompleted == null)) {
                this.pingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpingOperationCompleted);
            }
            this.InvokeAsync("ping", new object[] {
                        pingCallParms}, this.pingOperationCompleted, userState);
        }
        
        private void OnpingOperationCompleted(object arg) {
            if ((this.pingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.pingCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Retrieves the system license information, detailing how many users are 
    ///   currently in the system, the maximum number of users, and the 
    ///   license expiry date. 
    ///   <p>
    ///   Callers of this operation must have a role with the licenseGet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   Any parameters passed to this call are ignored, but null is not an 
    ///   acceptable value. A zero-length array is acceptable. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have licenseGet 
    ///   permission. 
    ///   </p>
    /// </summary>
    /// <param name="licenseGetCallParms">
    ///   licenseGetCallParms
    /// </param>
    /// <returns type="LicenseInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("licenseGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public LicenseInfo licenseGet([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] licenseGetCallParms) {
            object[] results = this.Invoke("licenseGet", new object[] {
                        licenseGetCallParms});
            return ((LicenseInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginlicenseGet(NameValue[] licenseGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("licenseGet", new object[] {
                        licenseGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public LicenseInfo EndlicenseGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LicenseInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void licenseGetAsync(NameValue[] licenseGetCallParms) {
            this.licenseGetAsync(licenseGetCallParms, null);
        }
        
    ///  <remarks/>
        public void licenseGetAsync(NameValue[] licenseGetCallParms, object userState) {
            if ((this.licenseGetOperationCompleted == null)) {
                this.licenseGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnlicenseGetOperationCompleted);
            }
            this.InvokeAsync("licenseGet", new object[] {
                        licenseGetCallParms}, this.licenseGetOperationCompleted, userState);
        }
        
        private void OnlicenseGetOperationCompleted(object arg) {
            if ((this.licenseGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.licenseGetCompleted(this, new licenseGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Given an installation key and an activation key, updates the system 
    ///   license and returns the new license settings. This operation will not 
    ///   allow setting of a license that will cause the system to stop 
    ///   functioning, for example because the new expiry date is in the past. 
    ///   <p>
    ///   Callers of this operation must have a role with the licenseSet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have licenseSet 
    ///   permission. 
    ///   2. A fault with an INVALID_LICENSE error code, if the installation or 
    ///   activation key are incorrect, the license is expired, or the license 
    ///   allows for fewer users than are currently in the system. 
    ///   </p>
    /// </summary>
    /// <param name="licenseSetCallParms">
    ///   licenseSetCallParms
    /// </param>
    /// <returns type="LicenseInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("licenseSetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public LicenseInfo licenseSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] LicenseSetCallParms licenseSetCallParms) {
            object[] results = this.Invoke("licenseSet", new object[] {
                        licenseSetCallParms});
            return ((LicenseInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginlicenseSet(LicenseSetCallParms licenseSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("licenseSet", new object[] {
                        licenseSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public LicenseInfo EndlicenseSet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LicenseInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void licenseSetAsync(LicenseSetCallParms licenseSetCallParms) {
            this.licenseSetAsync(licenseSetCallParms, null);
        }
        
    ///  <remarks/>
        public void licenseSetAsync(LicenseSetCallParms licenseSetCallParms, object userState) {
            if ((this.licenseSetOperationCompleted == null)) {
                this.licenseSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnlicenseSetOperationCompleted);
            }
            this.InvokeAsync("licenseSet", new object[] {
                        licenseSetCallParms}, this.licenseSetOperationCompleted, userState);
        }
        
        private void OnlicenseSetOperationCompleted(object arg) {
            if ((this.licenseSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.licenseSetCompleted(this, new licenseSetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Given an installation key and an activation key, returns what the new 
    ///   system license information would be if this activation key were used, 
    ///   but does not actually update the system license. 
    ///   <p>
    ///   Callers of this operation must have a role with the licenseSet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have licenseSet 
    ///   permission. 
    ///   2. A fault with an INVALID_LICENSE error code, if the installation or 
    ///   activation key are incorrect. 
    ///   </p>
    /// </summary>
    /// <param name="licenseCheckCallParms">
    ///   licenseCheckCallParms
    /// </param>
    /// <returns type="LicenseInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("licenseCheckReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public LicenseInfo licenseCheck([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] LicenseCheckCallParms licenseCheckCallParms) {
            object[] results = this.Invoke("licenseCheck", new object[] {
                        licenseCheckCallParms});
            return ((LicenseInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginlicenseCheck(LicenseCheckCallParms licenseCheckCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("licenseCheck", new object[] {
                        licenseCheckCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public LicenseInfo EndlicenseCheck(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((LicenseInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void licenseCheckAsync(LicenseCheckCallParms licenseCheckCallParms) {
            this.licenseCheckAsync(licenseCheckCallParms, null);
        }
        
    ///  <remarks/>
        public void licenseCheckAsync(LicenseCheckCallParms licenseCheckCallParms, object userState) {
            if ((this.licenseCheckOperationCompleted == null)) {
                this.licenseCheckOperationCompleted = new System.Threading.SendOrPostCallback(this.OnlicenseCheckOperationCompleted);
            }
            this.InvokeAsync("licenseCheck", new object[] {
                        licenseCheckCallParms}, this.licenseCheckOperationCompleted, userState);
        }
        
        private void OnlicenseCheckOperationCompleted(object arg) {
            if ((this.licenseCheckCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.licenseCheckCompleted(this, new licenseCheckCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Given an IP address in "dot" notation, such as 47.97.1.1, return it's 
    ///   location. 
    ///   <p>
    ///   Callers of this operation must have a role with the ipLocationGet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have ipLocationGet 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the IP address is 
    ///   not valid. 
    ///   </p>
    /// </summary>
    /// <param name="ipLocationGetCallParms">
    ///   ipLocationGetCallParms
    /// </param>
    /// <returns type="IPLocation">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("ipLocationGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public IPLocation ipLocationGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] IPLocationGetCallParms ipLocationGetCallParms) {
            object[] results = this.Invoke("ipLocationGet", new object[] {
                        ipLocationGetCallParms});
            return ((IPLocation)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginipLocationGet(IPLocationGetCallParms ipLocationGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ipLocationGet", new object[] {
                        ipLocationGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public IPLocation EndipLocationGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((IPLocation)(results[0]));
        }
        
    ///  <remarks/>
        public void ipLocationGetAsync(IPLocationGetCallParms ipLocationGetCallParms) {
            this.ipLocationGetAsync(ipLocationGetCallParms, null);
        }
        
    ///  <remarks/>
        public void ipLocationGetAsync(IPLocationGetCallParms ipLocationGetCallParms, object userState) {
            if ((this.ipLocationGetOperationCompleted == null)) {
                this.ipLocationGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnipLocationGetOperationCompleted);
            }
            this.InvokeAsync("ipLocationGet", new object[] {
                        ipLocationGetCallParms}, this.ipLocationGetOperationCompleted, userState);
        }
        
        private void OnipLocationGetOperationCompleted(object arg) {
            if ((this.ipLocationGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ipLocationGetCompleted(this, new ipLocationGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Given a country code, return information about it.
    ///   <p>
    ///   Callers of this operation must have a role with the ipLocationGet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have ipLocationGet 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the given country 
    ///   code is not recognized. 
    ///   </p>
    /// </summary>
    /// <param name="countryGetCallParms">
    ///   countryGetCallParms
    /// </param>
    /// <returns type="CountryInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("countryGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public CountryInfo countryGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] CountryGetCallParms countryGetCallParms) {
            object[] results = this.Invoke("countryGet", new object[] {
                        countryGetCallParms});
            return ((CountryInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegincountryGet(CountryGetCallParms countryGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("countryGet", new object[] {
                        countryGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public CountryInfo EndcountryGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CountryInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void countryGetAsync(CountryGetCallParms countryGetCallParms) {
            this.countryGetAsync(countryGetCallParms, null);
        }
        
    ///  <remarks/>
        public void countryGetAsync(CountryGetCallParms countryGetCallParms, object userState) {
            if ((this.countryGetOperationCompleted == null)) {
                this.countryGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OncountryGetOperationCompleted);
            }
            this.InvokeAsync("countryGet", new object[] {
                        countryGetCallParms}, this.countryGetOperationCompleted, userState);
        }
        
        private void OncountryGetOperationCompleted(object arg) {
            if ((this.countryGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.countryGetCompleted(this, new countryGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   List information about all countries.
    ///   <p>
    ///   Callers of this operation must have a role with the ipLocationGet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   Any parameters passed to this call are ignored, but null is not an 
    ///   acceptable value. A zero-length array is acceptable. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have ipLocationGet 
    ///   permission. 
    ///   </p>
    /// </summary>
    /// <param name="countryListCallParms">
    ///   countryListCallParms
    /// </param>
    /// <returns type="CountryInfo[]">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlArrayAttribute("countryListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        [return: System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public CountryInfo[] countryList([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] countryListCallParms) {
            object[] results = this.Invoke("countryList", new object[] {
                        countryListCallParms});
            return ((CountryInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegincountryList(NameValue[] countryListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("countryList", new object[] {
                        countryListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public CountryInfo[] EndcountryList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CountryInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public void countryListAsync(NameValue[] countryListCallParms) {
            this.countryListAsync(countryListCallParms, null);
        }
        
    ///  <remarks/>
        public void countryListAsync(NameValue[] countryListCallParms, object userState) {
            if ((this.countryListOperationCompleted == null)) {
                this.countryListOperationCompleted = new System.Threading.SendOrPostCallback(this.OncountryListOperationCompleted);
            }
            this.InvokeAsync("countryList", new object[] {
                        countryListCallParms}, this.countryListOperationCompleted, userState);
        }
        
        private void OncountryListOperationCompleted(object arg) {
            if ((this.countryListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.countryListCompleted(this, new countryListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Given a country and region code, return information about it. 
    ///   <p>
    ///   Callers of this operation must have a role with the ipLocationGet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have ipLocationGet 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if either the country 
    ///   code is incorrect or the region code for the given country is not 
    ///   recognized. 
    ///   </p>
    /// </summary>
    /// <param name="regionGetCallParms">
    ///   regionGetCallParms
    /// </param>
    /// <returns type="RegionInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("regionGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public RegionInfo regionGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] RegionGetCallParms regionGetCallParms) {
            object[] results = this.Invoke("regionGet", new object[] {
                        regionGetCallParms});
            return ((RegionInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginregionGet(RegionGetCallParms regionGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("regionGet", new object[] {
                        regionGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public RegionInfo EndregionGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RegionInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void regionGetAsync(RegionGetCallParms regionGetCallParms) {
            this.regionGetAsync(regionGetCallParms, null);
        }
        
    ///  <remarks/>
        public void regionGetAsync(RegionGetCallParms regionGetCallParms, object userState) {
            if ((this.regionGetOperationCompleted == null)) {
                this.regionGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnregionGetOperationCompleted);
            }
            this.InvokeAsync("regionGet", new object[] {
                        regionGetCallParms}, this.regionGetOperationCompleted, userState);
        }
        
        private void OnregionGetOperationCompleted(object arg) {
            if ((this.regionGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.regionGetCompleted(this, new regionGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   List information about all the regions in a given country.
    ///   <p>
    ///   Callers of this operation must have a role with the ipLocationGet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have ipLocationGet 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the country code is 
    ///   not recognized. 
    ///   </p>
    /// </summary>
    /// <param name="regionListCallParms">
    ///   regionListCallParms
    /// </param>
    /// <returns type="RegionInfo[]">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlArrayAttribute("regionListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        [return: System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public RegionInfo[] regionList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] RegionListCallParms regionListCallParms) {
            object[] results = this.Invoke("regionList", new object[] {
                        regionListCallParms});
            return ((RegionInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginregionList(RegionListCallParms regionListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("regionList", new object[] {
                        regionListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public RegionInfo[] EndregionList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RegionInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public void regionListAsync(RegionListCallParms regionListCallParms) {
            this.regionListAsync(regionListCallParms, null);
        }
        
    ///  <remarks/>
        public void regionListAsync(RegionListCallParms regionListCallParms, object userState) {
            if ((this.regionListOperationCompleted == null)) {
                this.regionListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnregionListOperationCompleted);
            }
            this.InvokeAsync("regionList", new object[] {
                        regionListCallParms}, this.regionListOperationCompleted, userState);
        }
        
        private void OnregionListOperationCompleted(object arg) {
            if ((this.regionListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.regionListCompleted(this, new regionListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Given a token vendor ID, return information about it.
    ///   <p>
    ///   Callers of this operation must have a role with the tokenGet or 
    ///   userTokenGet permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have tokenGet or 
    ///   userTokenGet permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the token vendor ID 
    ///   is not defined. 
    ///   </p>
    /// </summary>
    /// <param name="tokenVendorGetCallParms">
    ///   tokenVendorGetCallParms
    /// </param>
    /// <returns type="TokenVendorInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("tokenVendorGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public TokenVendorInfo tokenVendorGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] TokenVendorGetCallParms tokenVendorGetCallParms) {
            object[] results = this.Invoke("tokenVendorGet", new object[] {
                        tokenVendorGetCallParms});
            return ((TokenVendorInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegintokenVendorGet(TokenVendorGetCallParms tokenVendorGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("tokenVendorGet", new object[] {
                        tokenVendorGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public TokenVendorInfo EndtokenVendorGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TokenVendorInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void tokenVendorGetAsync(TokenVendorGetCallParms tokenVendorGetCallParms) {
            this.tokenVendorGetAsync(tokenVendorGetCallParms, null);
        }
        
    ///  <remarks/>
        public void tokenVendorGetAsync(TokenVendorGetCallParms tokenVendorGetCallParms, object userState) {
            if ((this.tokenVendorGetOperationCompleted == null)) {
                this.tokenVendorGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OntokenVendorGetOperationCompleted);
            }
            this.InvokeAsync("tokenVendorGet", new object[] {
                        tokenVendorGetCallParms}, this.tokenVendorGetOperationCompleted, userState);
        }
        
        private void OntokenVendorGetOperationCompleted(object arg) {
            if ((this.tokenVendorGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.tokenVendorGetCompleted(this, new tokenVendorGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   List information about all the token vendors.
    ///   <p>
    ///   Callers of this operation must have a role with the tokenGet or 
    ///   userTokenGet permission. 
    ///   </p>
    ///   <p>
    ///   Any parameters passed to this call are ignored, but null is not an 
    ///   acceptable value. A zero-length array is acceptable. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have tokenGet or 
    ///   userTokenGet permission. 
    ///   </p>
    /// </summary>
    /// <param name="tokenVendorListCallParms">
    ///   tokenVendorListCallParms
    /// </param>
    /// <returns type="TokenVendorInfo[]">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlArrayAttribute("tokenVendorListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        [return: System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public TokenVendorInfo[] tokenVendorList([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] tokenVendorListCallParms) {
            object[] results = this.Invoke("tokenVendorList", new object[] {
                        tokenVendorListCallParms});
            return ((TokenVendorInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegintokenVendorList(NameValue[] tokenVendorListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("tokenVendorList", new object[] {
                        tokenVendorListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public TokenVendorInfo[] EndtokenVendorList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TokenVendorInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public void tokenVendorListAsync(NameValue[] tokenVendorListCallParms) {
            this.tokenVendorListAsync(tokenVendorListCallParms, null);
        }
        
    ///  <remarks/>
        public void tokenVendorListAsync(NameValue[] tokenVendorListCallParms, object userState) {
            if ((this.tokenVendorListOperationCompleted == null)) {
                this.tokenVendorListOperationCompleted = new System.Threading.SendOrPostCallback(this.OntokenVendorListOperationCompleted);
            }
            this.InvokeAsync("tokenVendorList", new object[] {
                        tokenVendorListCallParms}, this.tokenVendorListOperationCompleted, userState);
        }
        
        private void OntokenVendorListOperationCompleted(object arg) {
            if ((this.tokenVendorListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.tokenVendorListCompleted(this, new tokenVendorListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a new policy. Any policy setting not supplied during creation 
    ///   will be filled in with the system default for the setting. 
    ///   <p>
    ///   Callers of this operation must have a role that has the policyCreate 
    ///   permission and the special "all" flag for the policy list. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the caller's roles do not have the properties 
    ///   described above. 
    ///   2. A fault with an OBJECT_EXIST error code, if a policy with the given 
    ///   name already exists. 
    ///   3. A fault with an INVALID_ARGUMENT error code, if any of the policy 
    ///   parameters are not valid. 
    ///   </p>
    /// </summary>
    /// <param name="policyCreateCallParms">
    ///   policyCreateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void policyCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PolicyCreateCallParms policyCreateCallParms) {
            this.Invoke("policyCreate", new object[] {
                        policyCreateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpolicyCreate(PolicyCreateCallParms policyCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("policyCreate", new object[] {
                        policyCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndpolicyCreate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void policyCreateAsync(PolicyCreateCallParms policyCreateCallParms) {
            this.policyCreateAsync(policyCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void policyCreateAsync(PolicyCreateCallParms policyCreateCallParms, object userState) {
            if ((this.policyCreateOperationCompleted == null)) {
                this.policyCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpolicyCreateOperationCompleted);
            }
            this.InvokeAsync("policyCreate", new object[] {
                        policyCreateCallParms}, this.policyCreateOperationCompleted, userState);
        }
        
        private void OnpolicyCreateOperationCompleted(object arg) {
            if ((this.policyCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.policyCreateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the named policy from the Entrust IdentityGuard Server. 
    ///   Policies may only be deleted when they are no longer assigned to any 
    ///   groups, and the policy flagged as default can never be deleted. 
    ///   References to deleted policies are automatically removed from any role that 
    ///   may have granted access to them. 
    ///   <p>
    ///   Callers of this operation must have a role that has the policyDelete 
    ///   permission and a policy list that grants access to the policy being 
    ///   deleted. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the caller does not have a role with policyDelete 
    ///   permission, the policy is still assigned to a group, or the policy 
    ///   to delete is the policy flagged as default. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the policy does not 
    ///   exist, or access to the policy is not permitted by the criteria 
    ///   described above. 
    ///   </p>
    /// </summary>
    /// <param name="policyDeleteCallParms">
    ///   policyDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void policyDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PolicyDeleteCallParms policyDeleteCallParms) {
            this.Invoke("policyDelete", new object[] {
                        policyDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpolicyDelete(PolicyDeleteCallParms policyDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("policyDelete", new object[] {
                        policyDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndpolicyDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void policyDeleteAsync(PolicyDeleteCallParms policyDeleteCallParms) {
            this.policyDeleteAsync(policyDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void policyDeleteAsync(PolicyDeleteCallParms policyDeleteCallParms, object userState) {
            if ((this.policyDeleteOperationCompleted == null)) {
                this.policyDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpolicyDeleteOperationCompleted);
            }
            this.InvokeAsync("policyDelete", new object[] {
                        policyDeleteCallParms}, this.policyDeleteOperationCompleted, userState);
        }
        
        private void OnpolicyDeleteOperationCompleted(object arg) {
            if ((this.policyDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.policyDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return the named policy.
    ///   If the given name policy name is null, the policy flagged as the 
    ///   default is returned. 
    ///   <p>
    ///   The policy is only returned if one or more of the following criteria 
    ///   are met: 1. The caller has a role that grants access to the policy to 
    ///   retrieve via the role's policy list. 2. The caller has a role that 
    ///   grants access to a group that has the policy to retrieve as its policy. 
    ///   3. It is the policy assigned to the group of the administrator 
    ///   making this call. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the policy name is null and the caller's roles do 
    ///   not allow access to the policy flagged as the default. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the policy does not 
    ///   exist or access to the policy is not permitted by the criteria 
    ///   described above. 
    ///   </p>
    /// </summary>
    /// <param name="policyGetCallParms">
    ///   policyGetCallParms
    /// </param>
    /// <returns type="PolicyInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("policyGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public PolicyInfo policyGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PolicyGetCallParms policyGetCallParms) {
            object[] results = this.Invoke("policyGet", new object[] {
                        policyGetCallParms});
            return ((PolicyInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpolicyGet(PolicyGetCallParms policyGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("policyGet", new object[] {
                        policyGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public PolicyInfo EndpolicyGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PolicyInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void policyGetAsync(PolicyGetCallParms policyGetCallParms) {
            this.policyGetAsync(policyGetCallParms, null);
        }
        
    ///  <remarks/>
        public void policyGetAsync(PolicyGetCallParms policyGetCallParms, object userState) {
            if ((this.policyGetOperationCompleted == null)) {
                this.policyGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpolicyGetOperationCompleted);
            }
            this.InvokeAsync("policyGet", new object[] {
                        policyGetCallParms}, this.policyGetOperationCompleted, userState);
        }
        
        private void OnpolicyGetOperationCompleted(object arg) {
            if ((this.policyGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.policyGetCompleted(this, new policyGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Update the named policy.
    ///   <p>
    ///   Callers of this operation must have a role that has the policySet 
    ///   permission and a policy list that grants access to the policy being 
    ///   updated. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have policySet 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the policy does not 
    ///   exist, or access to the policy is not permitted by the role criteria 
    ///   described above. 
    ///   3. A fault with an OBJECT_EXIST error code, if the policy is being 
    ///   renamed but a policy with the new name already exists. 
    ///   4. A fault with an INVALID_ARGUMENT error code, if any of the policy 
    ///   parameters are not valid. 
    ///   </p>
    /// </summary>
    /// <param name="policySetCallParms">
    ///   policySetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void policySet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PolicySetCallParms policySetCallParms) {
            this.Invoke("policySet", new object[] {
                        policySetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpolicySet(PolicySetCallParms policySetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("policySet", new object[] {
                        policySetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndpolicySet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void policySetAsync(PolicySetCallParms policySetCallParms) {
            this.policySetAsync(policySetCallParms, null);
        }
        
    ///  <remarks/>
        public void policySetAsync(PolicySetCallParms policySetCallParms, object userState) {
            if ((this.policySetOperationCompleted == null)) {
                this.policySetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpolicySetOperationCompleted);
            }
            this.InvokeAsync("policySet", new object[] {
                        policySetCallParms}, this.policySetOperationCompleted, userState);
        }
        
        private void OnpolicySetOperationCompleted(object arg) {
            if ((this.policySetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.policySetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return a list of the policies for the Entrust IdentityGuard Server. 
    ///   <p>
    ///   Callers of this operation must have a role that has the policyList 
    ///   permission, and the returned list of policies is the list of all 
    ///   policies that all of the caller's roles with policyList permission grant 
    ///   access to. 
    ///   </p>
    ///   <p>
    ///   Any parameters passed to this call are ignored, but null is not an 
    ///   acceptable value. 
    ///   A zero-length array is acceptable.
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have policyList 
    ///   permission. 
    ///   </p>
    /// </summary>
    /// <param name="policyListCallParms">
    ///   policyListCallParms
    /// </param>
    /// <returns type="PolicyInfoList">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("policyListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public PolicyInfoList policyList([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] policyListCallParms) {
            object[] results = this.Invoke("policyList", new object[] {
                        policyListCallParms});
            return ((PolicyInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpolicyList(NameValue[] policyListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("policyList", new object[] {
                        policyListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public PolicyInfoList EndpolicyList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PolicyInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public void policyListAsync(NameValue[] policyListCallParms) {
            this.policyListAsync(policyListCallParms, null);
        }
        
    ///  <remarks/>
        public void policyListAsync(NameValue[] policyListCallParms, object userState) {
            if ((this.policyListOperationCompleted == null)) {
                this.policyListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpolicyListOperationCompleted);
            }
            this.InvokeAsync("policyList", new object[] {
                        policyListCallParms}, this.policyListOperationCompleted, userState);
        }
        
        private void OnpolicyListOperationCompleted(object arg) {
            if ((this.policyListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.policyListCompleted(this, new policyListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return the named user specification policy for the Entrust 
    ///   IdentityGuard Server. 
    ///   If the given policy name is null, the policy flagged as the default is 
    ///   returned. Unless conserving network bandwidth is an extremely high 
    ///   priority, the policyGet call should be used instead of this call. 
    ///   <p>
    ///   See the policyGet operation for access restrictions and likely faults. 
    ///   </p>
    /// </summary>
    /// <param name="userSpecGetCallParms">
    ///   userSpecGetCallParms
    /// </param>
    /// <returns type="UserSpecInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userSpecGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserSpecInfo userSpecGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserSpecGetCallParms userSpecGetCallParms) {
            object[] results = this.Invoke("userSpecGet", new object[] {
                        userSpecGetCallParms});
            return ((UserSpecInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserSpecGet(UserSpecGetCallParms userSpecGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userSpecGet", new object[] {
                        userSpecGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserSpecInfo EnduserSpecGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserSpecInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void userSpecGetAsync(UserSpecGetCallParms userSpecGetCallParms) {
            this.userSpecGetAsync(userSpecGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userSpecGetAsync(UserSpecGetCallParms userSpecGetCallParms, object userState) {
            if ((this.userSpecGetOperationCompleted == null)) {
                this.userSpecGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserSpecGetOperationCompleted);
            }
            this.InvokeAsync("userSpecGet", new object[] {
                        userSpecGetCallParms}, this.userSpecGetOperationCompleted, userState);
        }
        
        private void OnuserSpecGetOperationCompleted(object arg) {
            if ((this.userSpecGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userSpecGetCompleted(this, new userSpecGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return the named card specification policy for the Entrust 
    ///   IdentityGuard Sever. 
    ///   If the given policy name is null, the policy flagged as the default is 
    ///   returned. Unless conserving network bandwidth is an extremely high 
    ///   priority, the policyGet call should be used instead of this call. 
    ///   <p>
    ///   See the policyGet operation for access restrictions and likely faults. 
    ///   </p>
    /// </summary>
    /// <param name="cardSpecGetCallParms">
    ///   cardSpecGetCallParms
    /// </param>
    /// <returns type="CardSpecInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("cardSpecGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public CardSpecInfo cardSpecGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] CardSpecGetCallParms cardSpecGetCallParms) {
            object[] results = this.Invoke("cardSpecGet", new object[] {
                        cardSpecGetCallParms});
            return ((CardSpecInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegincardSpecGet(CardSpecGetCallParms cardSpecGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("cardSpecGet", new object[] {
                        cardSpecGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public CardSpecInfo EndcardSpecGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CardSpecInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void cardSpecGetAsync(CardSpecGetCallParms cardSpecGetCallParms) {
            this.cardSpecGetAsync(cardSpecGetCallParms, null);
        }
        
    ///  <remarks/>
        public void cardSpecGetAsync(CardSpecGetCallParms cardSpecGetCallParms, object userState) {
            if ((this.cardSpecGetOperationCompleted == null)) {
                this.cardSpecGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OncardSpecGetOperationCompleted);
            }
            this.InvokeAsync("cardSpecGet", new object[] {
                        cardSpecGetCallParms}, this.cardSpecGetOperationCompleted, userState);
        }
        
        private void OncardSpecGetOperationCompleted(object arg) {
            if ((this.cardSpecGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.cardSpecGetCompleted(this, new cardSpecGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return the named PIN policy for the Entrust IdentityGuard Server. 
    ///   If the given policy name is null, the policy flagged as the default is 
    ///   returned. Unless conserving network bandwidth is an extremely high 
    ///   priority, the policyGet call should be used instead of this call. 
    ///   <p>
    ///   See the policyGet operation for access restrictions and likely faults. 
    ///   </p>
    /// </summary>
    /// <param name="pinSpecGetCallParms">
    ///   pinSpecGetCallParms
    /// </param>
    /// <returns type="PINSpecInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("pinSpecGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public PINSpecInfo pinSpecGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PinSpecGetCallParms pinSpecGetCallParms) {
            object[] results = this.Invoke("pinSpecGet", new object[] {
                        pinSpecGetCallParms});
            return ((PINSpecInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpinSpecGet(PinSpecGetCallParms pinSpecGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("pinSpecGet", new object[] {
                        pinSpecGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public PINSpecInfo EndpinSpecGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PINSpecInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void pinSpecGetAsync(PinSpecGetCallParms pinSpecGetCallParms) {
            this.pinSpecGetAsync(pinSpecGetCallParms, null);
        }
        
    ///  <remarks/>
        public void pinSpecGetAsync(PinSpecGetCallParms pinSpecGetCallParms, object userState) {
            if ((this.pinSpecGetOperationCompleted == null)) {
                this.pinSpecGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpinSpecGetOperationCompleted);
            }
            this.InvokeAsync("pinSpecGet", new object[] {
                        pinSpecGetCallParms}, this.pinSpecGetOperationCompleted, userState);
        }
        
        private void OnpinSpecGetOperationCompleted(object arg) {
            if ((this.pinSpecGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.pinSpecGetCompleted(this, new pinSpecGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return the named Password policy for the Entrust IdentityGuard Server. 
    ///   If the given policy name is null, the policy flagged as the default is 
    ///   returned. Unless conserving network bandwidth is an extremely high 
    ///   priority, the policyGet call should be used instead of this call. 
    ///   <p>
    ///   See the policyGet operation for access restrictions and likely faults. 
    ///   </p>
    /// </summary>
    /// <param name="passwordRulesGetCallParms">
    ///   passwordRulesGetCallParms
    /// </param>
    /// <returns type="PasswordRulesInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("passwordRulesGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public PasswordRulesInfo passwordRulesGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PasswordRulesGetCallParms passwordRulesGetCallParms) {
            object[] results = this.Invoke("passwordRulesGet", new object[] {
                        passwordRulesGetCallParms});
            return ((PasswordRulesInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpasswordRulesGet(PasswordRulesGetCallParms passwordRulesGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("passwordRulesGet", new object[] {
                        passwordRulesGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public PasswordRulesInfo EndpasswordRulesGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PasswordRulesInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void passwordRulesGetAsync(PasswordRulesGetCallParms passwordRulesGetCallParms) {
            this.passwordRulesGetAsync(passwordRulesGetCallParms, null);
        }
        
    ///  <remarks/>
        public void passwordRulesGetAsync(PasswordRulesGetCallParms passwordRulesGetCallParms, object userState) {
            if ((this.passwordRulesGetOperationCompleted == null)) {
                this.passwordRulesGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpasswordRulesGetOperationCompleted);
            }
            this.InvokeAsync("passwordRulesGet", new object[] {
                        passwordRulesGetCallParms}, this.passwordRulesGetOperationCompleted, userState);
        }
        
        private void OnpasswordRulesGetOperationCompleted(object arg) {
            if ((this.passwordRulesGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.passwordRulesGetCompleted(this, new passwordRulesGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Returns all possible permissions that may appear in a permission list 
    ///   in a role. 
    ///   <p>
    ///    This call is not restricted by role permissions.
    ///   </p>
    /// </summary>
    /// <param name="permissionListCallParms">
    ///   permissionListCallParms
    /// </param>
    /// <returns type="PermissionsList">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("permissionListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public PermissionsList permissionList([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] permissionListCallParms) {
            object[] results = this.Invoke("permissionList", new object[] {
                        permissionListCallParms});
            return ((PermissionsList)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpermissionList(NameValue[] permissionListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("permissionList", new object[] {
                        permissionListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public PermissionsList EndpermissionList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PermissionsList)(results[0]));
        }
        
    ///  <remarks/>
        public void permissionListAsync(NameValue[] permissionListCallParms) {
            this.permissionListAsync(permissionListCallParms, null);
        }
        
    ///  <remarks/>
        public void permissionListAsync(NameValue[] permissionListCallParms, object userState) {
            if ((this.permissionListOperationCompleted == null)) {
                this.permissionListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpermissionListOperationCompleted);
            }
            this.InvokeAsync("permissionList", new object[] {
                        permissionListCallParms}, this.permissionListOperationCompleted, userState);
        }
        
        private void OnpermissionListOperationCompleted(object arg) {
            if ((this.permissionListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.permissionListCompleted(this, new permissionListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return the role definitions for the logged in administrator.
    ///   <p>
    ///    This call is not restricted by role permissions.
    ///   </p>
    ///   <p>
    ///   Any parameters passed to this call are ignored, but null is not an 
    ///   acceptable value. A zero-length array is acceptable. 
    ///   </p>
    /// </summary>
    /// <param name="ownRoleGetCallParms">
    ///   ownRoleGetCallParms
    /// </param>
    /// <returns type="RoleInfoList">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("ownRoleGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public RoleInfoList ownRoleGet([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] ownRoleGetCallParms) {
            object[] results = this.Invoke("ownRoleGet", new object[] {
                        ownRoleGetCallParms});
            return ((RoleInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginownRoleGet(NameValue[] ownRoleGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ownRoleGet", new object[] {
                        ownRoleGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public RoleInfoList EndownRoleGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RoleInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public void ownRoleGetAsync(NameValue[] ownRoleGetCallParms) {
            this.ownRoleGetAsync(ownRoleGetCallParms, null);
        }
        
    ///  <remarks/>
        public void ownRoleGetAsync(NameValue[] ownRoleGetCallParms, object userState) {
            if ((this.ownRoleGetOperationCompleted == null)) {
                this.ownRoleGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnownRoleGetOperationCompleted);
            }
            this.InvokeAsync("ownRoleGet", new object[] {
                        ownRoleGetCallParms}, this.ownRoleGetOperationCompleted, userState);
        }
        
        private void OnownRoleGetOperationCompleted(object arg) {
            if ((this.ownRoleGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ownRoleGetCompleted(this, new ownRoleGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a new role.
    ///   <p>
    ///   Callers of this operation must have a role that has the roleCreate 
    ///   permission and the special "all" flags for the list of policies, groups 
    ///   and roles that it grants access to. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the caller's roles do not have the properties 
    ///   described above. 
    ///   2. A fault with an OBJECT_EXIST error code, if a role with the given 
    ///   name already exists. 
    ///   3. A fault with an OBJECT_NOT_EXIST error code, if the given policy, 
    ///   group or role lists name a policy, group, or role, respectively, that 
    ///   does not exist. 
    ///   4. A fault with an INVALID_ARGUMENT error code, if any of the 
    ///   permissions in the permission list are not valid, or the permissions have 
    ///   unsatisfied dependencies (for example, if userSet is specified without 
    ///   userGet). 
    ///   </p>
    /// </summary>
    /// <param name="roleCreateCallParms">
    ///   roleCreateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void roleCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] RoleCreateCallParms roleCreateCallParms) {
            this.Invoke("roleCreate", new object[] {
                        roleCreateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginroleCreate(RoleCreateCallParms roleCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("roleCreate", new object[] {
                        roleCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndroleCreate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void roleCreateAsync(RoleCreateCallParms roleCreateCallParms) {
            this.roleCreateAsync(roleCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void roleCreateAsync(RoleCreateCallParms roleCreateCallParms, object userState) {
            if ((this.roleCreateOperationCompleted == null)) {
                this.roleCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnroleCreateOperationCompleted);
            }
            this.InvokeAsync("roleCreate", new object[] {
                        roleCreateCallParms}, this.roleCreateOperationCompleted, userState);
        }
        
        private void OnroleCreateOperationCompleted(object arg) {
            if ((this.roleCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.roleCreateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the named role from the Entrust IdentityGuard Server.
    ///   Roles may only be deleted when they are no longer assigned to any 
    ///   users, and roles that are flagged as being built-in system roles can 
    ///   never be deleted. References to deleted roles are automatically removed 
    ///   from any other roles that may have granted access to them. 
    ///   <p>
    ///   Callers of this operation must have a role that has the roleDelete 
    ///   permission, and a role list that grants access to the role being 
    ///   deleted. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the caller's roles do not have roleDelete 
    ///   permission, the role is still assigned to a user, or the role to delete is a 
    ///   built-in system role. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the role does not 
    ///   exist, or access to the role is not permitted by the criteria 
    ///   described above. 
    ///   </p>
    /// </summary>
    /// <param name="roleDeleteCallParms">
    ///   roleDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void roleDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] RoleDeleteCallParms roleDeleteCallParms) {
            this.Invoke("roleDelete", new object[] {
                        roleDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginroleDelete(RoleDeleteCallParms roleDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("roleDelete", new object[] {
                        roleDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndroleDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void roleDeleteAsync(RoleDeleteCallParms roleDeleteCallParms) {
            this.roleDeleteAsync(roleDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void roleDeleteAsync(RoleDeleteCallParms roleDeleteCallParms, object userState) {
            if ((this.roleDeleteOperationCompleted == null)) {
                this.roleDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnroleDeleteOperationCompleted);
            }
            this.InvokeAsync("roleDelete", new object[] {
                        roleDeleteCallParms}, this.roleDeleteOperationCompleted, userState);
        }
        
        private void OnroleDeleteOperationCompleted(object arg) {
            if ((this.roleDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.roleDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Returns the role information for a named role.
    ///   <p>
    ///   The policy is only returned if one or more of the following criteria 
    ///   are met: 1. The caller has a role that grants access to the role to 
    ///   retrieve via the role's role list. 2. It is one of the roles assigned 
    ///   to the administrator making this call. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with an 
    ///   OBJECT_NOT_EXIST error code, if the role does not exist or access to the role 
    ///   is not permitted by the criteria described above. 
    ///   </p>
    /// </summary>
    /// <param name="roleGetCallParms">
    ///   roleGetCallParms
    /// </param>
    /// <returns type="RoleInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("roleGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public RoleInfo roleGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] RoleGetCallParms roleGetCallParms) {
            object[] results = this.Invoke("roleGet", new object[] {
                        roleGetCallParms});
            return ((RoleInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginroleGet(RoleGetCallParms roleGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("roleGet", new object[] {
                        roleGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public RoleInfo EndroleGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RoleInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void roleGetAsync(RoleGetCallParms roleGetCallParms) {
            this.roleGetAsync(roleGetCallParms, null);
        }
        
    ///  <remarks/>
        public void roleGetAsync(RoleGetCallParms roleGetCallParms, object userState) {
            if ((this.roleGetOperationCompleted == null)) {
                this.roleGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnroleGetOperationCompleted);
            }
            this.InvokeAsync("roleGet", new object[] {
                        roleGetCallParms}, this.roleGetOperationCompleted, userState);
        }
        
        private void OnroleGetOperationCompleted(object arg) {
            if ((this.roleGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.roleGetCompleted(this, new roleGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Updates a role definition.
    ///   <p>
    ///   Callers of this operation must have a role that has the roleSet 
    ///   permission and the special "all" flags for the list of policies, groups and 
    ///   roles that it grants access to. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the caller's roles do not have the properties 
    ///   described above. 
    ///   2. A fault with an OBJECT_EXIST error code, if the role is being 
    ///   renamed and a role with the new name already exists. 
    ///   3. A fault with an OBJECT_NOT_EXIST error code, if the role to update 
    ///   does not exist, access to the role to update is not granted, or if 
    ///   the given policy, group or role lists name a policy, group, or role, 
    ///   respectively, that does not exist. 
    ///   4. A fault with an INVALID_ARGUMENT error code, if any of the 
    ///   permissions in the permission list are not valid, or the permissions have 
    ///   unsatisfied dependencies (for example, if userSet is specified without 
    ///   userGet). 
    ///   </p>
    /// </summary>
    /// <param name="roleSetCallParms">
    ///   roleSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void roleSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] RoleSetCallParms roleSetCallParms) {
            this.Invoke("roleSet", new object[] {
                        roleSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginroleSet(RoleSetCallParms roleSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("roleSet", new object[] {
                        roleSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndroleSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void roleSetAsync(RoleSetCallParms roleSetCallParms) {
            this.roleSetAsync(roleSetCallParms, null);
        }
        
    ///  <remarks/>
        public void roleSetAsync(RoleSetCallParms roleSetCallParms, object userState) {
            if ((this.roleSetOperationCompleted == null)) {
                this.roleSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnroleSetOperationCompleted);
            }
            this.InvokeAsync("roleSet", new object[] {
                        roleSetCallParms}, this.roleSetOperationCompleted, userState);
        }
        
        private void OnroleSetOperationCompleted(object arg) {
            if ((this.roleSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.roleSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Returns the role information for roles matching the given search 
    ///   filter. 
    ///   <p>
    ///   Callers of this operation must have a role that has the roleList 
    ///   permission, and the returned list is the list of all roles matching the 
    ///   search filter that the caller's roles with roleList permission grant 
    ///   access to via their role list. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the caller's roles do not have roleList. 
    ///   </p>
    /// </summary>
    /// <param name="roleListCallParms">
    ///   roleListCallParms
    /// </param>
    /// <returns type="RoleInfoList">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("roleListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public RoleInfoList roleList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] RoleListCallParms roleListCallParms) {
            object[] results = this.Invoke("roleList", new object[] {
                        roleListCallParms});
            return ((RoleInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginroleList(RoleListCallParms roleListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("roleList", new object[] {
                        roleListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public RoleInfoList EndroleList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RoleInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public void roleListAsync(RoleListCallParms roleListCallParms) {
            this.roleListAsync(roleListCallParms, null);
        }
        
    ///  <remarks/>
        public void roleListAsync(RoleListCallParms roleListCallParms, object userState) {
            if ((this.roleListOperationCompleted == null)) {
                this.roleListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnroleListOperationCompleted);
            }
            this.InvokeAsync("roleList", new object[] {
                        roleListCallParms}, this.roleListOperationCompleted, userState);
        }
        
        private void OnroleListOperationCompleted(object arg) {
            if ((this.roleListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.roleListCompleted(this, new roleListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a new group.
    ///   <p>
    ///   Callers of this operation must have a role that has the groupCreate 
    ///   permission and the special "all" flag for the group list. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the caller's roles do not have the properties 
    ///   described above. 
    ///   2. A fault with an OBJECT_EXIST error code, if a group with the given 
    ///   name already exists. 
    ///   3. A fault with an OBJECT_NOT_EXIST error code, if repositories are 
    ///   specified but have not been defined. 
    ///   </p>
    /// </summary>
    /// <param name="groupCreateCallParms">
    ///   groupCreateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void groupCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] GroupCreateCallParms groupCreateCallParms) {
            this.Invoke("groupCreate", new object[] {
                        groupCreateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegingroupCreate(GroupCreateCallParms groupCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("groupCreate", new object[] {
                        groupCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndgroupCreate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void groupCreateAsync(GroupCreateCallParms groupCreateCallParms) {
            this.groupCreateAsync(groupCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void groupCreateAsync(GroupCreateCallParms groupCreateCallParms, object userState) {
            if ((this.groupCreateOperationCompleted == null)) {
                this.groupCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OngroupCreateOperationCompleted);
            }
            this.InvokeAsync("groupCreate", new object[] {
                        groupCreateCallParms}, this.groupCreateOperationCompleted, userState);
        }
        
        private void OngroupCreateOperationCompleted(object arg) {
            if ((this.groupCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.groupCreateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Deletes a group. Groups can only be deleted when there a no users, 
    ///   preproduced cards, or unassigned tokens in the group. The group flagged 
    ///   as the default group can never be deleted. 
    ///   References to deleted groups are automatically removed from any role 
    ///   that may have granted access to them. 
    ///   <p>
    ///   Callers of this operation must have a role that has the groupDelete 
    ///   permission and a group list that grants access to the group being 
    ///   deleted. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the caller does not have a role with groupDelete 
    ///   permission, users, pre-produced cards or unassigned tokens are still 
    ///   assigned to the group, or the group to delete is the group flagged as 
    ///   default. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the group does not 
    ///   exist, or access to the group is not permitted by the criteria 
    ///   described above. 
    ///   </p>
    /// </summary>
    /// <param name="groupDeleteCallParms">
    ///   groupDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void groupDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] GroupDeleteCallParms groupDeleteCallParms) {
            this.Invoke("groupDelete", new object[] {
                        groupDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegingroupDelete(GroupDeleteCallParms groupDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("groupDelete", new object[] {
                        groupDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndgroupDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void groupDeleteAsync(GroupDeleteCallParms groupDeleteCallParms) {
            this.groupDeleteAsync(groupDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void groupDeleteAsync(GroupDeleteCallParms groupDeleteCallParms, object userState) {
            if ((this.groupDeleteOperationCompleted == null)) {
                this.groupDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OngroupDeleteOperationCompleted);
            }
            this.InvokeAsync("groupDelete", new object[] {
                        groupDeleteCallParms}, this.groupDeleteOperationCompleted, userState);
        }
        
        private void OngroupDeleteOperationCompleted(object arg) {
            if ((this.groupDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.groupDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Returns the group information for the named group.
    ///   If the given name group name is null, the group flagged as the default 
    ///   is returned. 
    ///   <p>
    ///   The group is only returned if one or more of the following criteria 
    ///   are met: 1. The caller has a role that grants access to the group to 
    ///   retrieve via the role's group list. 2. It is the group of the 
    ///   administrator making this call. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if the group name is null and the caller's roles do 
    ///   not allow access to the group flagged as the default. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the group does not 
    ///   exist or access to the group is not permitted by the criteria 
    ///   described above. 
    ///   </p>
    /// </summary>
    /// <param name="groupGetCallParms">
    ///   groupGetCallParms
    /// </param>
    /// <returns type="GroupInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("groupGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public GroupInfo groupGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] GroupGetCallParms groupGetCallParms) {
            object[] results = this.Invoke("groupGet", new object[] {
                        groupGetCallParms});
            return ((GroupInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegingroupGet(GroupGetCallParms groupGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("groupGet", new object[] {
                        groupGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public GroupInfo EndgroupGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GroupInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void groupGetAsync(GroupGetCallParms groupGetCallParms) {
            this.groupGetAsync(groupGetCallParms, null);
        }
        
    ///  <remarks/>
        public void groupGetAsync(GroupGetCallParms groupGetCallParms, object userState) {
            if ((this.groupGetOperationCompleted == null)) {
                this.groupGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OngroupGetOperationCompleted);
            }
            this.InvokeAsync("groupGet", new object[] {
                        groupGetCallParms}, this.groupGetOperationCompleted, userState);
        }
        
        private void OngroupGetOperationCompleted(object arg) {
            if ((this.groupGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.groupGetCompleted(this, new groupGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Updates a group definition.
    ///   <p>
    ///   Callers of this operation must have a role that has the groupSet 
    ///   permission and a group list that grants access to the group being updated. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have groupSet 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the group does not 
    ///   exist, access to the group is not permitted by the role criteria 
    ///   described above, or repositories are specified that do not exist. 
    ///   3. A fault with an OBJECT_EXIST error code, if the group is being 
    ///   renamed but a group with the new name already exists. 
    ///   </p>
    /// </summary>
    /// <param name="groupSetCallParms">
    ///   groupSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void groupSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] GroupSetCallParms groupSetCallParms) {
            this.Invoke("groupSet", new object[] {
                        groupSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegingroupSet(GroupSetCallParms groupSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("groupSet", new object[] {
                        groupSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndgroupSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void groupSetAsync(GroupSetCallParms groupSetCallParms) {
            this.groupSetAsync(groupSetCallParms, null);
        }
        
    ///  <remarks/>
        public void groupSetAsync(GroupSetCallParms groupSetCallParms, object userState) {
            if ((this.groupSetOperationCompleted == null)) {
                this.groupSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OngroupSetOperationCompleted);
            }
            this.InvokeAsync("groupSet", new object[] {
                        groupSetCallParms}, this.groupSetOperationCompleted, userState);
        }
        
        private void OngroupSetOperationCompleted(object arg) {
            if ((this.groupSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.groupSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Returns a list of groups matching a search filter.
    ///   <p>
    ///   Callers of this operation must have a role that has the groupList 
    ///   permission, and the returned list of groups is the list of all groups 
    ///   matching the filter that the user's roles with groupList permission 
    ///   grant access to via their group lists. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have groupList 
    ///   permission. 
    ///   </p>
    /// </summary>
    /// <param name="groupListCallParms">
    ///   groupListCallParms
    /// </param>
    /// <returns type="GroupInfoList">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("groupListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public GroupInfoList groupList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] GroupListCallParms groupListCallParms) {
            object[] results = this.Invoke("groupList", new object[] {
                        groupListCallParms});
            return ((GroupInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegingroupList(GroupListCallParms groupListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("groupList", new object[] {
                        groupListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public GroupInfoList EndgroupList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GroupInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public void groupListAsync(GroupListCallParms groupListCallParms) {
            this.groupListAsync(groupListCallParms, null);
        }
        
    ///  <remarks/>
        public void groupListAsync(GroupListCallParms groupListCallParms, object userState) {
            if ((this.groupListOperationCompleted == null)) {
                this.groupListOperationCompleted = new System.Threading.SendOrPostCallback(this.OngroupListOperationCompleted);
            }
            this.InvokeAsync("groupList", new object[] {
                        groupListCallParms}, this.groupListOperationCompleted, userState);
        }
        
        private void OngroupListOperationCompleted(object arg) {
            if ((this.groupListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.groupListCompleted(this, new groupListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Returns information about a single repository.
    ///   <p>
    ///   To call this operation, one of the caller's roles must have the 
    ///   repositoryList permission, or the repository named in the call must be 
    ///   assigned a group that the caller is granted access to through their 
    ///   roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with an 
    ///   OBJECT_NOT_EXIST error code, if the given repository does not exist, or 
    ///   access to the repository is not permitted by the role criteria described 
    ///   above. 
    ///   </p>
    /// </summary>
    /// <param name="repositoryGetCallParms">
    ///   repositoryGetCallParms
    /// </param>
    /// <returns type="RepositoryInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("repositoryGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public RepositoryInfo repositoryGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] RepositoryGetCallParms repositoryGetCallParms) {
            object[] results = this.Invoke("repositoryGet", new object[] {
                        repositoryGetCallParms});
            return ((RepositoryInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginrepositoryGet(RepositoryGetCallParms repositoryGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("repositoryGet", new object[] {
                        repositoryGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public RepositoryInfo EndrepositoryGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RepositoryInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void repositoryGetAsync(RepositoryGetCallParms repositoryGetCallParms) {
            this.repositoryGetAsync(repositoryGetCallParms, null);
        }
        
    ///  <remarks/>
        public void repositoryGetAsync(RepositoryGetCallParms repositoryGetCallParms, object userState) {
            if ((this.repositoryGetOperationCompleted == null)) {
                this.repositoryGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnrepositoryGetOperationCompleted);
            }
            this.InvokeAsync("repositoryGet", new object[] {
                        repositoryGetCallParms}, this.repositoryGetOperationCompleted, userState);
        }
        
        private void OnrepositoryGetOperationCompleted(object arg) {
            if ((this.repositoryGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.repositoryGetCompleted(this, new repositoryGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Returns information about all repositories that are defined.
    ///   <p>
    ///   To call this operation, one of the caller's roles must have the 
    ///   repositoryList permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   repositoryList permission. 
    ///   </p>
    ///   <p>
    ///   Any parameters passed to this call are ignored, but null is not an 
    ///   acceptable value. A zero-length array is acceptable. 
    ///   </p>
    /// </summary>
    /// <param name="repositoryListCallParms">
    ///   repositoryListCallParms
    /// </param>
    /// <returns type="RepositoryInfoList">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("repositoryListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public RepositoryInfoList repositoryList([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] repositoryListCallParms) {
            object[] results = this.Invoke("repositoryList", new object[] {
                        repositoryListCallParms});
            return ((RepositoryInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginrepositoryList(NameValue[] repositoryListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("repositoryList", new object[] {
                        repositoryListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public RepositoryInfoList EndrepositoryList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((RepositoryInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public void repositoryListAsync(NameValue[] repositoryListCallParms) {
            this.repositoryListAsync(repositoryListCallParms, null);
        }
        
    ///  <remarks/>
        public void repositoryListAsync(NameValue[] repositoryListCallParms, object userState) {
            if ((this.repositoryListOperationCompleted == null)) {
                this.repositoryListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnrepositoryListOperationCompleted);
            }
            this.InvokeAsync("repositoryList", new object[] {
                        repositoryListCallParms}, this.repositoryListOperationCompleted, userState);
        }
        
        private void OnrepositoryListOperationCompleted(object arg) {
            if ((this.repositoryListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.repositoryListCompleted(this, new repositoryListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a new user with the given user ID. Administrators are created 
    ///   with this call by providing an administrative role for the user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userCreate permission and a group list that grants access to the 
    ///   group in which the user is being created. If roles are being assigned 
    ///   to the user, one of the caller's roles with userCreate permission and 
    ///   correct group list must also have userSetRole permission. If shared 
    ///   secrets, question and answer pairs, or authentication secrets are 
    ///   being assigned to the user, one of the role with userCreate permission 
    ///   must have userSetSecret, userSetQa, or userSetAuthSecret permissions, 
    ///   respectively. 
    ///   If any of the user's location history settings are provided, e.g. the 
    ///   checkVelocity flag, one of the roles with userCreate permission must 
    ///   have userLocationHistoryOverridePolicy permission. 
    ///   If any of the user's expected location settings are provided, one of 
    ///   the roles with userCreate permission must also have 
    ///   userSetExpectedLocations permission. 
    ///   If the number of days before the user can activation expires is 
    ///   provided, one of the roles with userCreate permission must also have 
    ///   userActivationPeriodOverridePolicy permission. 
    ///   If contact information for the user is provided, one of the roles with 
    ///   userCreate permission must also have userContactInfoSet permission. 
    ///   If the OTPDeliveryEnabled flag is provided, one of the roles with 
    ///   userCreate permission must also have userOtpOverridePolicy permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the group the user 
    ///   is being assigned to does not exist, or is not accessible to the 
    ///   caller; if the roles being assigned to the user do not exist or are not 
    ///   accessible to the caller. 
    ///   3. A fault with a USER_EXIST error code, if a user with the given user 
    ///   ID already exists with the same user ID or an alias matching the 
    ///   given user ID, or any of the new user's aliases match the user ID or 
    ///   aliases of another user. 
    ///   4. A fault with an INVALID_ARGUMENT error code: if any of the given 
    ///   arguments are contradictory, e.g. if the usePolicyForCheckVelocity flag 
    ///   is TRUE and the checkVelocity flag is TRUE; if any of the given 
    ///   contact information are not valid; if any of the shared secret, Q/A pairs 
    ///   or authentication secret collections are provided and the collection 
    ///   exceeds the maximum number or size allowed for these collections as 
    ///   defined in policy. 
    ///   </p>
    /// </summary>
    /// <param name="userCreateCallParms">
    ///   userCreateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserCreateCallParms userCreateCallParms) {
            this.Invoke("userCreate", new object[] {
                        userCreateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserCreate(UserCreateCallParms userCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userCreate", new object[] {
                        userCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserCreate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userCreateAsync(UserCreateCallParms userCreateCallParms) {
            this.userCreateAsync(userCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void userCreateAsync(UserCreateCallParms userCreateCallParms, object userState) {
            if ((this.userCreateOperationCompleted == null)) {
                this.userCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserCreateOperationCompleted);
            }
            this.InvokeAsync("userCreate", new object[] {
                        userCreateCallParms}, this.userCreateOperationCompleted, userState);
        }
        
        private void OnuserCreateOperationCompleted(object arg) {
            if ((this.userCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userCreateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete a user, and all information (cards, authentication secrets, and 
    ///   so on) associated with that user. The only exception is that if the 
    ///   flag autoUnassignToken in the policy assigned to the user's group is 
    ///   true, the user's tokens are automatically unassigned when the user is 
    ///   being deleted. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userDelete permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of the 
    ///   administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userDelete 
    ///   permission, or none of the roles that would grant access to the user 
    ///   information through the userGet call have userDelete permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   </p>
    /// </summary>
    /// <param name="userDeleteCallParms">
    ///   userDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserDeleteCallParms userDeleteCallParms) {
            this.Invoke("userDelete", new object[] {
                        userDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserDelete(UserDeleteCallParms userDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userDelete", new object[] {
                        userDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userDeleteAsync(UserDeleteCallParms userDeleteCallParms) {
            this.userDeleteAsync(userDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void userDeleteAsync(UserDeleteCallParms userDeleteCallParms, object userState) {
            if ((this.userDeleteOperationCompleted == null)) {
                this.userDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserDeleteOperationCompleted);
            }
            this.InvokeAsync("userDelete", new object[] {
                        userDeleteCallParms}, this.userDeleteOperationCompleted, userState);
        }
        
        private void OnuserDeleteOperationCompleted(object arg) {
            if ((this.userDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return information about the user with the given user ID.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userGet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of these 
    ///   roles must also have a role list that grants access to all of the 
    ///   administrator's roles. Even if a user has certain attributes and these 
    ///   attributes are requested with the UserGetParms parameter, they may 
    ///   not be returned if the caller's role(s) that grant access to the user 
    ///   do not have certain permissions. The user's shared secrets are only 
    ///   returned if the one of these roles has userGetSecret permission. 
    ///   The questions from the user's question/answer pairs are only returned 
    ///   if one these roles has userGetQA permission. 
    ///   The user's machine secrets are only returned if one these roles has 
    ///   userMachineSecretGet permission. 
    ///   The user's OTP information is only returned if one these roles has 
    ///   userOtpGet permission. The user's actual OTP value is only returned if 
    ///   one these roles has userOtpView permission. 
    ///   The user's PVN information is only returned if one these roles has 
    ///   userPvnGet permission. The user's actual PVN value is only returned if 
    ///   one these roles has userPvnView permission and the PVN is set to allow 
    ///   viewing by administrators. 
    ///   The user's password information is only returned if one these roles 
    ///   has userPasswordGet permission. The user's actual password value is 
    ///   only returned if one these roles has userPasswordView permission and a 
    ///   retrievable version of the password has been stored. 
    ///   The user's contact information is only returned if one these roles has 
    ///   userContactInfoGet permission. 
    ///   The user's Temporary PIN information is only returned if one these 
    ///   roles has userPinGet permission. The user's actual temporary PIN value 
    ///   is only returned if one these roles has userPinView permission. 
    ///   The user's cards are only returned if one these roles has userCardGet 
    ///   permission. The card grids are only returned if one these roles has 
    ///   userCardView permission. 
    ///   The user's tokens are only returned if one these roles has 
    ///   userTokenGet permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userGet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   </p>
    /// </summary>
    /// <param name="userGetCallParms">
    ///   userGetCallParms
    /// </param>
    /// <returns type="UserInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserInfo userGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserGetCallParms userGetCallParms) {
            object[] results = this.Invoke("userGet", new object[] {
                        userGetCallParms});
            return ((UserInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserGet(UserGetCallParms userGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userGet", new object[] {
                        userGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserInfo EnduserGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void userGetAsync(UserGetCallParms userGetCallParms) {
            this.userGetAsync(userGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userGetAsync(UserGetCallParms userGetCallParms, object userState) {
            if ((this.userGetOperationCompleted == null)) {
                this.userGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserGetOperationCompleted);
            }
            this.InvokeAsync("userGet", new object[] {
                        userGetCallParms}, this.userGetOperationCompleted, userState);
        }
        
        private void OnuserGetOperationCompleted(object arg) {
            if ((this.userGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userGetCompleted(this, new userGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return the original userid of the given user. For a user in an LDAP 
    ///   repository whose entry has been renamed but where the Entrust 
    ///   IdentityGuard userid has not been changed, the original userid is the old 
    ///   userid of the user. In all other scenarios, the original userid is the 
    ///   same as the current userid. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userGet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of these 
    ///   roles must also have a role list that grants access to all of the 
    ///   administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userGet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   </p>
    /// </summary>
    /// <param name="userGetOriginalIdCallParms">
    ///   userGetOriginalIdCallParms
    /// </param>
    /// <returns type="string">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userGetOriginalIdReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public string userGetOriginalId([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserGetOriginalIdCallParms userGetOriginalIdCallParms) {
            object[] results = this.Invoke("userGetOriginalId", new object[] {
                        userGetOriginalIdCallParms});
            return ((string)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserGetOriginalId(UserGetOriginalIdCallParms userGetOriginalIdCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userGetOriginalId", new object[] {
                        userGetOriginalIdCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public string EnduserGetOriginalId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
    ///  <remarks/>
        public void userGetOriginalIdAsync(UserGetOriginalIdCallParms userGetOriginalIdCallParms) {
            this.userGetOriginalIdAsync(userGetOriginalIdCallParms, null);
        }
        
    ///  <remarks/>
        public void userGetOriginalIdAsync(UserGetOriginalIdCallParms userGetOriginalIdCallParms, object userState) {
            if ((this.userGetOriginalIdOperationCompleted == null)) {
                this.userGetOriginalIdOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserGetOriginalIdOperationCompleted);
            }
            this.InvokeAsync("userGetOriginalId", new object[] {
                        userGetOriginalIdCallParms}, this.userGetOriginalIdOperationCompleted, userState);
        }
        
        private void OnuserGetOriginalIdOperationCompleted(object arg) {
            if ((this.userGetOriginalIdCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userGetOriginalIdCompleted(this, new userGetOriginalIdCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Set a variety of information about the given user, including user ID, 
    ///   aliases, authentication secrets, expected locations, contact 
    ///   information, and more. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userSet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user being updated is an 
    ///   administrator, one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   If the user's group is being changed, one of the caller's roles with 
    ///   userSet permission and correct group list must also have a group list 
    ///   that grants access to the user's new group. 
    ///   If new roles are being assigned to the user, one of the caller's roles 
    ///   with userSet permission and correct group list must also have 
    ///   userSetRole permission and have a role list that grants access to all of 
    ///   the user's new roles. 
    ///   If the user's lockout count is being reset (i.e. if the UserParms 
    ///   clearlockout flag is TRUE), one of the roles with userSet permission must 
    ///   have userUnlock permission. 
    ///   If the user's state is being changed, one of the roles with userSet 
    ///   permission must have userSetState permission. 
    ///   If shared secrets, question and answer pairs, or authentication 
    ///   secrets are being changed or assigned to the user, one of the roles with 
    ///   userSet permission must have userSetSecret, userSetQa, or 
    ///   userSetAuthSecret permissions, respectively. 
    ///   If machine secrets are being deleted, one of the roles with userSet 
    ///   permission must have userMachineSecretDelete permission. 
    ///   If any of the settings affecting the user's location history size or 
    ///   location history checking are non-nil, one of the roles with userSet 
    ///   permission must have userLocationHistoryOverridePolicy permission. 
    ///   If any of the user's location history entries are being removed, one 
    ///   of the roles with userSet permission must have 
    ///   userDeleteLocationHistory permission. 
    ///   If any of the user's expected location settings are provided, one of 
    ///   the roles with userSet permission must also have 
    ///   userSetExpectedLocations permission. 
    ///   If the number of days before the user can activation expires is 
    ///   provided, one of the roles with userSet permission must also have 
    ///   userActivationPeriodOverridePolicy permission. 
    ///   If contact information for the user is being added or modified, 
    ///   provided, one of the roles with userSet permission must also have 
    ///   userContactInfoSet permission. 
    ///   If the OTPDeliveryEnabled flag is provided, one of the roles with 
    ///   userCreate permission must also have userOtpOverridePolicy permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with an OBJECT_NOT_EXIST error code, if the group the user 
    ///   is being re-assigned to does not exist, or is not accessible to the 
    ///   caller; if the roles being assigned to the user do not exist or are 
    ///   not accessible to the caller. 
    ///   4. A fault with a USER_EXIST error code, if the user is being renamed 
    ///   or assigned new aliases, and a user with the given user ID already 
    ///   exists with the same user ID or an alias matching the given user ID, or 
    ///   any of the user's new aliases match the user ID or aliases of 
    ///   another user. 
    ///   5. A fault with an INVALID_ARGUMENT error code: if any of the given 
    ///   arguments are contradictory, e.g. if the usePolicyForCheckVelocity flag 
    ///   is TRUE and the checkVelocity flag is TRUE; if any of the given 
    ///   contact information are not valid; if any of the shared secret, Q/A pairs 
    ///   or authentication secret collections are provided and the collection 
    ///   exceeds the maximum number or size allowed for these collections as 
    ///   defined in policy. 
    ///   </p>
    /// </summary>
    /// <param name="userSetCallParms">
    ///   userSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserSetCallParms userSetCallParms) {
            this.Invoke("userSet", new object[] {
                        userSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserSet(UserSetCallParms userSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userSet", new object[] {
                        userSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userSetAsync(UserSetCallParms userSetCallParms) {
            this.userSetAsync(userSetCallParms, null);
        }
        
    ///  <remarks/>
        public void userSetAsync(UserSetCallParms userSetCallParms, object userState) {
            if ((this.userSetOperationCompleted == null)) {
                this.userSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserSetOperationCompleted);
            }
            this.InvokeAsync("userSet", new object[] {
                        userSetCallParms}, this.userSetOperationCompleted, userState);
        }
        
        private void OnuserSetOperationCompleted(object arg) {
            if ((this.userSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return information about all users that match the given filter. 
    ///   The returned list will be ordered by the order in which the users were 
    ///   created. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userList permission. Users matching the filter are only returned 
    ///   if they are accessible to the caller using the roles with userList 
    ///   permission and the access rules described for the userGet operation. 
    ///   User information returned (cards, tokens, etc.) is also subject to the 
    ///   rules described for the userGet operation. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userList 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if any of the groups, 
    ///   roles, or token vendor IDs specified in the search filter do not 
    ///   exist, or access to them is not granted by the user's roles with userList 
    ///   permission. 
    ///   </p>
    /// </summary>
    /// <param name="userListCallParms">
    ///   userListCallParms
    /// </param>
    /// <returns type="UserListResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserListResult userList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserListCallParms userListCallParms) {
            object[] results = this.Invoke("userList", new object[] {
                        userListCallParms});
            return ((UserListResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserList(UserListCallParms userListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userList", new object[] {
                        userListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserListResult EnduserList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserListResult)(results[0]));
        }
        
    ///  <remarks/>
        public void userListAsync(UserListCallParms userListCallParms) {
            this.userListAsync(userListCallParms, null);
        }
        
    ///  <remarks/>
        public void userListAsync(UserListCallParms userListCallParms, object userState) {
            if ((this.userListOperationCompleted == null)) {
                this.userListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserListOperationCompleted);
            }
            this.InvokeAsync("userList", new object[] {
                        userListCallParms}, this.userListOperationCompleted, userState);
        }
        
        private void OnuserListOperationCompleted(object arg) {
            if ((this.userListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userListCompleted(this, new userListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return a list of the delivery configurations for the Entrust 
    ///   IdentityGuard Server. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userContactInfoGet permission. 
    ///   </p>
    ///   <p>
    ///   Any parameters passed to this call are ignored, but null is not an 
    ///   acceptable value. A zero-length array is acceptable. 
    ///   </p>
    /// </summary>
    /// <param name="deliveryConfigListCallParms">
    ///   deliveryConfigListCallParms
    /// </param>
    /// <returns type="DeliveryConfigInfoList">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("deliveryConfigListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public DeliveryConfigInfoList deliveryConfigList([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)] NameValue[] deliveryConfigListCallParms) {
            object[] results = this.Invoke("deliveryConfigList", new object[] {
                        deliveryConfigListCallParms});
            return ((DeliveryConfigInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegindeliveryConfigList(NameValue[] deliveryConfigListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("deliveryConfigList", new object[] {
                        deliveryConfigListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public DeliveryConfigInfoList EnddeliveryConfigList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((DeliveryConfigInfoList)(results[0]));
        }
        
    ///  <remarks/>
        public void deliveryConfigListAsync(NameValue[] deliveryConfigListCallParms) {
            this.deliveryConfigListAsync(deliveryConfigListCallParms, null);
        }
        
    ///  <remarks/>
        public void deliveryConfigListAsync(NameValue[] deliveryConfigListCallParms, object userState) {
            if ((this.deliveryConfigListOperationCompleted == null)) {
                this.deliveryConfigListOperationCompleted = new System.Threading.SendOrPostCallback(this.OndeliveryConfigListOperationCompleted);
            }
            this.InvokeAsync("deliveryConfigList", new object[] {
                        deliveryConfigListCallParms}, this.deliveryConfigListOperationCompleted, userState);
        }
        
        private void OndeliveryConfigListOperationCompleted(object arg) {
            if ((this.deliveryConfigListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.deliveryConfigListCompleted(this, new deliveryConfigListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a new contact information entry for the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userContactInfoSet permission and a group list that grants access 
    ///   to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userContactInfoSet permission, or none of the roles that would grant access to the 
    ///   user information through the userGet call have userContactInfoSet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an INVALID_ARGUMENT error code, if the specified 
    ///   delivery configuration is not valid, if contact information with the given 
    ///   label already exists, the value given for the contact information is 
    ///   not valid, or an attempt is made to flag multiple contact 
    ///   information as the default. 
    ///   </p>
    /// </summary>
    /// <param name="userContactInfoCreateCallParms">
    ///   userContactInfoCreateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userContactInfoCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserContactInfoCreateCallParms userContactInfoCreateCallParms) {
            this.Invoke("userContactInfoCreate", new object[] {
                        userContactInfoCreateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserContactInfoCreate(UserContactInfoCreateCallParms userContactInfoCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userContactInfoCreate", new object[] {
                        userContactInfoCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserContactInfoCreate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userContactInfoCreateAsync(UserContactInfoCreateCallParms userContactInfoCreateCallParms) {
            this.userContactInfoCreateAsync(userContactInfoCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void userContactInfoCreateAsync(UserContactInfoCreateCallParms userContactInfoCreateCallParms, object userState) {
            if ((this.userContactInfoCreateOperationCompleted == null)) {
                this.userContactInfoCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserContactInfoCreateOperationCompleted);
            }
            this.InvokeAsync("userContactInfoCreate", new object[] {
                        userContactInfoCreateCallParms}, this.userContactInfoCreateOperationCompleted, userState);
        }
        
        private void OnuserContactInfoCreateOperationCompleted(object arg) {
            if ((this.userContactInfoCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userContactInfoCreateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete contact information entries with the given labels from the 
    ///   given user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userContactInfoSet permission and a group list that grants access 
    ///   to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userContactInfoSet permission, or none of the roles that would grant access to the 
    ///   user information through the userGet call have userContactInfoSet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a CONTACTINFO_NOT_EXIST error code, if the specified 
    ///   contact information does not exist. 
    ///   </p>
    /// </summary>
    /// <param name="userContactInfoDeleteCallParms">
    ///   userContactInfoDeleteCallParms
    /// </param>
    /// <returns type="int">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userContactInfoDeleteReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public int userContactInfoDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserContactInfoDeleteCallParms userContactInfoDeleteCallParms) {
            object[] results = this.Invoke("userContactInfoDelete", new object[] {
                        userContactInfoDeleteCallParms});
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserContactInfoDelete(UserContactInfoDeleteCallParms userContactInfoDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userContactInfoDelete", new object[] {
                        userContactInfoDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public int EnduserContactInfoDelete(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public void userContactInfoDeleteAsync(UserContactInfoDeleteCallParms userContactInfoDeleteCallParms) {
            this.userContactInfoDeleteAsync(userContactInfoDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void userContactInfoDeleteAsync(UserContactInfoDeleteCallParms userContactInfoDeleteCallParms, object userState) {
            if ((this.userContactInfoDeleteOperationCompleted == null)) {
                this.userContactInfoDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserContactInfoDeleteOperationCompleted);
            }
            this.InvokeAsync("userContactInfoDelete", new object[] {
                        userContactInfoDeleteCallParms}, this.userContactInfoDeleteOperationCompleted, userState);
        }
        
        private void OnuserContactInfoDeleteOperationCompleted(object arg) {
            if ((this.userContactInfoDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userContactInfoDeleteCompleted(this, new userContactInfoDeleteCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Get the contact information of the given user, optionally returning 
    ///   only entries with the selected labels. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userContactInfoGet permission and a group list that grants access 
    ///   to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userContactInfoGet permission, or none of the roles that would grant access to the 
    ///   user information through the userGet call have userContactInfoGet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   </p>
    /// </summary>
    /// <param name="userContactInfoGetCallParms">
    ///   userContactInfoGetCallParms
    /// </param>
    /// <returns type="ContactInfo[]">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlArrayAttribute("userContactInfoGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        [return: System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public ContactInfo[] userContactInfoGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserContactInfoGetCallParms userContactInfoGetCallParms) {
            object[] results = this.Invoke("userContactInfoGet", new object[] {
                        userContactInfoGetCallParms});
            return ((ContactInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserContactInfoGet(UserContactInfoGetCallParms userContactInfoGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userContactInfoGet", new object[] {
                        userContactInfoGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public ContactInfo[] EnduserContactInfoGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ContactInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public void userContactInfoGetAsync(UserContactInfoGetCallParms userContactInfoGetCallParms) {
            this.userContactInfoGetAsync(userContactInfoGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userContactInfoGetAsync(UserContactInfoGetCallParms userContactInfoGetCallParms, object userState) {
            if ((this.userContactInfoGetOperationCompleted == null)) {
                this.userContactInfoGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserContactInfoGetOperationCompleted);
            }
            this.InvokeAsync("userContactInfoGet", new object[] {
                        userContactInfoGetCallParms}, this.userContactInfoGetOperationCompleted, userState);
        }
        
        private void OnuserContactInfoGetOperationCompleted(object arg) {
            if ((this.userContactInfoGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userContactInfoGetCompleted(this, new userContactInfoGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Update contact information for the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userContactInfoSet permission and a group list that grants access 
    ///   to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userContactInfoSet permission, or none of the roles that would grant access to the 
    ///   user information through the userGet call have userContactInfoSet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an INVALID_ARGUMENT error code, if the specified 
    ///   delivery configuration for any of the contact information objects is not 
    ///   valid, if contact information with the given label already exists, if 
    ///   the value given for the contact information is not valid, or an 
    ///   attempt is made to flag multiple contact information as the default. 
    ///   </p>
    /// </summary>
    /// <param name="userContactInfoSetCallParms">
    ///   userContactInfoSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userContactInfoSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserContactInfoSetCallParms userContactInfoSetCallParms) {
            this.Invoke("userContactInfoSet", new object[] {
                        userContactInfoSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserContactInfoSet(UserContactInfoSetCallParms userContactInfoSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userContactInfoSet", new object[] {
                        userContactInfoSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserContactInfoSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userContactInfoSetAsync(UserContactInfoSetCallParms userContactInfoSetCallParms) {
            this.userContactInfoSetAsync(userContactInfoSetCallParms, null);
        }
        
    ///  <remarks/>
        public void userContactInfoSetAsync(UserContactInfoSetCallParms userContactInfoSetCallParms, object userState) {
            if ((this.userContactInfoSetOperationCompleted == null)) {
                this.userContactInfoSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserContactInfoSetOperationCompleted);
            }
            this.InvokeAsync("userContactInfoSet", new object[] {
                        userContactInfoSetCallParms}, this.userContactInfoSetOperationCompleted, userState);
        }
        
        private void OnuserContactInfoSetOperationCompleted(object arg) {
            if ((this.userContactInfoSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userContactInfoSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a Temporary PIN for the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPinCreate permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. If either of the temporary PIN lifetime or 
    ///   the maximum number of uses is specified, one of these roles must 
    ///   have userPinOverridePolicy permission too. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a PIN_EXIST error code, if the user already has a 
    ///   temporary PIN and the Force flag was not set to true in the call. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if the temporary PIN 
    ///   lifetime is outside the acceptable range. 
    ///   </p>
    /// </summary>
    /// <param name="userPINCreateCallParms">
    ///   userPINCreateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userPINCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPINCreateCallParms userPINCreateCallParms) {
            this.Invoke("userPINCreate", new object[] {
                        userPINCreateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPINCreate(UserPINCreateCallParms userPINCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPINCreate", new object[] {
                        userPINCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserPINCreate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userPINCreateAsync(UserPINCreateCallParms userPINCreateCallParms) {
            this.userPINCreateAsync(userPINCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void userPINCreateAsync(UserPINCreateCallParms userPINCreateCallParms, object userState) {
            if ((this.userPINCreateOperationCompleted == null)) {
                this.userPINCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPINCreateOperationCompleted);
            }
            this.InvokeAsync("userPINCreate", new object[] {
                        userPINCreateCallParms}, this.userPINCreateOperationCompleted, userState);
        }
        
        private void OnuserPINCreateOperationCompleted(object arg) {
            if ((this.userPINCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPINCreateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the temporary PIN of the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPinDelete permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userPinDelete 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a PIN_NOT_EXIST error code, if the user does not have 
    ///   a temporary PIN. 
    ///   </p>
    /// </summary>
    /// <param name="userPINDeleteCallParms">
    ///   userPINDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userPINDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPINDeleteCallParms userPINDeleteCallParms) {
            this.Invoke("userPINDelete", new object[] {
                        userPINDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPINDelete(UserPINDeleteCallParms userPINDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPINDelete", new object[] {
                        userPINDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserPINDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userPINDeleteAsync(UserPINDeleteCallParms userPINDeleteCallParms) {
            this.userPINDeleteAsync(userPINDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void userPINDeleteAsync(UserPINDeleteCallParms userPINDeleteCallParms, object userState) {
            if ((this.userPINDeleteOperationCompleted == null)) {
                this.userPINDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPINDeleteOperationCompleted);
            }
            this.InvokeAsync("userPINDelete", new object[] {
                        userPINDeleteCallParms}, this.userPINDeleteOperationCompleted, userState);
        }
        
        private void OnuserPINDeleteOperationCompleted(object arg) {
            if ((this.userPINDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPINDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Get information about the temporary PIN of the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPinGet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of the 
    ///   administrator's roles. If one of these roles has the userPinView 
    ///   permission then the actual temporary PIN value is returned along with 
    ///   the information about the PIN. Otherwise, the temporary PIN value is 
    ///   not returned. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userPinGet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a PIN_NOT_EXIST error code, if the user does not have 
    ///   a temporary PIN. 
    ///   </p>
    /// </summary>
    /// <param name="userPINGetCallParms">
    ///   userPINGetCallParms
    /// </param>
    /// <returns type="UserPINInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userPINGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserPINInfo userPINGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPINGetCallParms userPINGetCallParms) {
            object[] results = this.Invoke("userPINGet", new object[] {
                        userPINGetCallParms});
            return ((UserPINInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPINGet(UserPINGetCallParms userPINGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPINGet", new object[] {
                        userPINGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserPINInfo EnduserPINGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserPINInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void userPINGetAsync(UserPINGetCallParms userPINGetCallParms) {
            this.userPINGetAsync(userPINGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userPINGetAsync(UserPINGetCallParms userPINGetCallParms, object userState) {
            if ((this.userPINGetOperationCompleted == null)) {
                this.userPINGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPINGetOperationCompleted);
            }
            this.InvokeAsync("userPINGet", new object[] {
                        userPINGetCallParms}, this.userPINGetOperationCompleted, userState);
        }
        
        private void OnuserPINGetOperationCompleted(object arg) {
            if ((this.userPINGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPINGetCompleted(this, new userPINGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Update information about the temporary PIN of the given user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPinSet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of the 
    ///   administrator's roles. If either of the temporary PIN lifetime or 
    ///   the maximum number of uses is specified, one of these roles must have 
    ///   userPinOverridePolicy permission too. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a PIN_NOT_EXIST error code, if the user does not have 
    ///   a temporary PIN. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if the temporary PIN 
    ///   lifetime is outside the acceptable range. 
    ///   </p>
    /// </summary>
    /// <param name="userPINSetCallParms">
    ///   userPINSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userPINSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPINSetCallParms userPINSetCallParms) {
            this.Invoke("userPINSet", new object[] {
                        userPINSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPINSet(UserPINSetCallParms userPINSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPINSet", new object[] {
                        userPINSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserPINSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userPINSetAsync(UserPINSetCallParms userPINSetCallParms) {
            this.userPINSetAsync(userPINSetCallParms, null);
        }
        
    ///  <remarks/>
        public void userPINSetAsync(UserPINSetCallParms userPINSetCallParms, object userState) {
            if ((this.userPINSetOperationCompleted == null)) {
                this.userPINSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPINSetOperationCompleted);
            }
            this.InvokeAsync("userPINSet", new object[] {
                        userPINSetCallParms}, this.userPINSetOperationCompleted, userState);
        }
        
        private void OnuserPINSetOperationCompleted(object arg) {
            if ((this.userPINSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPINSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a machine secret for the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userMachineSecretCreate permission and a group list that grants 
    ///   access to the user's group. Additionally, if the user is an 
    ///   administrator, one of these roles must also have a role list that grants access 
    ///   to all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userMachineSecretCreate permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_EXIST error code, if the user already has a 
    ///   machine secret with the given machine nonce. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if the user's machine 
    ///   secrets would exceed the maximum number or size, as defined by 
    ///   policy. 
    ///   </p>
    /// </summary>
    /// <param name="userMachineSecretCreateCallParms">
    ///   userMachineSecretCreateCallParms
    /// </param>
    /// <returns type="MachineSecretInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userMachineSecretCreateReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public MachineSecretInfo userMachineSecretCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserMachineSecretCreateCallParms userMachineSecretCreateCallParms) {
            object[] results = this.Invoke("userMachineSecretCreate", new object[] {
                        userMachineSecretCreateCallParms});
            return ((MachineSecretInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserMachineSecretCreate(UserMachineSecretCreateCallParms userMachineSecretCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userMachineSecretCreate", new object[] {
                        userMachineSecretCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public MachineSecretInfo EnduserMachineSecretCreate(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachineSecretInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void userMachineSecretCreateAsync(UserMachineSecretCreateCallParms userMachineSecretCreateCallParms) {
            this.userMachineSecretCreateAsync(userMachineSecretCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void userMachineSecretCreateAsync(UserMachineSecretCreateCallParms userMachineSecretCreateCallParms, object userState) {
            if ((this.userMachineSecretCreateOperationCompleted == null)) {
                this.userMachineSecretCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserMachineSecretCreateOperationCompleted);
            }
            this.InvokeAsync("userMachineSecretCreate", new object[] {
                        userMachineSecretCreateCallParms}, this.userMachineSecretCreateOperationCompleted, userState);
        }
        
        private void OnuserMachineSecretCreateOperationCompleted(object arg) {
            if ((this.userMachineSecretCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userMachineSecretCreateCompleted(this, new userMachineSecretCreateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the specified machine secret of the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userMachineSecretDelete permission and a group list that grants 
    ///   access to the user's group. Additionally, if the user is an 
    ///   administrator, one of these roles must also have a role list that grants access 
    ///   to all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userMachineSecretDelete permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have a machine secret with the specified machine nonce. 
    ///   </p>
    /// </summary>
    /// <param name="userMachineSecretDeleteCallParms">
    ///   userMachineSecretDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userMachineSecretDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserMachineSecretDeleteCallParms userMachineSecretDeleteCallParms) {
            this.Invoke("userMachineSecretDelete", new object[] {
                        userMachineSecretDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserMachineSecretDelete(UserMachineSecretDeleteCallParms userMachineSecretDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userMachineSecretDelete", new object[] {
                        userMachineSecretDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserMachineSecretDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userMachineSecretDeleteAsync(UserMachineSecretDeleteCallParms userMachineSecretDeleteCallParms) {
            this.userMachineSecretDeleteAsync(userMachineSecretDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void userMachineSecretDeleteAsync(UserMachineSecretDeleteCallParms userMachineSecretDeleteCallParms, object userState) {
            if ((this.userMachineSecretDeleteOperationCompleted == null)) {
                this.userMachineSecretDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserMachineSecretDeleteOperationCompleted);
            }
            this.InvokeAsync("userMachineSecretDelete", new object[] {
                        userMachineSecretDeleteCallParms}, this.userMachineSecretDeleteOperationCompleted, userState);
        }
        
        private void OnuserMachineSecretDeleteOperationCompleted(object arg) {
            if ((this.userMachineSecretDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userMachineSecretDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Get information about the specified machine secret of the given user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userMachineSecretGet permission and a group list that grants 
    ///   access to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userMachineSecretGet permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have a machine secret with the given nonce. 
    ///   </p>
    /// </summary>
    /// <param name="userMachineSecretGetCallParms">
    ///   userMachineSecretGetCallParms
    /// </param>
    /// <returns type="MachineSecretInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userMachineSecretGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public MachineSecretInfo userMachineSecretGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserMachineSecretGetCallParms userMachineSecretGetCallParms) {
            object[] results = this.Invoke("userMachineSecretGet", new object[] {
                        userMachineSecretGetCallParms});
            return ((MachineSecretInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserMachineSecretGet(UserMachineSecretGetCallParms userMachineSecretGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userMachineSecretGet", new object[] {
                        userMachineSecretGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public MachineSecretInfo EnduserMachineSecretGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachineSecretInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void userMachineSecretGetAsync(UserMachineSecretGetCallParms userMachineSecretGetCallParms) {
            this.userMachineSecretGetAsync(userMachineSecretGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userMachineSecretGetAsync(UserMachineSecretGetCallParms userMachineSecretGetCallParms, object userState) {
            if ((this.userMachineSecretGetOperationCompleted == null)) {
                this.userMachineSecretGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserMachineSecretGetOperationCompleted);
            }
            this.InvokeAsync("userMachineSecretGet", new object[] {
                        userMachineSecretGetCallParms}, this.userMachineSecretGetOperationCompleted, userState);
        }
        
        private void OnuserMachineSecretGetOperationCompleted(object arg) {
            if ((this.userMachineSecretGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userMachineSecretGetCompleted(this, new userMachineSecretGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Update information about the specified machine secret of the given 
    ///   user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userMachineSecretSet permission and a group list that grants 
    ///   access to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userMachineSecretSet permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have a machine secret with the given machine nonce. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if the size of the 
    ///   user's machine secrets would exceed the maximum size allowed by policy. 
    ///   </p>
    /// </summary>
    /// <param name="userMachineSecretSetCallParms">
    ///   userMachineSecretSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userMachineSecretSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserMachineSecretSetCallParms userMachineSecretSetCallParms) {
            this.Invoke("userMachineSecretSet", new object[] {
                        userMachineSecretSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserMachineSecretSet(UserMachineSecretSetCallParms userMachineSecretSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userMachineSecretSet", new object[] {
                        userMachineSecretSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserMachineSecretSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userMachineSecretSetAsync(UserMachineSecretSetCallParms userMachineSecretSetCallParms) {
            this.userMachineSecretSetAsync(userMachineSecretSetCallParms, null);
        }
        
    ///  <remarks/>
        public void userMachineSecretSetAsync(UserMachineSecretSetCallParms userMachineSecretSetCallParms, object userState) {
            if ((this.userMachineSecretSetOperationCompleted == null)) {
                this.userMachineSecretSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserMachineSecretSetOperationCompleted);
            }
            this.InvokeAsync("userMachineSecretSet", new object[] {
                        userMachineSecretSetCallParms}, this.userMachineSecretSetOperationCompleted, userState);
        }
        
        private void OnuserMachineSecretSetOperationCompleted(object arg) {
            if ((this.userMachineSecretSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userMachineSecretSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   List all of the machine secrets for the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userMachineSecretGet permission and a group list that grants 
    ///   access to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userMachineSecretGet permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   </p>
    /// </summary>
    /// <param name="userMachineSecretListCallParms">
    ///   userMachineSecretListCallParms
    /// </param>
    /// <returns type="MachineSecretInfo[]">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlArrayAttribute("userMachineSecretListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        [return: System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public MachineSecretInfo[] userMachineSecretList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserMachineSecretListCallParms userMachineSecretListCallParms) {
            object[] results = this.Invoke("userMachineSecretList", new object[] {
                        userMachineSecretListCallParms});
            return ((MachineSecretInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserMachineSecretList(UserMachineSecretListCallParms userMachineSecretListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userMachineSecretList", new object[] {
                        userMachineSecretListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public MachineSecretInfo[] EnduserMachineSecretList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachineSecretInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public void userMachineSecretListAsync(UserMachineSecretListCallParms userMachineSecretListCallParms) {
            this.userMachineSecretListAsync(userMachineSecretListCallParms, null);
        }
        
    ///  <remarks/>
        public void userMachineSecretListAsync(UserMachineSecretListCallParms userMachineSecretListCallParms, object userState) {
            if ((this.userMachineSecretListOperationCompleted == null)) {
                this.userMachineSecretListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserMachineSecretListOperationCompleted);
            }
            this.InvokeAsync("userMachineSecretList", new object[] {
                        userMachineSecretListCallParms}, this.userMachineSecretListOperationCompleted, userState);
        }
        
        private void OnuserMachineSecretListOperationCompleted(object arg) {
            if ((this.userMachineSecretListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userMachineSecretListCompleted(this, new userMachineSecretListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a one-time password (OTP) for the given user and return it. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userOtpCreate permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. If the OTP lifetime is specified, one of 
    ///   these roles must have userOtpOverridePolicy permission too. The actual 
    ///   OTP value, as opposed to just information about the OTP, is only 
    ///   returned if one of these roles has the userOtpView permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_EXIST error code, if the user already has an 
    ///   OTP and the Force flag was not set to true in the call. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if the OTP lifetime is 
    ///   outside the acceptable range. 
    ///   </p>
    /// </summary>
    /// <param name="userOTPCreateCallParms">
    ///   userOTPCreateCallParms
    /// </param>
    /// <returns type="UserOTPInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userOTPCreateReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserOTPInfo userOTPCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserOTPCreateCallParms userOTPCreateCallParms) {
            object[] results = this.Invoke("userOTPCreate", new object[] {
                        userOTPCreateCallParms});
            return ((UserOTPInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserOTPCreate(UserOTPCreateCallParms userOTPCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userOTPCreate", new object[] {
                        userOTPCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserOTPInfo EnduserOTPCreate(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserOTPInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void userOTPCreateAsync(UserOTPCreateCallParms userOTPCreateCallParms) {
            this.userOTPCreateAsync(userOTPCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void userOTPCreateAsync(UserOTPCreateCallParms userOTPCreateCallParms, object userState) {
            if ((this.userOTPCreateOperationCompleted == null)) {
                this.userOTPCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserOTPCreateOperationCompleted);
            }
            this.InvokeAsync("userOTPCreate", new object[] {
                        userOTPCreateCallParms}, this.userOTPCreateOperationCompleted, userState);
        }
        
        private void OnuserOTPCreateOperationCompleted(object arg) {
            if ((this.userOTPCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userOTPCreateCompleted(this, new userOTPCreateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the one-time password (OTP) of the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userOtpDelete permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userOtpDelete 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have an OTP. 
    ///   </p>
    /// </summary>
    /// <param name="userOTPDeleteCallParms">
    ///   userOTPDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userOTPDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserOTPDeleteCallParms userOTPDeleteCallParms) {
            this.Invoke("userOTPDelete", new object[] {
                        userOTPDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserOTPDelete(UserOTPDeleteCallParms userOTPDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userOTPDelete", new object[] {
                        userOTPDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserOTPDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userOTPDeleteAsync(UserOTPDeleteCallParms userOTPDeleteCallParms) {
            this.userOTPDeleteAsync(userOTPDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void userOTPDeleteAsync(UserOTPDeleteCallParms userOTPDeleteCallParms, object userState) {
            if ((this.userOTPDeleteOperationCompleted == null)) {
                this.userOTPDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserOTPDeleteOperationCompleted);
            }
            this.InvokeAsync("userOTPDelete", new object[] {
                        userOTPDeleteCallParms}, this.userOTPDeleteOperationCompleted, userState);
        }
        
        private void OnuserOTPDeleteOperationCompleted(object arg) {
            if ((this.userOTPDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userOTPDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Deliver the one-time password (OTP) for the given user to the 
    ///   specified contact information entry. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userOtpDeliver permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above, or if OTP delivery is not enabled for the user. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a CONTACTINFO_NOT_EXIST error code, if the user does 
    ///   not have a contact information entry with the given label. 
    ///   </p>
    /// </summary>
    /// <param name="userOTPDeliverCallParms">
    ///   userOTPDeliverCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userOTPDeliver([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserOTPDeliverCallParms userOTPDeliverCallParms) {
            this.Invoke("userOTPDeliver", new object[] {
                        userOTPDeliverCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserOTPDeliver(UserOTPDeliverCallParms userOTPDeliverCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userOTPDeliver", new object[] {
                        userOTPDeliverCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserOTPDeliver(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userOTPDeliverAsync(UserOTPDeliverCallParms userOTPDeliverCallParms) {
            this.userOTPDeliverAsync(userOTPDeliverCallParms, null);
        }
        
    ///  <remarks/>
        public void userOTPDeliverAsync(UserOTPDeliverCallParms userOTPDeliverCallParms, object userState) {
            if ((this.userOTPDeliverOperationCompleted == null)) {
                this.userOTPDeliverOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserOTPDeliverOperationCompleted);
            }
            this.InvokeAsync("userOTPDeliver", new object[] {
                        userOTPDeliverCallParms}, this.userOTPDeliverOperationCompleted, userState);
        }
        
        private void OnuserOTPDeliverOperationCompleted(object arg) {
            if ((this.userOTPDeliverCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userOTPDeliverCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Get information about the one-time password (OTP) of the given user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userOtpGet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of the 
    ///   administrator's roles. If one of these roles has the userOtpView 
    ///   permission then the actual OTP value is returned along with the 
    ///   information about the OTP. Otherwise, only information about the OTP is 
    ///   returned, but not the OTP value itself. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userOtpGet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a OBJECT_NOT_EXIST error code, if the user does not 
    ///   have an OTP. 
    ///   </p>
    /// </summary>
    /// <param name="userOTPGetCallParms">
    ///   userOTPGetCallParms
    /// </param>
    /// <returns type="UserOTPInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userOTPGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserOTPInfo userOTPGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserOTPGetCallParms userOTPGetCallParms) {
            object[] results = this.Invoke("userOTPGet", new object[] {
                        userOTPGetCallParms});
            return ((UserOTPInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserOTPGet(UserOTPGetCallParms userOTPGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userOTPGet", new object[] {
                        userOTPGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserOTPInfo EnduserOTPGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserOTPInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void userOTPGetAsync(UserOTPGetCallParms userOTPGetCallParms) {
            this.userOTPGetAsync(userOTPGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userOTPGetAsync(UserOTPGetCallParms userOTPGetCallParms, object userState) {
            if ((this.userOTPGetOperationCompleted == null)) {
                this.userOTPGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserOTPGetOperationCompleted);
            }
            this.InvokeAsync("userOTPGet", new object[] {
                        userOTPGetCallParms}, this.userOTPGetOperationCompleted, userState);
        }
        
        private void OnuserOTPGetOperationCompleted(object arg) {
            if ((this.userOTPGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userOTPGetCompleted(this, new userOTPGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a password for the given user. Will fail if the user already 
    ///   has a password. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPasswordCreate permission and a group list that grants access 
    ///   to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. If the password lifetime is 
    ///   specified, one of these roles must have userPasswordOverridePolicy permission 
    ///   too. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_EXIST error code, if the user already has a 
    ///   password. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if the auto-generate 
    ///   flag is set to true and a password is supplied in the parameters. 
    ///   </p>
    /// </summary>
    /// <param name="userPasswordCreateCallParms">
    ///   userPasswordCreateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userPasswordCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPasswordCreateCallParms userPasswordCreateCallParms) {
            this.Invoke("userPasswordCreate", new object[] {
                        userPasswordCreateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPasswordCreate(UserPasswordCreateCallParms userPasswordCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPasswordCreate", new object[] {
                        userPasswordCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserPasswordCreate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userPasswordCreateAsync(UserPasswordCreateCallParms userPasswordCreateCallParms) {
            this.userPasswordCreateAsync(userPasswordCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void userPasswordCreateAsync(UserPasswordCreateCallParms userPasswordCreateCallParms, object userState) {
            if ((this.userPasswordCreateOperationCompleted == null)) {
                this.userPasswordCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPasswordCreateOperationCompleted);
            }
            this.InvokeAsync("userPasswordCreate", new object[] {
                        userPasswordCreateCallParms}, this.userPasswordCreateOperationCompleted, userState);
        }
        
        private void OnuserPasswordCreateOperationCompleted(object arg) {
            if ((this.userPasswordCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPasswordCreateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Modify a password for the given user. Will fail if the user has no 
    ///   existing password. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPasswordSet permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all 
    ///   of the administrator's roles. If the password lifetime is specified, 
    ///   one of these roles must have userPasswordOverridePolicy permission 
    ///   too. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have a password. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if the auto-generate 
    ///   flag is set to true and a password is supplied in the parameters. 
    ///   </p>
    /// </summary>
    /// <param name="userPasswordSetCallParms">
    ///   userPasswordSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userPasswordSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPasswordSetCallParms userPasswordSetCallParms) {
            this.Invoke("userPasswordSet", new object[] {
                        userPasswordSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPasswordSet(UserPasswordSetCallParms userPasswordSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPasswordSet", new object[] {
                        userPasswordSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserPasswordSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userPasswordSetAsync(UserPasswordSetCallParms userPasswordSetCallParms) {
            this.userPasswordSetAsync(userPasswordSetCallParms, null);
        }
        
    ///  <remarks/>
        public void userPasswordSetAsync(UserPasswordSetCallParms userPasswordSetCallParms, object userState) {
            if ((this.userPasswordSetOperationCompleted == null)) {
                this.userPasswordSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPasswordSetOperationCompleted);
            }
            this.InvokeAsync("userPasswordSet", new object[] {
                        userPasswordSetCallParms}, this.userPasswordSetOperationCompleted, userState);
        }
        
        private void OnuserPasswordSetOperationCompleted(object arg) {
            if ((this.userPasswordSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPasswordSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Get the password for the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPasswordGet permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all 
    ///   of the administrator's roles. If one of these roles has the 
    ///   userPasswordView permission and a retrievable version of the password is stored 
    ///   then the actual password value is returned along with the 
    ///   information about it. Otherwise, only information about the password, but not 
    ///   the actual password, is returned. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have a password. 
    ///   </p>
    /// </summary>
    /// <param name="userPasswordGetCallParms">
    ///   userPasswordGetCallParms
    /// </param>
    /// <returns type="UserPasswordInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userPasswordGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserPasswordInfo userPasswordGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPasswordGetCallParms userPasswordGetCallParms) {
            object[] results = this.Invoke("userPasswordGet", new object[] {
                        userPasswordGetCallParms});
            return ((UserPasswordInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPasswordGet(UserPasswordGetCallParms userPasswordGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPasswordGet", new object[] {
                        userPasswordGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserPasswordInfo EnduserPasswordGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserPasswordInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void userPasswordGetAsync(UserPasswordGetCallParms userPasswordGetCallParms) {
            this.userPasswordGetAsync(userPasswordGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userPasswordGetAsync(UserPasswordGetCallParms userPasswordGetCallParms, object userState) {
            if ((this.userPasswordGetOperationCompleted == null)) {
                this.userPasswordGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPasswordGetOperationCompleted);
            }
            this.InvokeAsync("userPasswordGet", new object[] {
                        userPasswordGetCallParms}, this.userPasswordGetOperationCompleted, userState);
        }
        
        private void OnuserPasswordGetOperationCompleted(object arg) {
            if ((this.userPasswordGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPasswordGetCompleted(this, new userPasswordGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the password for the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPasswordDelete permission and a group list that grants access 
    ///   to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userPasswordDelete permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have a password. 
    ///   </p>
    /// </summary>
    /// <param name="userPasswordDeleteCallParms">
    ///   userPasswordDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userPasswordDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPasswordDeleteCallParms userPasswordDeleteCallParms) {
            this.Invoke("userPasswordDelete", new object[] {
                        userPasswordDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPasswordDelete(UserPasswordDeleteCallParms userPasswordDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPasswordDelete", new object[] {
                        userPasswordDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserPasswordDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userPasswordDeleteAsync(UserPasswordDeleteCallParms userPasswordDeleteCallParms) {
            this.userPasswordDeleteAsync(userPasswordDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void userPasswordDeleteAsync(UserPasswordDeleteCallParms userPasswordDeleteCallParms, object userState) {
            if ((this.userPasswordDeleteOperationCompleted == null)) {
                this.userPasswordDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPasswordDeleteOperationCompleted);
            }
            this.InvokeAsync("userPasswordDelete", new object[] {
                        userPasswordDeleteCallParms}, this.userPasswordDeleteOperationCompleted, userState);
        }
        
        private void OnuserPasswordDeleteOperationCompleted(object arg) {
            if ((this.userPasswordDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPasswordDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create the personal verification number (PVN) for the given user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPvnCreate permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userPvnCreate 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_EXIST error code, if the user already has a 
    ///   PVN. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if neither the PVN is 
    ///   specified nor the auto-generate flag is set to true, or if both the 
    ///   PVN is specified and the auto-generate flag is set to true, if the 
    ///   specified PVN contains non-numeric characters, or the PVN specified is 
    ///   not the length specified by the user's policy. 
    ///   6. A fault with a PVN_CHANGE_REQUIRED error code, if the change 
    ///   required flag is set to false but the policy dictates that a PVN must be 
    ///   changed when it is first used. 
    ///   </p>
    /// </summary>
    /// <param name="userPVNCreateCallParms">
    ///   userPVNCreateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userPVNCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPVNCreateCallParms userPVNCreateCallParms) {
            this.Invoke("userPVNCreate", new object[] {
                        userPVNCreateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPVNCreate(UserPVNCreateCallParms userPVNCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPVNCreate", new object[] {
                        userPVNCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserPVNCreate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userPVNCreateAsync(UserPVNCreateCallParms userPVNCreateCallParms) {
            this.userPVNCreateAsync(userPVNCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void userPVNCreateAsync(UserPVNCreateCallParms userPVNCreateCallParms, object userState) {
            if ((this.userPVNCreateOperationCompleted == null)) {
                this.userPVNCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPVNCreateOperationCompleted);
            }
            this.InvokeAsync("userPVNCreate", new object[] {
                        userPVNCreateCallParms}, this.userPVNCreateOperationCompleted, userState);
        }
        
        private void OnuserPVNCreateOperationCompleted(object arg) {
            if ((this.userPVNCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPVNCreateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Update the personal verification number (PVN) for the given user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPvnSet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of the 
    ///   administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have a PVN. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if the "change 
    ///   required" flag is not specified and neither the PVN is specified nor the 
    ///   auto-generate flag is set to true, if both the PVN is specified and the 
    ///   auto-generate flag is set to true, if the specified PVN contains 
    ///   non-numeric characters, or the length of the PVN specified is not the 
    ///   same as the PVN length specified by the user's policy. 
    ///   6. A fault with a PVN_INVALID error code, if both a new PVN value and 
    ///   the old PVN are specified, and the old PVN is not the correct value. 
    ///   7. A fault with a PVN_CHANGE_REQUIRED error code, if the change 
    ///   required flag is set to false but the policy dictates that a PVN must be 
    ///   changed when it is first used. 
    ///   </p>
    /// </summary>
    /// <param name="userPVNSetCallParms">
    ///   userPVNSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userPVNSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPVNSetCallParms userPVNSetCallParms) {
            this.Invoke("userPVNSet", new object[] {
                        userPVNSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPVNSet(UserPVNSetCallParms userPVNSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPVNSet", new object[] {
                        userPVNSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserPVNSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userPVNSetAsync(UserPVNSetCallParms userPVNSetCallParms) {
            this.userPVNSetAsync(userPVNSetCallParms, null);
        }
        
    ///  <remarks/>
        public void userPVNSetAsync(UserPVNSetCallParms userPVNSetCallParms, object userState) {
            if ((this.userPVNSetOperationCompleted == null)) {
                this.userPVNSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPVNSetOperationCompleted);
            }
            this.InvokeAsync("userPVNSet", new object[] {
                        userPVNSetCallParms}, this.userPVNSetOperationCompleted, userState);
        }
        
        private void OnuserPVNSetOperationCompleted(object arg) {
            if ((this.userPVNSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPVNSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the personal verification number (PVN) for the given user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPvnDelete permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userPvnDelete 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have a PVN. 
    ///   </p>
    /// </summary>
    /// <param name="userPVNDeleteCallParms">
    ///   userPVNDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userPVNDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPVNDeleteCallParms userPVNDeleteCallParms) {
            this.Invoke("userPVNDelete", new object[] {
                        userPVNDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPVNDelete(UserPVNDeleteCallParms userPVNDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPVNDelete", new object[] {
                        userPVNDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserPVNDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userPVNDeleteAsync(UserPVNDeleteCallParms userPVNDeleteCallParms) {
            this.userPVNDeleteAsync(userPVNDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void userPVNDeleteAsync(UserPVNDeleteCallParms userPVNDeleteCallParms, object userState) {
            if ((this.userPVNDeleteOperationCompleted == null)) {
                this.userPVNDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPVNDeleteOperationCompleted);
            }
            this.InvokeAsync("userPVNDelete", new object[] {
                        userPVNDeleteCallParms}, this.userPVNDeleteOperationCompleted, userState);
        }
        
        private void OnuserPVNDeleteOperationCompleted(object arg) {
            if ((this.userPVNDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPVNDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Get information about the personal verification number (PVN) of the 
    ///   given user. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userPvnGet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of the 
    ///   administrator's roles. If one of these roles has the userPvnView 
    ///   permission and the PVN was created by the administration service and has 
    ///   not yet been changed by the user, then the actual PVN value is 
    ///   returned along with the information about the PVN. Otherwise, only 
    ///   information about the PVN, but not the PVN value itself, is returned. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userPvnGet 
    ///   permission described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an OBJECT_NOT_EXIST error code, if the user does not 
    ///   have a PVN. 
    ///   </p>
    /// </summary>
    /// <param name="userPVNGetCallParms">
    ///   userPVNGetCallParms
    /// </param>
    /// <returns type="UserPVNInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userPVNGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserPVNInfo userPVNGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserPVNGetCallParms userPVNGetCallParms) {
            object[] results = this.Invoke("userPVNGet", new object[] {
                        userPVNGetCallParms});
            return ((UserPVNInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserPVNGet(UserPVNGetCallParms userPVNGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userPVNGet", new object[] {
                        userPVNGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserPVNInfo EnduserPVNGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserPVNInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void userPVNGetAsync(UserPVNGetCallParms userPVNGetCallParms) {
            this.userPVNGetAsync(userPVNGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userPVNGetAsync(UserPVNGetCallParms userPVNGetCallParms, object userState) {
            if ((this.userPVNGetOperationCompleted == null)) {
                this.userPVNGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserPVNGetOperationCompleted);
            }
            this.InvokeAsync("userPVNGet", new object[] {
                        userPVNGetCallParms}, this.userPVNGetOperationCompleted, userState);
        }
        
        private void OnuserPVNGetOperationCompleted(object arg) {
            if ((this.userPVNGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userPVNGetCompleted(this, new userPVNGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create a card for the given user. If the card serial number is 
    ///   specified in the UserCardParms parameter, the preproduced card with the 
    ///   given serial number will be assigned to the user; otherwise a new user 
    ///   card will be created with the next available serial number. 
    ///   <p>
    ///   To call this operation and specify a serial number of a card to assign 
    ///   to the user, at least one of the caller's roles must have the 
    ///   userCardAssign permission. To call it to create a brand new card for the 
    ///   user, at least one of the caller's roles must have the userCardCreate 
    ///   permission. Additionally, one of these roles must have a group list 
    ///   that grants access to the user's group, and if the user is an 
    ///   administrator, must also have a role list that grants access to all of the 
    ///   administrator's roles. If either of the card lifetime or a supersede 
    ///   date for an existing card are specified, one of the roles meeting all 
    ///   the previous conditions must have userCardOverridePolicy permission 
    ///   too. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a CARD_EXIST error code, if the user already has a 
    ///   card in the PENDING or HOLD_PENDING states. 
    ///   5. A fault with a CARD_NOT_EXIST error code, if a card serial number 
    ///   is supplied but that preproduced card does not exist. 
    ///   6. A fault with an INVALID_ARGUMENT error code, if a card serial 
    ///   number is supplied but that preproduced card does not belong to the same 
    ///   group as the user, or if the specified card lifetime or supersede 
    ///   dates are outside the acceptable range. 
    ///   7. A fault with an INVALID_CARD_STATE error code, if an attempt is 
    ///   made to create a card in the CURRENT or HOLD state when the user already 
    ///   has a card in the CURRENT or HOLD state. 
    ///   </p>
    /// </summary>
    /// <param name="userCardCreateCallParms">
    ///   userCardCreateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userCardCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserCardCreateCallParms userCardCreateCallParms) {
            this.Invoke("userCardCreate", new object[] {
                        userCardCreateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserCardCreate(UserCardCreateCallParms userCardCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userCardCreate", new object[] {
                        userCardCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserCardCreate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userCardCreateAsync(UserCardCreateCallParms userCardCreateCallParms) {
            this.userCardCreateAsync(userCardCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void userCardCreateAsync(UserCardCreateCallParms userCardCreateCallParms, object userState) {
            if ((this.userCardCreateOperationCompleted == null)) {
                this.userCardCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserCardCreateOperationCompleted);
            }
            this.InvokeAsync("userCardCreate", new object[] {
                        userCardCreateCallParms}, this.userCardCreateOperationCompleted, userState);
        }
        
        private void OnuserCardCreateOperationCompleted(object arg) {
            if ((this.userCardCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userCardCreateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the cards for the given user that match the given filter, and 
    ///   return the number of cards deleted. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userCardDelete permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. Alternately, if only cards in the 
    ///   CANCELED state are being deleted, only userCardDeleteCanceled permission is 
    ///   required, but the role list and group list requirements must still be 
    ///   met. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a CARD_NOT_EXIST error code, if none of the user's 
    ///   cards match the given filter. 
    ///   </p>
    /// </summary>
    /// <param name="userCardDeleteCallParms">
    ///   userCardDeleteCallParms
    /// </param>
    /// <returns type="int">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userCardDeleteReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public int userCardDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserCardDeleteCallParms userCardDeleteCallParms) {
            object[] results = this.Invoke("userCardDelete", new object[] {
                        userCardDeleteCallParms});
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserCardDelete(UserCardDeleteCallParms userCardDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userCardDelete", new object[] {
                        userCardDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public int EnduserCardDelete(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public void userCardDeleteAsync(UserCardDeleteCallParms userCardDeleteCallParms) {
            this.userCardDeleteAsync(userCardDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void userCardDeleteAsync(UserCardDeleteCallParms userCardDeleteCallParms, object userState) {
            if ((this.userCardDeleteOperationCompleted == null)) {
                this.userCardDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserCardDeleteOperationCompleted);
            }
            this.InvokeAsync("userCardDelete", new object[] {
                        userCardDeleteCallParms}, this.userCardDeleteOperationCompleted, userState);
        }
        
        private void OnuserCardDeleteOperationCompleted(object arg) {
            if ((this.userCardDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userCardDeleteCompleted(this, new userCardDeleteCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return cards for the given user that match the given filter.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userCardGet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. If one of these roles has the userCardView 
    ///   permission and the card grids are requested in the parameters, then 
    ///   the grids are returned along with the card information. Otherwise, the 
    ///   card grids are not returned. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userCardGet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   </p>
    /// </summary>
    /// <param name="userCardGetCallParms">
    ///   userCardGetCallParms
    /// </param>
    /// <returns type="UserCardInfo[]">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlArrayAttribute("userCardGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        [return: System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public UserCardInfo[] userCardGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserCardGetCallParms userCardGetCallParms) {
            object[] results = this.Invoke("userCardGet", new object[] {
                        userCardGetCallParms});
            return ((UserCardInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserCardGet(UserCardGetCallParms userCardGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userCardGet", new object[] {
                        userCardGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserCardInfo[] EnduserCardGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserCardInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public void userCardGetAsync(UserCardGetCallParms userCardGetCallParms) {
            this.userCardGetAsync(userCardGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userCardGetAsync(UserCardGetCallParms userCardGetCallParms, object userState) {
            if ((this.userCardGetOperationCompleted == null)) {
                this.userCardGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserCardGetOperationCompleted);
            }
            this.InvokeAsync("userCardGet", new object[] {
                        userCardGetCallParms}, this.userCardGetOperationCompleted, userState);
        }
        
        private void OnuserCardGetOperationCompleted(object arg) {
            if ((this.userCardGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userCardGetCompleted(this, new userCardGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Update cards for the given user that match the given filter, returning 
    ///   the number of cards that were updated. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userCardSet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. If either of the card lifetime, supersede 
    ///   lifetime, challenge count or least used cell count are specified, one 
    ///   of the roles meeting the previous conditions must have 
    ///   userCardOverridePolicy permission too. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an INVALID_ARGUMENT error code, if the temporary card 
    ///   lifetime or supersede lifetime is outside the acceptable range. 
    ///   5. A fault with an INVALID_CARD_STATE error code, if an attempt is 
    ///   made to move a card through an invalid state transition, e.g. 
    ///   change a CANCELED card to a state other than CANCELED, or move a 
    ///   CURRENT or HOLD card to the PENDING or HOLD_PENDING state. 
    ///   This error will also occur if an attempt is made to put more than one 
    ///   card in either of the CURRENT or HOLD states. 
    ///   </p>
    /// </summary>
    /// <param name="userCardSetCallParms">
    ///   userCardSetCallParms
    /// </param>
    /// <returns type="int">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userCardSetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public int userCardSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserCardSetCallParms userCardSetCallParms) {
            object[] results = this.Invoke("userCardSet", new object[] {
                        userCardSetCallParms});
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserCardSet(UserCardSetCallParms userCardSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userCardSet", new object[] {
                        userCardSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public int EnduserCardSet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public void userCardSetAsync(UserCardSetCallParms userCardSetCallParms) {
            this.userCardSetAsync(userCardSetCallParms, null);
        }
        
    ///  <remarks/>
        public void userCardSetAsync(UserCardSetCallParms userCardSetCallParms, object userState) {
            if ((this.userCardSetOperationCompleted == null)) {
                this.userCardSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserCardSetOperationCompleted);
            }
            this.InvokeAsync("userCardSet", new object[] {
                        userCardSetCallParms}, this.userCardSetOperationCompleted, userState);
        }
        
        private void OnuserCardSetOperationCompleted(object arg) {
            if ((this.userCardSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userCardSetCompleted(this, new userCardSetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Unassign the cards for the given user that match the given filter, 
    ///   returning the number of cards that were unassigned. 
    ///   Unassigned cards are moved to the preproduced card list and can be 
    ///   assigned to other users. Only cards in the PENDING or HOLD_PENDING 
    ///   states that were originally preproduced cards can be unassigned. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userCardUnassign permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all 
    ///   of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the permissions 
    ///   described above. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an INVALID_CARD_STATE error code, if an attempt is 
    ///   made to unassign a card that was not originally preproduced or is not in 
    ///   the PENDING or HOLD_PENDING state. 
    ///   </p>
    /// </summary>
    /// <param name="userCardUnassignCallParms">
    ///   userCardUnassignCallParms
    /// </param>
    /// <returns type="int">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userCardUnassignReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public int userCardUnassign([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserCardUnassignCallParms userCardUnassignCallParms) {
            object[] results = this.Invoke("userCardUnassign", new object[] {
                        userCardUnassignCallParms});
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserCardUnassign(UserCardUnassignCallParms userCardUnassignCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userCardUnassign", new object[] {
                        userCardUnassignCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public int EnduserCardUnassign(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public void userCardUnassignAsync(UserCardUnassignCallParms userCardUnassignCallParms) {
            this.userCardUnassignAsync(userCardUnassignCallParms, null);
        }
        
    ///  <remarks/>
        public void userCardUnassignAsync(UserCardUnassignCallParms userCardUnassignCallParms, object userState) {
            if ((this.userCardUnassignOperationCompleted == null)) {
                this.userCardUnassignOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserCardUnassignOperationCompleted);
            }
            this.InvokeAsync("userCardUnassign", new object[] {
                        userCardUnassignCallParms}, this.userCardUnassignOperationCompleted, userState);
        }
        
        private void OnuserCardUnassignOperationCompleted(object arg) {
            if ((this.userCardUnassignCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userCardUnassignCompleted(this, new userCardUnassignCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   List cards that match the given search filter. The returned list of 
    ///   cards will not be in any particular order. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userCardList permission. Cards matching the filter are only 
    ///   returned if the user that owns them is accessible to the caller using the 
    ///   roles with userCardList permission and the access rules described for 
    ///   the userGet operation. Card grids are only returned if the role 
    ///   granting access to the user also has userCardView permission and the grids 
    ///   are requested in the parameters. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userCardList 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if any of the groups, 
    ///   roles, or token vendor IDs specified in the search filter do not 
    ///   exist, or access to them is not granted by the user's roles with 
    ///   userCardList permission. 
    ///   </p>
    /// </summary>
    /// <param name="userCardListCallParms">
    ///   userCardListCallParms
    /// </param>
    /// <returns type="UserCardListResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userCardListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserCardListResult userCardList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserCardListCallParms userCardListCallParms) {
            object[] results = this.Invoke("userCardList", new object[] {
                        userCardListCallParms});
            return ((UserCardListResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserCardList(UserCardListCallParms userCardListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userCardList", new object[] {
                        userCardListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserCardListResult EnduserCardList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserCardListResult)(results[0]));
        }
        
    ///  <remarks/>
        public void userCardListAsync(UserCardListCallParms userCardListCallParms) {
            this.userCardListAsync(userCardListCallParms, null);
        }
        
    ///  <remarks/>
        public void userCardListAsync(UserCardListCallParms userCardListCallParms, object userState) {
            if ((this.userCardListOperationCompleted == null)) {
                this.userCardListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserCardListOperationCompleted);
            }
            this.InvokeAsync("userCardList", new object[] {
                        userCardListCallParms}, this.userCardListOperationCompleted, userState);
        }
        
        private void OnuserCardListOperationCompleted(object arg) {
            if ((this.userCardListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userCardListCompleted(this, new userCardListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Export cards that match the given search filter to a file on the 
    ///   server, returning the number of cards exported and the file they were 
    ///   exported to. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userCardExport permission. Cards matching the filter are only 
    ///   exported if the user that owns them is accessible to the caller using the 
    ///   roles with userCardExport permission and the access rules described 
    ///   for the userGet operation. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userCardList 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if any of the groups, 
    ///   roles, or token vendor IDs specified in the search filter do not 
    ///   exist, or access to them is not granted by the user's roles with 
    ///   userCardExport permission. 
    ///   </p>
    /// </summary>
    /// <param name="userCardExportCallParms">
    ///   userCardExportCallParms
    /// </param>
    /// <returns type="CardExportResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userCardExportReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public CardExportResult userCardExport([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserCardExportCallParms userCardExportCallParms) {
            object[] results = this.Invoke("userCardExport", new object[] {
                        userCardExportCallParms});
            return ((CardExportResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserCardExport(UserCardExportCallParms userCardExportCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userCardExport", new object[] {
                        userCardExportCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public CardExportResult EnduserCardExport(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CardExportResult)(results[0]));
        }
        
    ///  <remarks/>
        public void userCardExportAsync(UserCardExportCallParms userCardExportCallParms) {
            this.userCardExportAsync(userCardExportCallParms, null);
        }
        
    ///  <remarks/>
        public void userCardExportAsync(UserCardExportCallParms userCardExportCallParms, object userState) {
            if ((this.userCardExportOperationCompleted == null)) {
                this.userCardExportOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserCardExportOperationCompleted);
            }
            this.InvokeAsync("userCardExport", new object[] {
                        userCardExportCallParms}, this.userCardExportOperationCompleted, userState);
        }
        
        private void OnuserCardExportOperationCompleted(object arg) {
            if ((this.userCardExportCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userCardExportCompleted(this, new userCardExportCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Assign a token to the given user.
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenAssign permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all 
    ///   of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userTokenAssign permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a TOKEN_EXIST error code, if the user already has a 
    ///   token in the PENDING or HOLD_PENDING states. 
    ///   5. A fault with a TOKEN_NOT_EXIST error code, if an unassigned token 
    ///   with the given serial number does not exist. 
    ///   6. A fault with an OBJECT_NOT_EXIST error code, if the given token 
    ///   vendor ID does not exist. 
    ///   7. A fault with an INVALID_ARGUMENT error code, if the token being 
    ///   assigned does not belong to the same group as the user. 
    ///   8. A fault with an INVALID_TOKEN_STATE error code, if an attempt is 
    ///   made to assign a token in the CURRENT or HOLD state when the user 
    ///   already has a token in the CURRENT or HOLD state. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenAssignCallParms">
    ///   userTokenAssignCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void userTokenAssign([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenAssignCallParms userTokenAssignCallParms) {
            this.Invoke("userTokenAssign", new object[] {
                        userTokenAssignCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenAssign(UserTokenAssignCallParms userTokenAssignCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenAssign", new object[] {
                        userTokenAssignCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EnduserTokenAssign(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void userTokenAssignAsync(UserTokenAssignCallParms userTokenAssignCallParms) {
            this.userTokenAssignAsync(userTokenAssignCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenAssignAsync(UserTokenAssignCallParms userTokenAssignCallParms, object userState) {
            if ((this.userTokenAssignOperationCompleted == null)) {
                this.userTokenAssignOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenAssignOperationCompleted);
            }
            this.InvokeAsync("userTokenAssign", new object[] {
                        userTokenAssignCallParms}, this.userTokenAssignOperationCompleted, userState);
        }
        
        private void OnuserTokenAssignOperationCompleted(object arg) {
            if ((this.userTokenAssignCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenAssignCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the tokens for the given user that match the given filter, 
    ///   returning the number of tokens deleted. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenDelete permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all 
    ///   of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userTokenDelete permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a TOKEN_NOT_EXIST error code, if none of the user's 
    ///   tokens match the given filter. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenDeleteCallParms">
    ///   userTokenDeleteCallParms
    /// </param>
    /// <returns type="int">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userTokenDeleteReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public int userTokenDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenDeleteCallParms userTokenDeleteCallParms) {
            object[] results = this.Invoke("userTokenDelete", new object[] {
                        userTokenDeleteCallParms});
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenDelete(UserTokenDeleteCallParms userTokenDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenDelete", new object[] {
                        userTokenDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public int EnduserTokenDelete(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public void userTokenDeleteAsync(UserTokenDeleteCallParms userTokenDeleteCallParms) {
            this.userTokenDeleteAsync(userTokenDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenDeleteAsync(UserTokenDeleteCallParms userTokenDeleteCallParms, object userState) {
            if ((this.userTokenDeleteOperationCompleted == null)) {
                this.userTokenDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenDeleteOperationCompleted);
            }
            this.InvokeAsync("userTokenDelete", new object[] {
                        userTokenDeleteCallParms}, this.userTokenDeleteOperationCompleted, userState);
        }
        
        private void OnuserTokenDeleteOperationCompleted(object arg) {
            if ((this.userTokenDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenDeleteCompleted(this, new userTokenDeleteCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return tokens for the given user that match the given filter. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenGet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userTokenGet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenGetCallParms">
    ///   userTokenGetCallParms
    /// </param>
    /// <returns type="UserTokenInfo[]">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlArrayAttribute("userTokenGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        [return: System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public UserTokenInfo[] userTokenGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenGetCallParms userTokenGetCallParms) {
            object[] results = this.Invoke("userTokenGet", new object[] {
                        userTokenGetCallParms});
            return ((UserTokenInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenGet(UserTokenGetCallParms userTokenGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenGet", new object[] {
                        userTokenGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserTokenInfo[] EnduserTokenGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserTokenInfo[])(results[0]));
        }
        
    ///  <remarks/>
        public void userTokenGetAsync(UserTokenGetCallParms userTokenGetCallParms) {
            this.userTokenGetAsync(userTokenGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenGetAsync(UserTokenGetCallParms userTokenGetCallParms, object userState) {
            if ((this.userTokenGetOperationCompleted == null)) {
                this.userTokenGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenGetOperationCompleted);
            }
            this.InvokeAsync("userTokenGet", new object[] {
                        userTokenGetCallParms}, this.userTokenGetOperationCompleted, userState);
        }
        
        private void OnuserTokenGetOperationCompleted(object arg) {
            if ((this.userTokenGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenGetCompleted(this, new userTokenGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Update tokens for the given user that match the given filter, 
    ///   returning the number of tokens that were updated. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenSet permission and a group list that grants access to the 
    ///   user's group. Additionally, if the user is an administrator, one of 
    ///   these roles must also have a role list that grants access to all of 
    ///   the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userTokenSet 
    ///   permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an INVALID_TOKEN_STATE error code, if an attempt is 
    ///   made to move a token through an invalid state transition, e.g. 
    ///   change a CANCELED token to a state other than CANCELED, or move a 
    ///   CURRENT or HOLD token to the PENDING or HOLD_PENDING state. 
    ///   This error will also occur if an attempt is made to put more than one 
    ///   token in either of the CURRENT or HOLD states. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenSetCallParms">
    ///   userTokenSetCallParms
    /// </param>
    /// <returns type="int">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userTokenSetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public int userTokenSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenSetCallParms userTokenSetCallParms) {
            object[] results = this.Invoke("userTokenSet", new object[] {
                        userTokenSetCallParms});
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenSet(UserTokenSetCallParms userTokenSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenSet", new object[] {
                        userTokenSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public int EnduserTokenSet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public void userTokenSetAsync(UserTokenSetCallParms userTokenSetCallParms) {
            this.userTokenSetAsync(userTokenSetCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenSetAsync(UserTokenSetCallParms userTokenSetCallParms, object userState) {
            if ((this.userTokenSetOperationCompleted == null)) {
                this.userTokenSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenSetOperationCompleted);
            }
            this.InvokeAsync("userTokenSet", new object[] {
                        userTokenSetCallParms}, this.userTokenSetOperationCompleted, userState);
        }
        
        private void OnuserTokenSetOperationCompleted(object arg) {
            if ((this.userTokenSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenSetCompleted(this, new userTokenSetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Unassign the tokens for the given user that match the given filter, 
    ///   returning the number of tokens that were unassigned. 
    ///   The tokens that being unassigned are moved to the unassigned token 
    ///   list. 
    ///   There is no token state limitation for token unassign operation; user 
    ///   tokens in any states can be unassigned. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenUnassign permission and a group list that grants access 
    ///   to the user's group. Additionally, if the user is an administrator, 
    ///   one of these roles must also have a role list that grants access to all 
    ///   of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userTokenUnassign permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with an TOKEN_NOT_EXIST error code, if no tokens match the 
    ///   given search filter. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenUnassignCallParms">
    ///   userTokenUnassignCallParms
    /// </param>
    /// <returns type="int">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userTokenUnassignReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public int userTokenUnassign([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenUnassignCallParms userTokenUnassignCallParms) {
            object[] results = this.Invoke("userTokenUnassign", new object[] {
                        userTokenUnassignCallParms});
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenUnassign(UserTokenUnassignCallParms userTokenUnassignCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenUnassign", new object[] {
                        userTokenUnassignCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public int EnduserTokenUnassign(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
    ///  <remarks/>
        public void userTokenUnassignAsync(UserTokenUnassignCallParms userTokenUnassignCallParms) {
            this.userTokenUnassignAsync(userTokenUnassignCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenUnassignAsync(UserTokenUnassignCallParms userTokenUnassignCallParms, object userState) {
            if ((this.userTokenUnassignOperationCompleted == null)) {
                this.userTokenUnassignOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenUnassignOperationCompleted);
            }
            this.InvokeAsync("userTokenUnassign", new object[] {
                        userTokenUnassignCallParms}, this.userTokenUnassignOperationCompleted, userState);
        }
        
        private void OnuserTokenUnassignOperationCompleted(object arg) {
            if ((this.userTokenUnassignCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenUnassignCompleted(this, new userTokenUnassignCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Get a token challenge for the token specified by the given filter. The 
    ///   challenge will be retained until successfully answered. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenAuthenticate permission and a group list that grants 
    ///   access to the user's group. Additionally, if the user is an 
    ///   administrator, one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userTokenAuthenticate permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a TOKEN_NOT_EXIST error code, if none of the user's 
    ///   tokens match the filter. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if more than one token 
    ///   matches the filter. 
    ///   6. A fault with a NOT_SUPPORTED error code, if the token does not 
    ///   support challenges. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenChallengeGetCallParms">
    ///   userTokenChallengeGetCallParms
    /// </param>
    /// <returns type="string">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userTokenChallengeGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public string userTokenChallengeGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenChallengeGetCallParms userTokenChallengeGetCallParms) {
            object[] results = this.Invoke("userTokenChallengeGet", new object[] {
                        userTokenChallengeGetCallParms});
            return ((string)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenChallengeGet(UserTokenChallengeGetCallParms userTokenChallengeGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenChallengeGet", new object[] {
                        userTokenChallengeGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public string EnduserTokenChallengeGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
    ///  <remarks/>
        public void userTokenChallengeGetAsync(UserTokenChallengeGetCallParms userTokenChallengeGetCallParms) {
            this.userTokenChallengeGetAsync(userTokenChallengeGetCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenChallengeGetAsync(UserTokenChallengeGetCallParms userTokenChallengeGetCallParms, object userState) {
            if ((this.userTokenChallengeGetOperationCompleted == null)) {
                this.userTokenChallengeGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenChallengeGetOperationCompleted);
            }
            this.InvokeAsync("userTokenChallengeGet", new object[] {
                        userTokenChallengeGetCallParms}, this.userTokenChallengeGetOperationCompleted, userState);
        }
        
        private void OnuserTokenChallengeGetOperationCompleted(object arg) {
            if ((this.userTokenChallengeGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenChallengeGetCompleted(this, new userTokenChallengeGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Authenticate the response against the token specified by the given 
    ///   filter. A successful authentication will not change the token state. An 
    ///   error is returned if the token does not authenticate. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenAuthenticate permission and a group list that grants 
    ///   access to the user's group. Additionally, if the user is an 
    ///   administrator, one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userTokenAuthenticate permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a TOKEN_NOT_EXIST error code, if none of the user's 
    ///   tokens match the filter. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if more than one token 
    ///   matches the filter. 
    ///   6. A fault with an INVALID_RESPONSE error code, if the response is not 
    ///   correct. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenAuthenticateCallParms">
    ///   userTokenAuthenticateCallParms
    /// </param>
    /// <returns type="string">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userTokenAuthenticateReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public string userTokenAuthenticate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenAuthenticateCallParms userTokenAuthenticateCallParms) {
            object[] results = this.Invoke("userTokenAuthenticate", new object[] {
                        userTokenAuthenticateCallParms});
            return ((string)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenAuthenticate(UserTokenAuthenticateCallParms userTokenAuthenticateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenAuthenticate", new object[] {
                        userTokenAuthenticateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public string EnduserTokenAuthenticate(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
    ///  <remarks/>
        public void userTokenAuthenticateAsync(UserTokenAuthenticateCallParms userTokenAuthenticateCallParms) {
            this.userTokenAuthenticateAsync(userTokenAuthenticateCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenAuthenticateAsync(UserTokenAuthenticateCallParms userTokenAuthenticateCallParms, object userState) {
            if ((this.userTokenAuthenticateOperationCompleted == null)) {
                this.userTokenAuthenticateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenAuthenticateOperationCompleted);
            }
            this.InvokeAsync("userTokenAuthenticate", new object[] {
                        userTokenAuthenticateCallParms}, this.userTokenAuthenticateOperationCompleted, userState);
        }
        
        private void OnuserTokenAuthenticateOperationCompleted(object arg) {
            if ((this.userTokenAuthenticateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenAuthenticateCompleted(this, new userTokenAuthenticateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Authenticate the response against the token specified by the given 
    ///   filter using a previously generated challenge. 
    ///   A successful authentication will not change the token state. This call 
    ///   should only be made after a matching call to userTokenChallengeGet. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenAuthenticate permission and a group list that grants 
    ///   access to the user's group. Additionally, if the user is an 
    ///   administrator, one of these roles must also have a role list that grants access to 
    ///   all of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userTokenAuthenticate permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a TOKEN_NOT_EXIST error code, if none of the user's 
    ///   tokens match the filter. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if more than one token 
    ///   matches the filter. 
    ///   6. A fault with a NOT_SUPPORTED error code, if the token does not 
    ///   support challenges. 
    ///   7. A fault with a CHALLENGE_NOT_EXIST error code, if there is no 
    ///   retained token challenge. This will occur if no prior call was made to 
    ///   userTokenChallengeGet. 
    ///   8. A fault with an INVALID_RESPONSE error code, if the response to the 
    ///   challenge is not correct. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenChallengeAuthenticateCallParms">
    ///   userTokenChallengeAuthenticateCallParms
    /// </param>
    /// <returns type="string">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userTokenAuthenticateReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public string userTokenChallengeAuthenticate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenChallengeAuthenticateCallParms userTokenChallengeAuthenticateCallParms) {
            object[] results = this.Invoke("userTokenChallengeAuthenticate", new object[] {
                        userTokenChallengeAuthenticateCallParms});
            return ((string)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenChallengeAuthenticate(UserTokenChallengeAuthenticateCallParms userTokenChallengeAuthenticateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenChallengeAuthenticate", new object[] {
                        userTokenChallengeAuthenticateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public string EnduserTokenChallengeAuthenticate(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
    ///  <remarks/>
        public void userTokenChallengeAuthenticateAsync(UserTokenChallengeAuthenticateCallParms userTokenChallengeAuthenticateCallParms) {
            this.userTokenChallengeAuthenticateAsync(userTokenChallengeAuthenticateCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenChallengeAuthenticateAsync(UserTokenChallengeAuthenticateCallParms userTokenChallengeAuthenticateCallParms, object userState) {
            if ((this.userTokenChallengeAuthenticateOperationCompleted == null)) {
                this.userTokenChallengeAuthenticateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenChallengeAuthenticateOperationCompleted);
            }
            this.InvokeAsync("userTokenChallengeAuthenticate", new object[] {
                        userTokenChallengeAuthenticateCallParms}, this.userTokenChallengeAuthenticateOperationCompleted, userState);
        }
        
        private void OnuserTokenChallengeAuthenticateOperationCompleted(object arg) {
            if ((this.userTokenChallengeAuthenticateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenChallengeAuthenticateCompleted(this, new userTokenChallengeAuthenticateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Unlock the token specified token using the given challenge generated 
    ///   by the token. The server will return an unlock code which must be 
    ///   entered into the token to complete the unlock operation. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenUnlock permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all 
    ///   of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userTokenUnlock permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a TOKEN_NOT_EXIST error code, if none of the user's 
    ///   tokens match the filter. 
    ///   5. A fault with an INVALID_ARGUMENT error code, if more than one token 
    ///   matches the filter, or the unlock challenge is not valid. 
    ///   6. A fault with a NOT_SUPPORTED error code, if the token does not 
    ///   support the unlock operation. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenUnlockCallParms">
    ///   userTokenUnlockCallParms
    /// </param>
    /// <returns type="UserTokenUnlockResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userTokenUnlockReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserTokenUnlockResult userTokenUnlock([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenUnlockCallParms userTokenUnlockCallParms) {
            object[] results = this.Invoke("userTokenUnlock", new object[] {
                        userTokenUnlockCallParms});
            return ((UserTokenUnlockResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenUnlock(UserTokenUnlockCallParms userTokenUnlockCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenUnlock", new object[] {
                        userTokenUnlockCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserTokenUnlockResult EnduserTokenUnlock(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserTokenUnlockResult)(results[0]));
        }
        
    ///  <remarks/>
        public void userTokenUnlockAsync(UserTokenUnlockCallParms userTokenUnlockCallParms) {
            this.userTokenUnlockAsync(userTokenUnlockCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenUnlockAsync(UserTokenUnlockCallParms userTokenUnlockCallParms, object userState) {
            if ((this.userTokenUnlockOperationCompleted == null)) {
                this.userTokenUnlockOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenUnlockOperationCompleted);
            }
            this.InvokeAsync("userTokenUnlock", new object[] {
                        userTokenUnlockCallParms}, this.userTokenUnlockOperationCompleted, userState);
        }
        
        private void OnuserTokenUnlockOperationCompleted(object arg) {
            if ((this.userTokenUnlockCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenUnlockCompleted(this, new userTokenUnlockCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   List tokens that match the given search filter. The returned list of 
    ///   tokens will not be in any particular order. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userTokenList permission. Tokens matching the filter are only 
    ///   returned if the user that owns them is accessible to the caller using the 
    ///   roles with userTokenList permission and the access rules described 
    ///   for the userGet operation. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the userTokenList 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if any of the groups, 
    ///   roles, or token vendor IDs specified in the search filter do not 
    ///   exist, or access to them is not granted by the user's roles with 
    ///   userTokenList permission. 
    ///   </p>
    /// </summary>
    /// <param name="userTokenListCallParms">
    ///   userTokenListCallParms
    /// </param>
    /// <returns type="UserTokenListResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("userTokenListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public UserTokenListResult userTokenList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] UserTokenListCallParms userTokenListCallParms) {
            object[] results = this.Invoke("userTokenList", new object[] {
                        userTokenListCallParms});
            return ((UserTokenListResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginuserTokenList(UserTokenListCallParms userTokenListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("userTokenList", new object[] {
                        userTokenListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public UserTokenListResult EnduserTokenList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserTokenListResult)(results[0]));
        }
        
    ///  <remarks/>
        public void userTokenListAsync(UserTokenListCallParms userTokenListCallParms) {
            this.userTokenListAsync(userTokenListCallParms, null);
        }
        
    ///  <remarks/>
        public void userTokenListAsync(UserTokenListCallParms userTokenListCallParms, object userState) {
            if ((this.userTokenListOperationCompleted == null)) {
                this.userTokenListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnuserTokenListOperationCompleted);
            }
            this.InvokeAsync("userTokenList", new object[] {
                        userTokenListCallParms}, this.userTokenListOperationCompleted, userState);
        }
        
        private void OnuserTokenListOperationCompleted(object arg) {
            if ((this.userTokenListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.userTokenListCompleted(this, new userTokenListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Create one or more preproduced cards, whose serial numbers starting 
    ///   with next available serial number, and return information about the 
    ///   cards created. 
    ///   <p>
    ///   Callers of this operation must have a role that has the cardCreate 
    ///   permission and a group list that grants access to the group that the 
    ///   cards are to be created in. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the cardCreate 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the group to create 
    ///   the cards in to does not exist or is not accessible to the caller. 
    ///   </p>
    /// </summary>
    /// <param name="preproducedCardCreateCallParms">
    ///   preproducedCardCreateCallParms
    /// </param>
    /// <returns type="PreproducedCardCreateResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("preproducedCardCreateReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public PreproducedCardCreateResult preproducedCardCreate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PreproducedCardCreateCallParms preproducedCardCreateCallParms) {
            object[] results = this.Invoke("preproducedCardCreate", new object[] {
                        preproducedCardCreateCallParms});
            return ((PreproducedCardCreateResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpreproducedCardCreate(PreproducedCardCreateCallParms preproducedCardCreateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("preproducedCardCreate", new object[] {
                        preproducedCardCreateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public PreproducedCardCreateResult EndpreproducedCardCreate(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PreproducedCardCreateResult)(results[0]));
        }
        
    ///  <remarks/>
        public void preproducedCardCreateAsync(PreproducedCardCreateCallParms preproducedCardCreateCallParms) {
            this.preproducedCardCreateAsync(preproducedCardCreateCallParms, null);
        }
        
    ///  <remarks/>
        public void preproducedCardCreateAsync(PreproducedCardCreateCallParms preproducedCardCreateCallParms, object userState) {
            if ((this.preproducedCardCreateOperationCompleted == null)) {
                this.preproducedCardCreateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpreproducedCardCreateOperationCompleted);
            }
            this.InvokeAsync("preproducedCardCreate", new object[] {
                        preproducedCardCreateCallParms}, this.preproducedCardCreateOperationCompleted, userState);
        }
        
        private void OnpreproducedCardCreateOperationCompleted(object arg) {
            if ((this.preproducedCardCreateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.preproducedCardCreateCompleted(this, new preproducedCardCreateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the preproduced card with the given serial number.
    ///   <p>
    ///   Callers of this operation must have a role that has the cardDelete 
    ///   permission and a group list that grants access to the group that the 
    ///   card being deleted belongs to. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the cardDelete 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the given serial 
    ///   number is not a valid card serial number. 
    ///   3. A fault with a CARD_NOT_EXIST error code, if the given card does 
    ///   not exist, or belongs to a group that the caller does not have access 
    ///   to. 
    ///   </p>
    /// </summary>
    /// <param name="preproducedCardDeleteCallParms">
    ///   preproducedCardDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void preproducedCardDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PreproducedCardDeleteCallParms preproducedCardDeleteCallParms) {
            this.Invoke("preproducedCardDelete", new object[] {
                        preproducedCardDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpreproducedCardDelete(PreproducedCardDeleteCallParms preproducedCardDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("preproducedCardDelete", new object[] {
                        preproducedCardDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndpreproducedCardDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void preproducedCardDeleteAsync(PreproducedCardDeleteCallParms preproducedCardDeleteCallParms) {
            this.preproducedCardDeleteAsync(preproducedCardDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void preproducedCardDeleteAsync(PreproducedCardDeleteCallParms preproducedCardDeleteCallParms, object userState) {
            if ((this.preproducedCardDeleteOperationCompleted == null)) {
                this.preproducedCardDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpreproducedCardDeleteOperationCompleted);
            }
            this.InvokeAsync("preproducedCardDelete", new object[] {
                        preproducedCardDeleteCallParms}, this.preproducedCardDeleteOperationCompleted, userState);
        }
        
        private void OnpreproducedCardDeleteOperationCompleted(object arg) {
            if ((this.preproducedCardDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.preproducedCardDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return the preproduced card with the given serial number.
    ///   <p>
    ///   Callers of this operation must have a role that has the cardGet 
    ///   permission and a group list that grants access to the group that the card 
    ///   being retrieved belongs to. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the cardGet 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the given serial 
    ///   number is not a valid preproduced card serial number. 
    ///   3. A fault with a CARD_NOT_EXIST error code, if the given card does 
    ///   not exist, or belongs to a group that the caller does not have access 
    ///   to. 
    ///   </p>
    /// </summary>
    /// <param name="preproducedCardGetCallParms">
    ///   preproducedCardGetCallParms
    /// </param>
    /// <returns type="PreproducedCardInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("preproducedCardGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public PreproducedCardInfo preproducedCardGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PreproducedCardGetCallParms preproducedCardGetCallParms) {
            object[] results = this.Invoke("preproducedCardGet", new object[] {
                        preproducedCardGetCallParms});
            return ((PreproducedCardInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpreproducedCardGet(PreproducedCardGetCallParms preproducedCardGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("preproducedCardGet", new object[] {
                        preproducedCardGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public PreproducedCardInfo EndpreproducedCardGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PreproducedCardInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void preproducedCardGetAsync(PreproducedCardGetCallParms preproducedCardGetCallParms) {
            this.preproducedCardGetAsync(preproducedCardGetCallParms, null);
        }
        
    ///  <remarks/>
        public void preproducedCardGetAsync(PreproducedCardGetCallParms preproducedCardGetCallParms, object userState) {
            if ((this.preproducedCardGetOperationCompleted == null)) {
                this.preproducedCardGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpreproducedCardGetOperationCompleted);
            }
            this.InvokeAsync("preproducedCardGet", new object[] {
                        preproducedCardGetCallParms}, this.preproducedCardGetOperationCompleted, userState);
        }
        
        private void OnpreproducedCardGetOperationCompleted(object arg) {
            if ((this.preproducedCardGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.preproducedCardGetCompleted(this, new preproducedCardGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Update preproduced card with given serial number.
    ///   <p>
    ///   Callers of this operation must have a role that has the cardSet 
    ///   permission and a group list that grants access to the group that the card 
    ///   being updated belongs to. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the cardSet 
    ///   permission, or the group the card is assigned to is being changed and the 
    ///   caller does not have a role granting access to the destination group. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the given serial 
    ///   number is not a valid card serial number. 
    ///   3. A fault with a CARD_NOT_EXIST error code, if the given card does 
    ///   not exist, or belongs to a group that the caller does not have access 
    ///   to. 
    ///   </p>
    /// </summary>
    /// <param name="preproducedCardSetCallParms">
    ///   preproducedCardSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void preproducedCardSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PreproducedCardSetCallParms preproducedCardSetCallParms) {
            this.Invoke("preproducedCardSet", new object[] {
                        preproducedCardSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpreproducedCardSet(PreproducedCardSetCallParms preproducedCardSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("preproducedCardSet", new object[] {
                        preproducedCardSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndpreproducedCardSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void preproducedCardSetAsync(PreproducedCardSetCallParms preproducedCardSetCallParms) {
            this.preproducedCardSetAsync(preproducedCardSetCallParms, null);
        }
        
    ///  <remarks/>
        public void preproducedCardSetAsync(PreproducedCardSetCallParms preproducedCardSetCallParms, object userState) {
            if ((this.preproducedCardSetOperationCompleted == null)) {
                this.preproducedCardSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpreproducedCardSetOperationCompleted);
            }
            this.InvokeAsync("preproducedCardSet", new object[] {
                        preproducedCardSetCallParms}, this.preproducedCardSetOperationCompleted, userState);
        }
        
        private void OnpreproducedCardSetOperationCompleted(object arg) {
            if ((this.preproducedCardSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.preproducedCardSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   List preproduced cards that match the given search filter.
    ///   <p>
    ///   Callers of this operation must have a role that has the cardList 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the cardList 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if groups are 
    ///   specified in the filter that either do not exist or are not accessible to the 
    ///   caller. 
    ///   </p>
    /// </summary>
    /// <param name="preproducedCardListCallParms">
    ///   preproducedCardListCallParms
    /// </param>
    /// <returns type="PreproducedCardListResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("preproducedCardListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public PreproducedCardListResult preproducedCardList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PreproducedCardListCallParms preproducedCardListCallParms) {
            object[] results = this.Invoke("preproducedCardList", new object[] {
                        preproducedCardListCallParms});
            return ((PreproducedCardListResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpreproducedCardList(PreproducedCardListCallParms preproducedCardListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("preproducedCardList", new object[] {
                        preproducedCardListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public PreproducedCardListResult EndpreproducedCardList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PreproducedCardListResult)(results[0]));
        }
        
    ///  <remarks/>
        public void preproducedCardListAsync(PreproducedCardListCallParms preproducedCardListCallParms) {
            this.preproducedCardListAsync(preproducedCardListCallParms, null);
        }
        
    ///  <remarks/>
        public void preproducedCardListAsync(PreproducedCardListCallParms preproducedCardListCallParms, object userState) {
            if ((this.preproducedCardListOperationCompleted == null)) {
                this.preproducedCardListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpreproducedCardListOperationCompleted);
            }
            this.InvokeAsync("preproducedCardList", new object[] {
                        preproducedCardListCallParms}, this.preproducedCardListOperationCompleted, userState);
        }
        
        private void OnpreproducedCardListOperationCompleted(object arg) {
            if ((this.preproducedCardListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.preproducedCardListCompleted(this, new preproducedCardListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Export preproduced cards that match the given search filter.
    /// </summary>
    /// <param name="preproducedCardExportCallParms">
    ///   preproducedCardExportCallParms
    /// </param>
    /// <returns type="CardExportResult">
    ///   a summary of the cards exported
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("preproducedCardExportReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public CardExportResult preproducedCardExport([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] PreproducedCardExportCallParms preproducedCardExportCallParms) {
            object[] results = this.Invoke("preproducedCardExport", new object[] {
                        preproducedCardExportCallParms});
            return ((CardExportResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginpreproducedCardExport(PreproducedCardExportCallParms preproducedCardExportCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("preproducedCardExport", new object[] {
                        preproducedCardExportCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public CardExportResult EndpreproducedCardExport(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CardExportResult)(results[0]));
        }
        
    ///  <remarks/>
        public void preproducedCardExportAsync(PreproducedCardExportCallParms preproducedCardExportCallParms) {
            this.preproducedCardExportAsync(preproducedCardExportCallParms, null);
        }
        
    ///  <remarks/>
        public void preproducedCardExportAsync(PreproducedCardExportCallParms preproducedCardExportCallParms, object userState) {
            if ((this.preproducedCardExportOperationCompleted == null)) {
                this.preproducedCardExportOperationCompleted = new System.Threading.SendOrPostCallback(this.OnpreproducedCardExportOperationCompleted);
            }
            this.InvokeAsync("preproducedCardExport", new object[] {
                        preproducedCardExportCallParms}, this.preproducedCardExportOperationCompleted, userState);
        }
        
        private void OnpreproducedCardExportOperationCompleted(object arg) {
            if ((this.preproducedCardExportCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.preproducedCardExportCompleted(this, new preproducedCardExportCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Load the token data included in the given token data file, returning 
    ///   the number of tokens loaded and the number of tokens that failed to 
    ///   load. The token data file must be loaded as either a list of strings or 
    ///   an array of binary data. The format required depends on the token 
    ///   vendor, and whether the file is binary or not can be obtained from the 
    ///   token vendor information returned from tokenVendorGet or 
    ///   tokenVendorList. 
    ///   <p>
    ///   Callers of this operation must have a role that has the tokenLoad 
    ///   permission and a group list that grants access to the group that the 
    ///   tokens are to be loaded in to. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the tokenLoad 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the group to load 
    ///   the tokens in to does not exist or is not accessible to the caller. 
    ///   3. A fault with an INVALID_ARGUMENT error code, if the token data file 
    ///   or key are not specified, or if the data file cannot be loaded. 
    ///   </p>
    /// </summary>
    /// <param name="tokenLoadCallParms">
    ///   tokenLoadCallParms
    /// </param>
    /// <returns type="TokenLoadResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("tokenLoadReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public TokenLoadResult tokenLoad([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] TokenLoadCallParms tokenLoadCallParms) {
            object[] results = this.Invoke("tokenLoad", new object[] {
                        tokenLoadCallParms});
            return ((TokenLoadResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegintokenLoad(TokenLoadCallParms tokenLoadCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("tokenLoad", new object[] {
                        tokenLoadCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public TokenLoadResult EndtokenLoad(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TokenLoadResult)(results[0]));
        }
        
    ///  <remarks/>
        public void tokenLoadAsync(TokenLoadCallParms tokenLoadCallParms) {
            this.tokenLoadAsync(tokenLoadCallParms, null);
        }
        
    ///  <remarks/>
        public void tokenLoadAsync(TokenLoadCallParms tokenLoadCallParms, object userState) {
            if ((this.tokenLoadOperationCompleted == null)) {
                this.tokenLoadOperationCompleted = new System.Threading.SendOrPostCallback(this.OntokenLoadOperationCompleted);
            }
            this.InvokeAsync("tokenLoad", new object[] {
                        tokenLoadCallParms}, this.tokenLoadOperationCompleted, userState);
        }
        
        private void OntokenLoadOperationCompleted(object arg) {
            if ((this.tokenLoadCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.tokenLoadCompleted(this, new tokenLoadCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete the unassigned token with the given serial number.
    ///   <p>
    ///   Callers of this operation must have a role that has the tokenDelete 
    ///   permission and a group list that grants access to the group that the 
    ///   token being deleted belongs to. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the tokenDelete 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the given serial 
    ///   number is not a valid token serial number. 
    ///   3. A fault with a TOKEN_NOT_EXIST error code, if the given token does 
    ///   not exist, or belongs to a group that the caller does not have access 
    ///   to. 
    ///   </p>
    /// </summary>
    /// <param name="tokenDeleteCallParms">
    ///   tokenDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void tokenDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] TokenDeleteCallParms tokenDeleteCallParms) {
            this.Invoke("tokenDelete", new object[] {
                        tokenDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegintokenDelete(TokenDeleteCallParms tokenDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("tokenDelete", new object[] {
                        tokenDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndtokenDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void tokenDeleteAsync(TokenDeleteCallParms tokenDeleteCallParms) {
            this.tokenDeleteAsync(tokenDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void tokenDeleteAsync(TokenDeleteCallParms tokenDeleteCallParms, object userState) {
            if ((this.tokenDeleteOperationCompleted == null)) {
                this.tokenDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OntokenDeleteOperationCompleted);
            }
            this.InvokeAsync("tokenDelete", new object[] {
                        tokenDeleteCallParms}, this.tokenDeleteOperationCompleted, userState);
        }
        
        private void OntokenDeleteOperationCompleted(object arg) {
            if ((this.tokenDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.tokenDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Return the unassigned token with the given serial number.
    ///   <p>
    ///   Callers of this operation must have a role that has the tokenGet 
    ///   permission and a group list that grants access to the group that the token 
    ///   being retrieved belongs to. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the tokenGet 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the given serial 
    ///   number is not a valid token serial number. 
    ///   3. A fault with a TOKEN_NOT_EXIST error code, if the given token does 
    ///   not exist, or belongs to a group that the caller does not have access 
    ///   to. 
    ///   </p>
    /// </summary>
    /// <param name="tokenGetCallParms">
    ///   tokenGetCallParms
    /// </param>
    /// <returns type="TokenInfo">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("tokenGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public TokenInfo tokenGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] TokenGetCallParms tokenGetCallParms) {
            object[] results = this.Invoke("tokenGet", new object[] {
                        tokenGetCallParms});
            return ((TokenInfo)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegintokenGet(TokenGetCallParms tokenGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("tokenGet", new object[] {
                        tokenGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public TokenInfo EndtokenGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TokenInfo)(results[0]));
        }
        
    ///  <remarks/>
        public void tokenGetAsync(TokenGetCallParms tokenGetCallParms) {
            this.tokenGetAsync(tokenGetCallParms, null);
        }
        
    ///  <remarks/>
        public void tokenGetAsync(TokenGetCallParms tokenGetCallParms, object userState) {
            if ((this.tokenGetOperationCompleted == null)) {
                this.tokenGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OntokenGetOperationCompleted);
            }
            this.InvokeAsync("tokenGet", new object[] {
                        tokenGetCallParms}, this.tokenGetOperationCompleted, userState);
        }
        
        private void OntokenGetOperationCompleted(object arg) {
            if ((this.tokenGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.tokenGetCompleted(this, new tokenGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Update the unassigned token with the given serial number.
    ///   <p>
    ///   Callers of this operation must have a role that has the tokenSet 
    ///   permission and a group list that grants access to the group that the token 
    ///   being deleted belongs to. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the tokenSet 
    ///   permission, or the group the token is assigned to is being changed and 
    ///   the caller does not have a role granting access to the destination 
    ///   group. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the given serial 
    ///   number is not a valid token serial number. 
    ///   3. A fault with a TOKEN_NOT_EXIST error code, if the given token does 
    ///   not exist, or belongs to a group that the caller does not have access 
    ///   to. 
    ///   </p>
    /// </summary>
    /// <param name="tokenSetCallParms">
    ///   tokenSetCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void tokenSet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] TokenSetCallParms tokenSetCallParms) {
            this.Invoke("tokenSet", new object[] {
                        tokenSetCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegintokenSet(TokenSetCallParms tokenSetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("tokenSet", new object[] {
                        tokenSetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndtokenSet(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void tokenSetAsync(TokenSetCallParms tokenSetCallParms) {
            this.tokenSetAsync(tokenSetCallParms, null);
        }
        
    ///  <remarks/>
        public void tokenSetAsync(TokenSetCallParms tokenSetCallParms, object userState) {
            if ((this.tokenSetOperationCompleted == null)) {
                this.tokenSetOperationCompleted = new System.Threading.SendOrPostCallback(this.OntokenSetOperationCompleted);
            }
            this.InvokeAsync("tokenSet", new object[] {
                        tokenSetCallParms}, this.tokenSetOperationCompleted, userState);
        }
        
        private void OntokenSetOperationCompleted(object arg) {
            if ((this.tokenSetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.tokenSetCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   List unassigned tokens that match the given search filter.
    ///   <p>
    ///   Callers of this operation must have a role that has the tokenList 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the tokenList 
    ///   permission. 
    ///   2. A fault with an OBJECT_NOT_EXIST error code, if the token vendor ID 
    ///   in the search filter does not exist, or groups are specified in the 
    ///   filter that either do not exist or are not accessible to the caller. 
    ///   </p>
    /// </summary>
    /// <param name="tokenListCallParms">
    ///   tokenListCallParms
    /// </param>
    /// <returns type="TokenListResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("tokenListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public TokenListResult tokenList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] TokenListCallParms tokenListCallParms) {
            object[] results = this.Invoke("tokenList", new object[] {
                        tokenListCallParms});
            return ((TokenListResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BegintokenList(TokenListCallParms tokenListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("tokenList", new object[] {
                        tokenListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public TokenListResult EndtokenList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TokenListResult)(results[0]));
        }
        
    ///  <remarks/>
        public void tokenListAsync(TokenListCallParms tokenListCallParms) {
            this.tokenListAsync(tokenListCallParms, null);
        }
        
    ///  <remarks/>
        public void tokenListAsync(TokenListCallParms tokenListCallParms, object userState) {
            if ((this.tokenListOperationCompleted == null)) {
                this.tokenListOperationCompleted = new System.Threading.SendOrPostCallback(this.OntokenListOperationCompleted);
            }
            this.InvokeAsync("tokenList", new object[] {
                        tokenListCallParms}, this.tokenListOperationCompleted, userState);
        }
        
        private void OntokenListOperationCompleted(object arg) {
            if ((this.tokenListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.tokenListCompleted(this, new tokenListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Retrieves a grid challenge for the given user ID. The challenge must 
    ///   be authenticated using the challengeAuthenticate call. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userAuthenticate permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all 
    ///   of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userAuthenticate permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a CARD_NOT_EXIST error code, if the user does not have 
    ///   any cards. 
    ///   </p>
    /// </summary>
    /// <param name="challengeGetCallParms">
    ///   challengeGetCallParms
    /// </param>
    /// <returns type="Challenge[]">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlArrayAttribute("challengeGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        [return: System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public Challenge[] challengeGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] ChallengeGetCallParms challengeGetCallParms) {
            object[] results = this.Invoke("challengeGet", new object[] {
                        challengeGetCallParms});
            return ((Challenge[])(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginchallengeGet(ChallengeGetCallParms challengeGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("challengeGet", new object[] {
                        challengeGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public Challenge[] EndchallengeGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Challenge[])(results[0]));
        }
        
    ///  <remarks/>
        public void challengeGetAsync(ChallengeGetCallParms challengeGetCallParms) {
            this.challengeGetAsync(challengeGetCallParms, null);
        }
        
    ///  <remarks/>
        public void challengeGetAsync(ChallengeGetCallParms challengeGetCallParms, object userState) {
            if ((this.challengeGetOperationCompleted == null)) {
                this.challengeGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnchallengeGetOperationCompleted);
            }
            this.InvokeAsync("challengeGet", new object[] {
                        challengeGetCallParms}, this.challengeGetOperationCompleted, userState);
        }
        
        private void OnchallengeGetOperationCompleted(object arg) {
            if ((this.challengeGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.challengeGetCompleted(this, new challengeGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Authenticates a response against a grid challenge that was issued by 
    ///   the challengeGet call for the given user ID. A successful 
    ///   authentication will not change the user card state. 
    ///   <p>
    ///   To call this operation, at least one of the caller's roles must have 
    ///   the userAuthenticate permission and a group list that grants access to 
    ///   the user's group. Additionally, if the user is an administrator, one 
    ///   of these roles must also have a role list that grants access to all 
    ///   of the administrator's roles. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the 
    ///   userAuthenticate permission. 
    ///   2. A fault with a USER_NOT_EXIST error code, if the user does not 
    ///   exist, or access to the user is not granted because of their group 
    ///   membership or roles. 
    ///   3. A fault with a USERNAME_NOT_UNIQUE error code, if the user's group 
    ///   is not specified in their user ID and multiple users with this user 
    ///   ID or alias exist in different groups. 
    ///   4. A fault with a CARD_NOT_EXIST error code, if none of the user's 
    ///   cards match the filter. 
    ///   5. A fault with a CHALLENGE_NOT_EXIST error code, if there is no 
    ///   retained grid challenge. This will occur if no prior call was made to 
    ///   challengeGet. 
    ///   6. A fault with an INVALID_RESPONSE error code, if the response to the 
    ///   challenge is not correct. 
    ///   7. A fault with an INVALID_CARD_STATE error code, if an attempt is 
    ///   made to authenticate a card in the CANCELED state. 
    ///   </p>
    /// </summary>
    /// <param name="challengeAuthenticateCallParms">
    ///   challengeAuthenticateCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void challengeAuthenticate([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] ChallengeAuthenticateCallParms challengeAuthenticateCallParms) {
            this.Invoke("challengeAuthenticate", new object[] {
                        challengeAuthenticateCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginchallengeAuthenticate(ChallengeAuthenticateCallParms challengeAuthenticateCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("challengeAuthenticate", new object[] {
                        challengeAuthenticateCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndchallengeAuthenticate(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void challengeAuthenticateAsync(ChallengeAuthenticateCallParms challengeAuthenticateCallParms) {
            this.challengeAuthenticateAsync(challengeAuthenticateCallParms, null);
        }
        
    ///  <remarks/>
        public void challengeAuthenticateAsync(ChallengeAuthenticateCallParms challengeAuthenticateCallParms, object userState) {
            if ((this.challengeAuthenticateOperationCompleted == null)) {
                this.challengeAuthenticateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnchallengeAuthenticateOperationCompleted);
            }
            this.InvokeAsync("challengeAuthenticate", new object[] {
                        challengeAuthenticateCallParms}, this.challengeAuthenticateOperationCompleted, userState);
        }
        
        private void OnchallengeAuthenticateOperationCompleted(object arg) {
            if ((this.challengeAuthenticateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.challengeAuthenticateCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Add an entry to the IP blacklist.
    ///   <p>
    ///   Callers of this operation must have a role with the ipListSet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the ipListSet 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the start address 
    ///   is not specified, the start or the end address are not valid IP 
    ///   addresses, or the start address comes after the end address. 
    ///   </p>
    /// </summary>
    /// <param name="ipListAddCallParms">
    ///   ipListAddCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void ipListAdd([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] IPListAddCallParms ipListAddCallParms) {
            this.Invoke("ipListAdd", new object[] {
                        ipListAddCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginipListAdd(IPListAddCallParms ipListAddCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ipListAdd", new object[] {
                        ipListAddCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndipListAdd(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void ipListAddAsync(IPListAddCallParms ipListAddCallParms) {
            this.ipListAddAsync(ipListAddCallParms, null);
        }
        
    ///  <remarks/>
        public void ipListAddAsync(IPListAddCallParms ipListAddCallParms, object userState) {
            if ((this.ipListAddOperationCompleted == null)) {
                this.ipListAddOperationCompleted = new System.Threading.SendOrPostCallback(this.OnipListAddOperationCompleted);
            }
            this.InvokeAsync("ipListAdd", new object[] {
                        ipListAddCallParms}, this.ipListAddOperationCompleted, userState);
        }
        
        private void OnipListAddOperationCompleted(object arg) {
            if ((this.ipListAddCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ipListAddCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Delete an entry from the IP blacklist.
    ///   <p>
    ///   Callers of this operation must have a role with the ipListDelete 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the ipListDelete 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the start or the 
    ///   end address are not valid IP addresses, or the start address comes 
    ///   after the end address. 
    ///   </p>
    /// </summary>
    /// <param name="ipListDeleteCallParms">
    ///   ipListDeleteCallParms
    /// </param>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        public void ipListDelete([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] IPListDeleteCallParms ipListDeleteCallParms) {
            this.Invoke("ipListDelete", new object[] {
                        ipListDeleteCallParms});
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginipListDelete(IPListDeleteCallParms ipListDeleteCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ipListDelete", new object[] {
                        ipListDeleteCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public void EndipListDelete(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
    ///  <remarks/>
        public void ipListDeleteAsync(IPListDeleteCallParms ipListDeleteCallParms) {
            this.ipListDeleteAsync(ipListDeleteCallParms, null);
        }
        
    ///  <remarks/>
        public void ipListDeleteAsync(IPListDeleteCallParms ipListDeleteCallParms, object userState) {
            if ((this.ipListDeleteOperationCompleted == null)) {
                this.ipListDeleteOperationCompleted = new System.Threading.SendOrPostCallback(this.OnipListDeleteOperationCompleted);
            }
            this.InvokeAsync("ipListDelete", new object[] {
                        ipListDeleteCallParms}, this.ipListDeleteOperationCompleted, userState);
        }
        
        private void OnipListDeleteOperationCompleted(object arg) {
            if ((this.ipListDeleteCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ipListDeleteCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   Get the entry from the IP blacklist containing the given IP address. 
    ///   <p>
    ///   Callers of this operation must have a role with the ipListGet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the ipListGet 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the given address 
    ///   is not a valid IP address. 
    ///   3. A fault with an OBJECT_NOT_EXIST error code, if there is no IP 
    ///   blacklist entry with the given IP address </p> 
    /// </summary>
    /// <param name="ipListGetCallParms">
    ///   ipListGetCallParms
    /// </param>
    /// <returns type="IPListEntry">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("ipListGetReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public IPListEntry ipListGet([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] IPListGetCallParms ipListGetCallParms) {
            object[] results = this.Invoke("ipListGet", new object[] {
                        ipListGetCallParms});
            return ((IPListEntry)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginipListGet(IPListGetCallParms ipListGetCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ipListGet", new object[] {
                        ipListGetCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public IPListEntry EndipListGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((IPListEntry)(results[0]));
        }
        
    ///  <remarks/>
        public void ipListGetAsync(IPListGetCallParms ipListGetCallParms) {
            this.ipListGetAsync(ipListGetCallParms, null);
        }
        
    ///  <remarks/>
        public void ipListGetAsync(IPListGetCallParms ipListGetCallParms, object userState) {
            if ((this.ipListGetOperationCompleted == null)) {
                this.ipListGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnipListGetOperationCompleted);
            }
            this.InvokeAsync("ipListGet", new object[] {
                        ipListGetCallParms}, this.ipListGetOperationCompleted, userState);
        }
        
        private void OnipListGetOperationCompleted(object arg) {
            if ((this.ipListGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ipListGetCompleted(this, new ipListGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    /// <summary>
    ///   List the entries from the IP blacklist matching the given search 
    ///   filter. 
    ///   <p>
    ///   Callers of this operation must have a role with the ipListGet 
    ///   permission. 
    ///   </p>
    ///   <p>
    ///   The most likely faults from this call are: 1. A fault with a 
    ///   NOT_PERMITTED error code, if none of the caller's roles have the ipListGet 
    ///   permission. 
    ///   2. A fault with an INVALID_ARGUMENT error code, if the start or end 
    ///   addresses in the filter are not valid IP addresses. 
    ///   </p>
    /// </summary>
    /// <param name="ipListListCallParms">
    ///   ipListListCallParms
    /// </param>
    /// <returns type="IPListListResult">
    /// </returns>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
        [return: System.Xml.Serialization.XmlElementAttribute("ipListListReturn", Namespace="urn:entrust.com:ig:adminV3:wsdl")]
        public IPListListResult ipListList([System.Xml.Serialization.XmlElementAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")] IPListListCallParms ipListListCallParms) {
            object[] results = this.Invoke("ipListList", new object[] {
                        ipListListCallParms});
            return ((IPListListResult)(results[0]));
        }
        
    ///  <remarks/>
        public System.IAsyncResult BeginipListList(IPListListCallParms ipListListCallParms, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ipListList", new object[] {
                        ipListListCallParms}, callback, asyncState);
        }
        
    ///  <remarks/>
        public IPListListResult EndipListList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((IPListListResult)(results[0]));
        }
        
    ///  <remarks/>
        public void ipListListAsync(IPListListCallParms ipListListCallParms) {
            this.ipListListAsync(ipListListCallParms, null);
        }
        
    ///  <remarks/>
        public void ipListListAsync(IPListListCallParms ipListListCallParms, object userState) {
            if ((this.ipListListOperationCompleted == null)) {
                this.ipListListOperationCompleted = new System.Threading.SendOrPostCallback(this.OnipListListOperationCompleted);
            }
            this.InvokeAsync("ipListList", new object[] {
                        ipListListCallParms}, this.ipListListOperationCompleted, userState);
        }
        
        private void OnipListListOperationCompleted(object arg) {
            if ((this.ipListListCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ipListListCompleted(this, new ipListListCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
    ///  <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to login. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class LoginCallParms {
        
        private LoginParms parmsField;
        
    /// <datatype>
    ///   LoginParms
    /// </datatype>
    /// <value>
    ///   Includes the administrator ID and password of the administrator 
    ///   logging in. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public LoginParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information passed to a login or changePassword request. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class LoginParms {
        
        private string adminIdField;
        
        private string passwordField;
        
        private string[] responseField;
        
        private NameValue[] parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID of the administrator logging in.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string adminId {
            get {
                return this.adminIdField;
            }
            set {
                this.adminIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The password for the first phase of authentication.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string password {
            get {
                return this.passwordField;
            }
            set {
                this.passwordField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The response to a GRID or TOKENCR challenge, or the value displayed on 
    ///   the token for TOKENRO authentication, for the second phase of 
    ///   authentication. 
    ///   Set this parameter for the second call to login or changePassword when 
    ///   second-factor authentication is required. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] response {
            get {
                return this.responseField;
            }
            set {
                this.responseField = value;
            }
        }
        
    /// <datatype>
    ///   NameValue[]
    /// </datatype>
    /// <value>
    ///   Parameters passed to login. Currently the only supported parameter 
    ///   here is "locale", used to provide the location of the administrator 
    ///   logging in. This locale is an ISO language code, optionally followed by 
    ///   an ISO country code, separated by an underscore, for example "en_US" 
    ///   for American English. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public NameValue[] parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   A name/value pair.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:commonV3")]
    public partial class NameValue {
        
        private string nameField;
        
        private string valueField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The value.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure defines the results of an ipListList operation. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class IPListListResult {
        
        private string nextEntryField;
        
        private IPListEntry[] entriesField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If set, the next ipListList operation should specify this address as 
    ///   the start address in order to continue the list operation. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string nextEntry {
            get {
                return this.nextEntryField;
            }
            set {
                this.nextEntryField = value;
            }
        }
        
    /// <datatype>
    ///   IPListEntry[]
    /// </datatype>
    /// <value>
    ///   The list of entries returned by this ipListList operation.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public IPListEntry[] entries {
            get {
                return this.entriesField;
            }
            set {
                this.entriesField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure defines an entry in the IP blacklist.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class IPListEntry {
        
        private string startIPAddressField;
        
        private string endIPAddressField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The starting entry.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string startIPAddress {
            get {
                return this.startIPAddressField;
            }
            set {
                this.startIPAddressField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The ending entry. If not set, it defaults to the start entry. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string endIPAddress {
            get {
                return this.endIPAddressField;
            }
            set {
                this.endIPAddressField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure defines search parameters for a ipListList operation. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class IPListFilter {
        
        private string startIPAddressField;
        
        private string endIPAddressField;
        
        private System.Nullable<int> maxReturnField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The starting entry. If not specified, start with the first entry. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string startIPAddress {
            get {
                return this.startIPAddressField;
            }
            set {
                this.startIPAddressField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The ending entry.  If not set, end with the last entry.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string endIPAddress {
            get {
                return this.endIPAddressField;
            }
            set {
                this.endIPAddressField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of entries to return.
    ///   If not specified or a value of 0 or less is specified, it defaults to 
    ///   100. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxReturn {
            get {
                return this.maxReturnField;
            }
            set {
                this.maxReturnField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to ipListList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class IPListListCallParms {
        
        private IPListFilter filterField;
        
    /// <datatype>
    ///   IPListFilter
    /// </datatype>
    /// <value>
    ///   Return the entries in the IP blacklist matching the given search 
    ///   parameters. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public IPListFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to ipListGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class IPListGetCallParms {
        
        private string iPAddressField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Return the entry in the IP blacklist containing this IP address. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string IPAddress {
            get {
                return this.iPAddressField;
            }
            set {
                this.iPAddressField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   ipListDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class IPListDeleteCallParms {
        
        private IPListEntry entryField;
        
    /// <datatype>
    ///   IPListEntry
    /// </datatype>
    /// <value>
    ///   The IP list entry to remove from the IP blacklist.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public IPListEntry entry {
            get {
                return this.entryField;
            }
            set {
                this.entryField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to ipListAdd. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class IPListAddCallParms {
        
        private IPListEntry entryField;
        
    /// <datatype>
    ///   IPListEntry
    /// </datatype>
    /// <value>
    ///   The IP list entry to add to the IP blacklist.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public IPListEntry entry {
            get {
                return this.entryField;
            }
            set {
                this.entryField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   challengeAuthenticate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class ChallengeAuthenticateCallParms {
        
        private string useridField;
        
        private UserCardFilter cardFilterField;
        
        private string[] responseField;
        
        private System.Nullable<bool> obeyLockoutField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID to authenticate.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserCardFilter
    /// </datatype>
    /// <value>
    ///   The cards to authenticate against.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserCardFilter cardFilter {
            get {
                return this.cardFilterField;
            }
            set {
                this.cardFilterField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The user's response to the challenge.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] response {
            get {
                return this.responseField;
            }
            set {
                this.responseField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If this flag is true, this operation will check the user's current 
    ///   lockout and update the lockout based on whether the response 
    ///   authenticates. If this flag is false, this operation will ignore lockout. If not 
    ///   set, this flag defaults to false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> obeyLockout {
            get {
                return this.obeyLockoutField;
            }
            set {
                this.obeyLockoutField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a filter to limit which cards are returned for a user. If both 
    ///   SerialNumber and State are set, SerialNumber is used. If neither are 
    ///   set, all cards for the user are returned. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardFilter {
        
        private string serialNumberField;
        
        private State[] stateField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Filter cards that match the given serial number.
    ///   The value can include the '*' character for wildcard matching. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string SerialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   State[]
    /// </datatype>
    /// <value>
    ///   Filter cards that match one of the given states.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public State[] State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the possible card and token states.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum State {
        
    /// <value>
    ///   State indicating that the card or token has not yet been used by the 
    ///   user it is assigned to for authentication, but authentication is 
    ///   allowed. 
    ///   Cards or tokens in the PENDING state may have their state changed to 
    ///   CURRENT, HOLD, HOLD_PENDING, or CANCELED by the relevant operations in 
    ///   the admin service. 
    /// </value>
        PENDING,
        
    /// <value>
    ///   State indicating that the card or token is considered to have been 
    ///   used by the user it is assigned to for authentication, and 
    ///   authentication with it is allowed. 
    ///   Cards or tokens in the CURRENT state may have their state changed to 
    ///   HOLD or CANCELED by the relevant operations in the admin service. 
    /// </value>
        CURRENT,
        
    /// <value>
    ///   State indicating that the card or token is considered to have been 
    ///   used by the user it is assigned to for authentication, but 
    ///   authentication with it is not allowed until its state is changed to CURRENT. 
    ///   Cards or tokens in the HOLD state may have their state changed to 
    ///   CURRENT or CANCELED by the relevant operations in the admin service. 
    /// </value>
        HOLD,
        
    /// <value>
    ///   State indicating that the card or token has not been used by the user 
    ///   it is assigned to for authentication, and authentication with it is 
    ///   not allowed until its state is changed to PENDING or CURRENT. 
    ///   Cards or tokens in the HOLD_PENDING state may have their state changed 
    ///   to CURRENT, HOLD, PENDING, or CANCELED by the relevant operations in 
    ///   the admin service. 
    /// </value>
        HOLD_PENDING,
        
    /// <value>
    ///   State indicating that the card or token has been canceled, and can 
    ///   never again be used for authentication. 
    ///   Cards or tokens in the CANCELED state may not have their state changed 
    ///   to any other state. 
    /// </value>
        CANCELED,
        
    /// <value>
    ///   A placeholder in case more states are introduced in future releases. 
    ///   If an application ever encounters this value in a card or token, it 
    ///   should be upgraded to use the most recent version of the admin service. 
    /// </value>
        UNKNOWN,
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   challengeGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class ChallengeGetCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to get the challenge for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   The data returned from a tokenList operation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenListResult {
        
        private TokenInfo[] tokensField;
        
        private string nextTokenVendorIdField;
        
        private string nextTokenSerialNumberField;
        
    /// <datatype>
    ///   TokenInfo[]
    /// </datatype>
    /// <value>
    ///   The list of tokens.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public TokenInfo[] tokens {
            get {
                return this.tokensField;
            }
            set {
                this.tokensField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If set, indicates that more tokens are left to be returned. The value 
    ///   can be set in the TokenFilter of the next tokenList operation. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string nextTokenVendorId {
            get {
                return this.nextTokenVendorIdField;
            }
            set {
                this.nextTokenVendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If set, indicates that more tokens are left to be returned. The value 
    ///   can be set in the TokenFilter of the next tokenList operation. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string nextTokenSerialNumber {
            get {
                return this.nextTokenSerialNumberField;
            }
            set {
                this.nextTokenSerialNumberField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned about an unassigned token.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenInfo {
        
        private string vendorIdField;
        
        private string serialNumberField;
        
        private string tokenTypeField;
        
        private bool responseSupportedField;
        
        private bool challengeSupportedField;
        
        private bool unlockSupportedField;
        
        private bool signatureSupportedField;
        
        private System.DateTime loadDateField;
        
        private string groupField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The vendor id of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string VendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string SerialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The type of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string TokenType {
            get {
                return this.tokenTypeField;
            }
            set {
                this.tokenTypeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this token supports token response-only 
    ///   authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool ResponseSupported {
            get {
                return this.responseSupportedField;
            }
            set {
                this.responseSupportedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this token supports token challenge/response 
    ///   authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool ChallengeSupported {
            get {
                return this.challengeSupportedField;
            }
            set {
                this.challengeSupportedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this token supports the unlock operation.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool UnlockSupported {
            get {
                return this.unlockSupportedField;
            }
            set {
                this.unlockSupportedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this token supports the data signature operation. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool SignatureSupported {
            get {
                return this.signatureSupportedField;
            }
            set {
                this.signatureSupportedField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The load date of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime LoadDate {
            get {
                return this.loadDateField;
            }
            set {
                this.loadDateField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group this token belongs to.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The token comment.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the filter to limit which unassigned tokens are to be returned 
    ///   from the token list operation. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenFilter {
        
        private string vendorIdField;
        
        private string serialNumberField;
        
        private System.Nullable<System.DateTime> loadStartDateField;
        
        private System.Nullable<System.DateTime> loadEndDateField;
        
        private string[] groupsField;
        
        private System.Nullable<int> maxReturnField;
        
        private string nextTokenVendorIdField;
        
        private string nextTokenSerialNumberField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, only tokens with the given vendor are returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string vendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, only tokens whose serial numbers match this expression 
    ///   are returned. This string can include the '*' character for wildcard 
    ///   matching. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only tokens whose load date is after the given 
    ///   date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> loadStartDate {
            get {
                return this.loadStartDateField;
            }
            set {
                this.loadStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only tokens whose load date is before the given 
    ///   date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> loadEndDate {
            get {
                return this.loadEndDateField;
            }
            set {
                this.loadEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If specified, provides a list of group names and returns only tokens 
    ///   in the specified groups. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] groups {
            get {
                return this.groupsField;
            }
            set {
                this.groupsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of tokens to return. If not specified or the value is 0 or 
    ///   less, it defaults to 100. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxReturn {
            get {
                return this.maxReturnField;
            }
            set {
                this.maxReturnField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The vendor id of the next token to be returned. If specified, 
    ///   indicates that searching should start at the given token. This value is used 
    ///   to get the next set of tokens following a previous search. The value 
    ///   can be found in the TokenListResult from the previous search. This 
    ///   value is ignored if the nextTokenSerialNumber is not specified. 
    ///   If not specified when nextTokenSerialNumber is specified, the default 
    ///   vendorid is used. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string nextTokenVendorId {
            get {
                return this.nextTokenVendorIdField;
            }
            set {
                this.nextTokenVendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serialNumber of the next token to be returned. If specified, 
    ///   indicates that searching should start at the given token. This value is 
    ///   used to get the next set of tokens following a previous search. The 
    ///   value can be found in the TokenListResult from the previous search. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string nextTokenSerialNumber {
            get {
                return this.nextTokenSerialNumberField;
            }
            set {
                this.nextTokenSerialNumberField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to tokenList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenListCallParms {
        
        private TokenFilter filterField;
        
    /// <datatype>
    ///   TokenFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which tokens are to be returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public TokenFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to tokenSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenSetCallParms {
        
        private string vendorIdField;
        
        private string serialNumberField;
        
        private TokenParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The vendor id the token to update. If not specified, the default 
    ///   vendor is used. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string vendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the token to update.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   TokenParms
    /// </datatype>
    /// <value>
    ///   The parameters to update the token with.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public TokenParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when loading or modifying unassigned 
    ///   tokens. All values can be null indicating that the default is used when 
    ///   loading or the value is not changed for modify. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenParms {
        
        private string vendorIdField;
        
        private string groupField;
        
        private string[] tokenDataField;
        
        private byte[] tokenBinaryDataField;
        
        private string tokenKeyField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   When loading tokens, the vendor to use for loading the tokens. If not 
    ///   specified, the default vendor is used. 
    ///   Ignored when modifying tokens.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string VendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group this token belongs to. If null during load, the token will 
    ///   belong to the default group. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The token data to load for the tokenLoad operation where the data is 
    ///   specified as a list of text lines. 
    ///   Each element in the array is a line from the token data file. 
    ///   Ignored when modifying tokens.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] TokenData {
            get {
                return this.tokenDataField;
            }
            set {
                this.tokenDataField = value;
            }
        }
        
    /// <datatype>
    ///   base64Binary
    /// </datatype>
    /// <value>
    ///   The token data to load for the tokenLoad operation where the data is 
    ///   specified as binary data. 
    ///   Ignored when modifying tokens.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="base64Binary", IsNullable=true)]
        public byte[] TokenBinaryData {
            get {
                return this.tokenBinaryDataField;
            }
            set {
                this.tokenBinaryDataField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The token key used to unlock the token data in the tokenLoad 
    ///   operation. 
    ///   Ignored when modifying tokens.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string TokenKey {
            get {
                return this.tokenKeyField;
            }
            set {
                this.tokenKeyField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The token comment. Defaults to an empty string if not specified during 
    ///   a tokenLoad operation. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to tokenGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenGetCallParms {
        
        private string vendorIdField;
        
        private string serialNumberField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The vendor id of the token to get. If not specified, the default 
    ///   vendor is used. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string vendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the token to get.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   tokenDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenDeleteCallParms {
        
        private string vendorIdField;
        
        private string serialNumberField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The vendor id of the token to delete. If not specified, the default 
    ///   vendor is used. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string vendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the token to delete.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines information returned from the tokenLoad operation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenLoadResult {
        
        private int numLoadedField;
        
        private int numFailedField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of tokens being successfully loaded.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int numLoaded {
            get {
                return this.numLoadedField;
            }
            set {
                this.numLoadedField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of tokens that failed to load.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int numFailed {
            get {
                return this.numFailedField;
            }
            set {
                this.numFailedField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to tokenLoad. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenLoadCallParms {
        
        private TokenParms parmsField;
        
    /// <datatype>
    ///   TokenParms
    /// </datatype>
    /// <value>
    ///   The data to load.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public TokenParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   preproducedCardExport. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardExportCallParms {
        
        private PreproducedCardFilter filterField;
        
        private NameValue[] parmsField;
        
    /// <datatype>
    ///   PreproducedCardFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which cards are to be exported.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PreproducedCardFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   NameValue[]
    /// </datatype>
    /// <value>
    ///   A list of parameters. Not currently used.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public NameValue[] parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the filter to limit which preproduced cards are to be returned 
    ///   from the preproducedCardList operation. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardFilter {
        
        private string serialNumberField;
        
        private System.Nullable<System.DateTime> createStartDateField;
        
        private System.Nullable<System.DateTime> createEndDateField;
        
        private string[] groupsField;
        
        private System.Nullable<int> maxReturnField;
        
        private string nextCardField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, only the card with this serial number will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards whose creation date is after the 
    ///   given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> createStartDate {
            get {
                return this.createStartDateField;
            }
            set {
                this.createStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards whose creation date is before the 
    ///   given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> createEndDate {
            get {
                return this.createEndDateField;
            }
            set {
                this.createEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If specified, provides a list of group names and returns only cards in 
    ///   the specified groups. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] groups {
            get {
                return this.groupsField;
            }
            set {
                this.groupsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of cards to return. If not specified, or the value is 0 or 
    ///   less, it defaults to 100. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxReturn {
            get {
                return this.maxReturnField;
            }
            set {
                this.maxReturnField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the next card to be returned. If specified, 
    ///   indicates that searching should start at the given card. This value is 
    ///   used to get the next set of cards following a previous search. The value 
    ///   can be found in the PreproducedCardListResult from the previous 
    ///   search. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string nextCard {
            get {
                return this.nextCardField;
            }
            set {
                this.nextCardField = value;
            }
        }
    }
    
    /// <summary>
    ///   The data returned from a PreproducedCardList operation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardListResult {
        
        private PreproducedCardInfo[] cardsField;
        
        private string nextCardField;
        
    /// <datatype>
    ///   PreproducedCardInfo[]
    /// </datatype>
    /// <value>
    ///   The list of cards.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public PreproducedCardInfo[] cards {
            get {
                return this.cardsField;
            }
            set {
                this.cardsField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If set, indicates that more cards are left to be returned. This value 
    ///   can be included in the filter for a further search to continue the 
    ///   search at the next preproduced card. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string nextCard {
            get {
                return this.nextCardField;
            }
            set {
                this.nextCardField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned about a preproduced card.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardInfo {
        
        private string serialNumberField;
        
        private System.DateTime createDateField;
        
        private Grid gridField;
        
        private string groupField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string SerialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The create date of the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime CreateDate {
            get {
                return this.createDateField;
            }
            set {
                this.createDateField = value;
            }
        }
        
    /// <datatype>
    ///   Grid
    /// </datatype>
    /// <value>
    ///   The contents of the card. The value will be null if the operation used 
    ///   to retrieve the card did not request the grid, or if the caller does 
    ///   not have permission to view the grid. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public Grid Grid {
            get {
                return this.gridField;
            }
            set {
                this.gridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group this preproduced card belongs to.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The card comment.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   A two-dimensional card grid. The grid is represented as a 
    ///   one-dimensional array due to the number of interoperability problems that arise 
    ///   when multi-dimensional arrays are used. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class Grid {
        
        private int numRowsField;
        
        private int numColumnsField;
        
        private GridCell[] cellsField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of rows in the grid.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int numRows {
            get {
                return this.numRowsField;
            }
            set {
                this.numRowsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of columns in the grid.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int numColumns {
            get {
                return this.numColumnsField;
            }
            set {
                this.numColumnsField = value;
            }
        }
        
    /// <datatype>
    ///   GridCell
    /// </datatype>
    /// <value>
    ///   The cells in the grid.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute("cells", Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public GridCell[] cells {
            get {
                return this.cellsField;
            }
            set {
                this.cellsField = value;
            }
        }
    }
    
    /// <summary>
    ///   An individual cell in a card grid.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GridCell {
        
        private int rowField;
        
        private int columnField;
        
        private string valueField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The row in which the cell appears. Row indexes start at 0 and go up to 
    ///   numRows-1 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int row {
            get {
                return this.rowField;
            }
            set {
                this.rowField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The column in which the cell appears. Column indexes start at 0 and go 
    ///   up to numColumns-1 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int column {
            get {
                return this.columnField;
            }
            set {
                this.columnField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The value of the cell.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   preproducedCardList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardListCallParms {
        
        private PreproducedCardFilter filterField;
        
        private CardGetParms parmsField;
        
    /// <datatype>
    ///   PreproducedCardFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which cards are to be returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PreproducedCardFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   CardGetParms
    /// </datatype>
    /// <value>
    ///   Parameters that control what information is returned for each card. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public CardGetParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines information returned about a card.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class CardGetParms {
        
        private System.Nullable<bool> getGridField;
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns the card grid. If not set, defaults to false. 
    ///   Even if requested, the card grid will not be returned if the caller 
    ///   does not have permission to view card grids. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getGrid {
            get {
                return this.getGridField;
            }
            set {
                this.getGridField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   preproducedCardSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardSetCallParms {
        
        private string serialNumberField;
        
        private PreproducedCardParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the card to update.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   PreproducedCardParms
    /// </datatype>
    /// <value>
    ///   The parameters to update each card with.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PreproducedCardParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when creating or modifying a preproduced 
    ///   card. All values can be null indicating that the default is used for 
    ///   create or the value is not changed for modify. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardParms {
        
        private System.Nullable<int> numCardsField;
        
        private string groupField;
        
        private string commentField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   During card creation, this value will define how many preproduced 
    ///   cards are to be created. 
    ///   If not set, one card will be created. This parameter is ignored by 
    ///   preproduced card modify. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> NumCards {
            get {
                return this.numCardsField;
            }
            set {
                this.numCardsField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group this preproduced card belongs to. If null during create, the 
    ///   card will belong to the group flagged as the default. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The card comment. Defaults to an empty string when creating new 
    ///   preproduced cards. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   preproducedCardGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardGetCallParms {
        
        private string serialNumberField;
        
        private CardGetParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the card to get.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   CardGetParms
    /// </datatype>
    /// <value>
    ///   Parameters that control what information is returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public CardGetParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   preproducedCardDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardDeleteCallParms {
        
        private string serialNumberField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the preproduced card to delete.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the base exception that will be returned when operations fail. 
    /// </summary>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(AdminPasswordChangeRequiredFault))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class AdminServiceFault {
        
        private ErrorCode errorCodeField;
        
        private string internalCodeField;
        
        private string errorMessageField;
        
        private string idField;
        
        private AdminServiceFault causeFaultField;
        
    /// <datatype>
    ///   ErrorCode
    /// </datatype>
    /// <value>
    ///   Error code indicating the reason for the failure.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public ErrorCode ErrorCode {
            get {
                return this.errorCodeField;
            }
            set {
                this.errorCodeField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The internal code indicating the reason for the failure.
    ///   This code corresponds to the codes documented in the error guide and 
    ///   the values logged by the Entrust IdentityGuard Server. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string InternalCode {
            get {
                return this.internalCodeField;
            }
            set {
                this.internalCodeField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The descriptive error message string corresponding the InternalCode. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string errorMessage {
            get {
                return this.errorMessageField;
            }
            set {
                this.errorMessageField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   An instance specific value that will be included in the Entrust 
    ///   IdentityGuard logs. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string id {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
    /// <datatype>
    ///   AdminServiceFault
    /// </datatype>
    /// <value>
    ///   If this fault was caused by another fault, specifies the causal fault. 
    ///   Otherwise, this element will be null. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public AdminServiceFault causeFault {
            get {
                return this.causeFaultField;
            }
            set {
                this.causeFaultField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines error codes that will be included in the exceptions returned 
    ///   from operations. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum ErrorCode {
        
    /// <value>
    ///   An operation has specified a userid that does not exist.
    /// </value>
        USER_NOT_EXIST,
        
    /// <value>
    ///   The specified user already exists.
    /// </value>
        USER_EXIST,
        
    /// <value>
    ///   An operation has specified username that exists in multiple groups. 
    ///   The group must also be included to specify a single user. 
    /// </value>
        USERNAME_NOT_UNIQUE,
        
    /// <value>
    ///   An operation has specified a card that does not exist.
    /// </value>
        CARD_NOT_EXIST,
        
    /// <value>
    ///   A card can not be created for a user because the user already has a 
    ///   pending card. 
    /// </value>
        CARD_EXIST,
        
    /// <value>
    ///   The user does not have a temporary PIN.
    /// </value>
        PIN_NOT_EXIST,
        
    /// <value>
    ///   The user already has a temporary PIN.
    /// </value>
        PIN_EXIST,
        
    /// <value>
    ///   An administrator can not change a user's PVN to not require change 
    ///   when this is not allowed by policy. 
    /// </value>
        PVN_CHANGE_REQUIRED,
        
    /// <value>
    ///   When assigning a new PVN to a user, the optional old PVN did not match 
    ///   the existing PVN. 
    /// </value>
        PVN_INVALID,
        
    /// <value>
    ///   An operation has specified a token that does not exist.
    /// </value>
        TOKEN_NOT_EXIST,
        
    /// <value>
    ///   A token can not be assigned to a user because the user already has a 
    ///   token in that state. 
    /// </value>
        TOKEN_EXIST,
        
    /// <value>
    ///   The specified object does not exist.
    /// </value>
        OBJECT_NOT_EXIST,
        
    /// <value>
    ///   The specified object already exists.
    /// </value>
        OBJECT_EXIST,
        
    /// <value>
    ///   The specified card is not in a state that allows the operation or the 
    ///   state of the card can not be changed to the specified state. 
    /// </value>
        INVALID_CARD_STATE,
        
    /// <value>
    ///   The specified token is not in a state that allows the operation or the 
    ///   state of the token can not be changed to the specified state. 
    /// </value>
        INVALID_TOKEN_STATE,
        
    /// <value>
    ///   An invalid argument was specified for the operation.
    /// </value>
        INVALID_ARGUMENT,
        
    /// <value>
    ///   An authentication operation was performed but the required challenge 
    ///   does not exist. 
    /// </value>
        CHALLENGE_NOT_EXIST,
        
    /// <value>
    ///   An authentication operation was performed and the response was 
    ///   invalid. 
    /// </value>
        INVALID_RESPONSE,
        
    /// <value>
    ///   An administration operation was performed but no administrator is 
    ///   logged in. 
    /// </value>
        NOT_LOGGED_IN,
        
    /// <value>
    ///   An administrator specified an invalid userid or password when trying 
    ///   to login. 
    /// </value>
        INVALID_USERID_PASSWORD,
        
    /// <value>
    ///   The administrator can not login because they are locked out.
    /// </value>
        ADMIN_LOCKED,
        
    /// <value>
    ///   The administrator can not login because they require a password 
    ///   change. 
    /// </value>
        PASSWORD_CHANGE_REQUIRED,
        
    /// <value>
    ///   The administrator's login session has expired.
    ///   The administrator will need to login again.
    /// </value>
        SESSION_EXPIRED,
        
    /// <value>
    ///   The administrator is not in the active state.
    /// </value>
        ADMIN_INACTIVE,
        
    /// <value>
    ///   The administrator can not login because they specified an invalid 
    ///   password or challenge response that has locked them out. 
    /// </value>
        LOGIN_FAILED_ADMIN_LOCKED,
        
    /// <value>
    ///   A miscellaneous error.
    /// </value>
        MISC,
        
    /// <value>
    ///   The administrator's role does not allow the operation to be performed. 
    /// </value>
        NOT_PERMITTED,
        
    /// <value>
    ///   The specified license is invalid or expired.
    /// </value>
        INVALID_LICENSE,
        
    /// <value>
    ///   A token does not support the specified operation.
    /// </value>
        NOT_SUPPORTED,
        
    /// <value>
    ///   An authenticaiton operation was called specifying a user who has 
    ///   responded incorrectly to a challenge too many times. The user is locked 
    ///   out of their account. 
    /// </value>
        USER_LOCKED,
        
    /// <value>
    ///   An authentication operation was made to authenticate a user and the 
    ///   response was incorrect. The user is locked out of their account. 
    /// </value>
        AUTH_FAILED_USER_LOCKED,
    }
    
    /// <summary>
    ///   Defines an exception returned when a login operation fails because the 
    ///   administrator requires a password change. In addition to the values 
    ///   included in the AdminServiceFault, it also includes the current 
    ///   password rules which define the requirements of the new password. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class AdminPasswordChangeRequiredFault : AdminServiceFault {
        
        private PasswordRulesInfo passwordRulesField;
        
    /// <datatype>
    ///   PasswordRulesInfo
    /// </datatype>
    /// <value>
    ///   The password rules defining the requirements for the new password. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PasswordRulesInfo PasswordRules {
            get {
                return this.passwordRulesField;
            }
            set {
                this.passwordRulesField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a password policy used to specify the rules newly created 
    ///   passwords must obey. The password rules for the default policy apply to 
    ///   master users as well as regular users of the system. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PasswordRulesInfo {
        
        private string nameField;
        
        private int minLengthField;
        
        private int lifetimeField;
        
        private int minLifetimeField;
        
        private int historyField;
        
        private int idleTimeoutField;
        
        private bool uppercaseField;
        
        private bool lowercaseField;
        
        private bool numberField;
        
        private bool specialField;
        
        private AuthenticationType secondAuthField;
        
        private PasswordStorage storageField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the password policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The minimum length of the password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int minLength {
            get {
                return this.minLengthField;
            }
            set {
                this.minLengthField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The lifetime of the password in days. A value of 0 means the password 
    ///   has an infinite lifetime. This value does not apply to master user 
    ///   passwords. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int lifetime {
            get {
                return this.lifetimeField;
            }
            set {
                this.lifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The minimum lifetime of the password in days. A value of 0 means the 
    ///   password has no minimum lifetime. This value controls how frequently 
    ///   users can change their passwords. 
    ///   This value does not apply to master user passwords.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int minLifetime {
            get {
                return this.minLifetimeField;
            }
            set {
                this.minLifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of old passwords kept in history to prevent duplicates. 
    ///   This value does not apply to master user passwords. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int history {
            get {
                return this.historyField;
            }
            set {
                this.historyField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The time in minutes before a logged in but idle administration service 
    ///   session requires relogin. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int idleTimeout {
            get {
                return this.idleTimeoutField;
            }
            set {
                this.idleTimeoutField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the password requires an uppercase character.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool uppercase {
            get {
                return this.uppercaseField;
            }
            set {
                this.uppercaseField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the password requires a lowercase character.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool lowercase {
            get {
                return this.lowercaseField;
            }
            set {
                this.lowercaseField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the password requires a numeric character.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool number {
            get {
                return this.numberField;
            }
            set {
                this.numberField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the password requires a non-alphanumeric character.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool special {
            get {
                return this.specialField;
            }
            set {
                this.specialField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType
    /// </datatype>
    /// <value>
    ///   If set to one of the values GRID, TOKENRO or TOKENCR then an 
    ///   administrator will require this type of second factor authentication to login 
    ///   to the administration service. If set to the value NONE, the 
    ///   administrator will not require second factor authentication to login. This 
    ///   value does not apply to master user login attempts. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public AuthenticationType secondAuth {
            get {
                return this.secondAuthField;
            }
            set {
                this.secondAuthField = value;
            }
        }
        
    /// <datatype>
    ///   PasswordStorage
    /// </datatype>
    /// <value>
    ///   Indicates how the password values are stored in the repository. 
    ///   This value does not apply to how master user passwords are stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PasswordStorage storage {
            get {
                return this.storageField;
            }
            set {
                this.storageField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] rolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   The supported types of authentication. These types are used with the 
    ///   generic authentication operation. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:commonV3")]
    public enum AuthenticationType {
        
    /// <value>
    ///   Authenticate using a card with a grid containing letters and numbers. 
    ///   To use this method, a user must either have a non-expired card in the 
    ///   CURRENT or PENDING states or a temporary PIN that has not yet 
    ///   expired or used too many times. 
    /// </value>
        GRID,
        
    /// <value>
    ///   Authenticate using a set of questions and answers. The user must have 
    ///   provided answers to the questions during the registration process. 
    /// </value>
        QA,
        
    /// <value>
    ///   Authenticate using a one-time password (OTP). The OTP will be 
    ///   generated when the challenge is requested. Entrust IdentityGuard provides 
    ///   mechanisms to deliver the OTP to the user out-of-band. 
    /// </value>
        OTP,
        
    /// <value>
    ///   Authenticate using a token in response-only mode. When using this mode 
    ///   of authentication, no challenge is generated or stored for the user; 
    ///   they simply enter the value displayed on the token to authenticate. 
    ///   To use this method, a user must have a token in the CURRENT or 
    ///   PENDING state or a temporary PIN that has not yet expired or used too many 
    ///   times. 
    /// </value>
        TOKENRO,
        
    /// <value>
    ///   Authenticate using a token in challenge-response mode. When using this 
    ///   mode of authentication, a challenge is generated and stored for the 
    ///   user; they enter this value into their token and respond with the 
    ///   value generated by the token to authenticate. To use this method, a user 
    ///   must have a token in the CURRENT or PENDING state that supports 
    ///   TOKENCR or a temporary PIN that has not yet expired or used too many 
    ///   times. 
    /// </value>
        TOKENCR,
        
    /// <value>
    ///   Authenticate using an external authentication method. The external 
    ///   authentication mechanism such as LDAP or Kerberos authentication must be 
    ///   configured within Entrust IdentityGuard. 
    /// </value>
        EXTERNAL,
        
    /// <value>
    ///   Authenticate using an Entrust IdentityGuard managed password. 
    /// </value>
        PASSWORD,
        
    /// <value>
    ///   No authentication is required.
    /// </value>
        NONE,
    }
    
    /// <summary>
    ///   Defines the choices for how to encode password values in the 
    ///   repository. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum PasswordStorage {
        
    /// <value>
    ///   Indicates that user's passwords are hashed before being encrypted, 
    ///   meaning the server does not store the actual password. 
    /// </value>
        HASHED,
        
    /// <value>
    ///   Indicates that user's passwords are stored in an encrypted fashion, 
    ///   and the server can access the actual password. 
    /// </value>
        ENCRYPTED,
    }
    
    /// <summary>
    ///   Defines the information returned about the preproduced card create 
    ///   operation. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardCreateResult {
        
        private int numCreatedField;
        
        private int numRequestedField;
        
        private string firstSerialNumberField;
        
        private string lastSerialNumberField;
        
        private AdminServiceFault failureReasonField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of cards that were successfully created.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int NumCreated {
            get {
                return this.numCreatedField;
            }
            set {
                this.numCreatedField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of cards requested to be created.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int NumRequested {
            get {
                return this.numRequestedField;
            }
            set {
                this.numRequestedField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the first card created.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string FirstSerialNumber {
            get {
                return this.firstSerialNumberField;
            }
            set {
                this.firstSerialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the last card created.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string LastSerialNumber {
            get {
                return this.lastSerialNumberField;
            }
            set {
                this.lastSerialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   AdminServiceFault
    /// </datatype>
    /// <value>
    ///   The fault describing why the operation failed after some cards were 
    ///   created. Null if the operation didn't fail. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public AdminServiceFault FailureReason {
            get {
                return this.failureReasonField;
            }
            set {
                this.failureReasonField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   preproducedCardCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PreproducedCardCreateCallParms {
        
        private PreproducedCardParms parmsField;
        
    /// <datatype>
    ///   PreproducedCardParms
    /// </datatype>
    /// <value>
    ///   The parameters for the new cards.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PreproducedCardParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   The data returned from a userTokenList operation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenListResult {
        
        private UserTokenInfo[] tokensField;
        
        private string nextUserField;
        
    /// <datatype>
    ///   UserTokenInfo[]
    /// </datatype>
    /// <value>
    ///   The list of tokens.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public UserTokenInfo[] tokens {
            get {
                return this.tokensField;
            }
            set {
                this.tokensField = value;
            }
        }
        
    /// <datatype>
    ///   integer
    /// </datatype>
    /// <value>
    ///   The next user number. If set to a non-zero value, indicates that this 
    ///   result only includes a subset of the results, and additional user 
    ///   tokens have not yet been returned. This value can be included in the 
    ///   filter for a further search to continue the search at the next user. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer", IsNullable=true)]
        public string nextUser {
            get {
                return this.nextUserField;
            }
            set {
                this.nextUserField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned about a user token.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenInfo {
        
        private string useridField;
        
        private string userNameField;
        
        private string groupField;
        
        private string vendorIdField;
        
        private string serialNumberField;
        
        private State stateField;
        
        private string tokenTypeField;
        
        private bool responseSupportedField;
        
        private bool challengeSupportedField;
        
        private bool unlockSupportedField;
        
        private bool signatureSupportedField;
        
        private System.DateTime loadDateField;
        
        private System.Nullable<System.DateTime> lastUsedDateField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID that owns the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user name of the user ID  that owns the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string UserName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group of the user ID that owns the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The vendor id of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string VendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string SerialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   State
    /// </datatype>
    /// <value>
    ///   The state of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public State State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The type of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string TokenType {
            get {
                return this.tokenTypeField;
            }
            set {
                this.tokenTypeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this token supports token response-only 
    ///   authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool ResponseSupported {
            get {
                return this.responseSupportedField;
            }
            set {
                this.responseSupportedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this token supports token challenge/response 
    ///   authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool ChallengeSupported {
            get {
                return this.challengeSupportedField;
            }
            set {
                this.challengeSupportedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this token supports the unlock operation.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool UnlockSupported {
            get {
                return this.unlockSupportedField;
            }
            set {
                this.unlockSupportedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this token supports the data signature operation. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool SignatureSupported {
            get {
                return this.signatureSupportedField;
            }
            set {
                this.signatureSupportedField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The load date of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime LoadDate {
            get {
                return this.loadDateField;
            }
            set {
                this.loadDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The last used date of the token. A value of Date(0) indicates that the 
    ///   token has never been used. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> LastUsedDate {
            get {
                return this.lastUsedDateField;
            }
            set {
                this.lastUsedDateField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The token comment.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenListCallParms {
        
        private UserFilter filterField;
        
    /// <datatype>
    ///   UserFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which tokens are to be returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the filter to limit which users, cards or tokens are to be 
    ///   returned from the userList, userCardList or userTokenList operations. To 
    ///   match the filter, a user, card, or token must match all of the 
    ///   criteria specified. 
    ///   <p>
    ///   Note that it is possible to construct filters that cannot match any 
    ///   users, cards, or tokens, for example by setting one of the "start date" 
    ///   fields to be after the corresponding "end date" field. Such invalid 
    ///   filters will return an empty results list, and do not result in a 
    ///   fault. 
    ///   </p>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserFilter {
        
        private string useridField;
        
        private string aliasField;
        
        private string aliasOrUseridField;
        
        private string fullNameField;
        
        private string[] groupsField;
        
        private string serialNumberField;
        
        private System.Nullable<System.DateTime> createStartDateField;
        
        private System.Nullable<System.DateTime> createEndDateField;
        
        private System.Nullable<System.DateTime> expireStartDateField;
        
        private System.Nullable<System.DateTime> expireEndDateField;
        
        private State[] statesField;
        
        private State[] absentCardStatesField;
        
        private UserState[] userStatesField;
        
        private System.Nullable<int> minChallengeCountField;
        
        private System.Nullable<int> maxChallengeCountField;
        
        private System.Nullable<int> minLeastUsedCellUsageCountField;
        
        private System.Nullable<int> maxLeastUsedCellUsageCountField;
        
        private CardUsageThresholdIndicator[] cardUsageThresholdIndicatorField;
        
        private System.Nullable<bool> hasPINField;
        
        private System.Nullable<int> minNumTempPINUsesField;
        
        private System.Nullable<int> maxNumTempPINUsesField;
        
        private System.Nullable<System.DateTime> tempPINExpireStartDateField;
        
        private System.Nullable<System.DateTime> tempPINExpireEndDateField;
        
        private System.Nullable<bool> hasPVNField;
        
        private System.Nullable<bool> hasPasswordField;
        
        private System.Nullable<bool> pvnChangeRequiredField;
        
        private System.Nullable<System.DateTime> pvnLastChangeStartDateField;
        
        private System.Nullable<System.DateTime> pvnLastChangeEndDateField;
        
        private System.Nullable<bool> passwordChangeRequiredField;
        
        private System.Nullable<System.DateTime> passwordExpireStartDateField;
        
        private System.Nullable<System.DateTime> passwordExpireEndDateField;
        
        private System.Nullable<System.DateTime> passwordLastChangeStartDateField;
        
        private System.Nullable<System.DateTime> passwordLastChangeEndDateField;
        
        private System.Nullable<System.DateTime> activationExpireStartDateField;
        
        private System.Nullable<System.DateTime> activationExpireEndDateField;
        
        private System.Nullable<ActivationCodeFilter> activationExpireCodeField;
        
        private System.Nullable<bool> otpAllowedField;
        
        private AttributeState[] otpDeliveryEnabledField;
        
        private System.Nullable<bool> hasContactInfoField;
        
        private System.Nullable<int> minUsableContactInfoField;
        
        private System.Nullable<int> maxUsableContactInfoField;
        
        private System.Nullable<int> minNumLocationsField;
        
        private System.Nullable<int> maxNumLocationsField;
        
        private System.Nullable<bool> lockedField;
        
        private string tokenVendorIdField;
        
        private string tokenSerialNumberField;
        
        private System.Nullable<System.DateTime> tokenLoadStartDateField;
        
        private System.Nullable<System.DateTime> tokenLoadEndDateField;
        
        private System.Nullable<System.DateTime> tokenLastUsedStartDateField;
        
        private System.Nullable<System.DateTime> tokenLastUsedEndDateField;
        
        private State[] tokenStatesField;
        
        private State[] absentTokenStatesField;
        
        private System.Nullable<int> minNumQaField;
        
        private System.Nullable<int> maxNumQaField;
        
        private System.Nullable<int> minNumMachineSecretsField;
        
        private System.Nullable<int> maxNumMachineSecretsField;
        
        private System.Nullable<bool> hasAuthenticationSecretsField;
        
        private System.Nullable<bool> hasRoleField;
        
        private string[] rolesField;
        
        private System.Nullable<bool> invalidUsersField;
        
        private System.Nullable<int> maxReturnField;
        
        private string nextUserField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, returns only users, cards or tokens whose user name 
    ///   matches this value. 
    ///   The '*' character can be included for wildcard matching.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, returns only users, cards or tokens who have an alias 
    ///   matching this value. 
    ///   The '*' character can be included for wildcard matching.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string alias {
            get {
                return this.aliasField;
            }
            set {
                this.aliasField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, returns only users, cards or tokens whose user name 
    ///   matches this value, or who have an alias matching this value. 
    ///   The '*' character can be included for wildcard matching.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string aliasOrUserid {
            get {
                return this.aliasOrUseridField;
            }
            set {
                this.aliasOrUseridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, returns only users, cards or tokens who have a full name 
    ///   matching this value. 
    ///   The '*' character can be included for wildcard matching.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string FullName {
            get {
                return this.fullNameField;
            }
            set {
                this.fullNameField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If specified, provides a list of group names and returns only users, 
    ///   cards or tokens whose user is in one of the specified groups 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] groups {
            get {
                return this.groupsField;
            }
            set {
                this.groupsField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards with a serial number matching this 
    ///   value, or users who have a card with a serial number matching this 
    ///   value. The '*' character can be included for wildcard matching. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card whose 
    ///   creation date is after the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> createStartDate {
            get {
                return this.createStartDateField;
            }
            set {
                this.createStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card whose 
    ///   creation date is before the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> createEndDate {
            get {
                return this.createEndDateField;
            }
            set {
                this.createEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card whose expiry 
    ///   date is after the given date. This will include cards that don't 
    ///   have an expiry date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> expireStartDate {
            get {
                return this.expireStartDateField;
            }
            set {
                this.expireStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card whose expiry 
    ///   date is before the given date. This will not include cards that 
    ///   don't have an expiry date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> expireEndDate {
            get {
                return this.expireEndDateField;
            }
            set {
                this.expireEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   State[]
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card whose state 
    ///   matches one of the given values. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public State[] states {
            get {
                return this.statesField;
            }
            set {
                this.statesField = value;
            }
        }
        
    /// <datatype>
    ///   State[]
    /// </datatype>
    /// <value>
    ///   If set, only cards not in any of these states, or users who have no 
    ///   cards with any of the states in this list will be returned. For 
    ///   example, if this list includes both CURRENT and PENDING in a call to 
    ///   userList, only users with no cards, or users whose only cards are in the 
    ///   HOLD_PENDING, HOLD or CANCELED states will be returned. No users with 
    ///   CURRENT or PENDING cards will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public State[] absentCardStates {
            get {
                return this.absentCardStatesField;
            }
            set {
                this.absentCardStatesField = value;
            }
        }
        
    /// <datatype>
    ///   UserState[]
    /// </datatype>
    /// <value>
    ///   If specified, returns users who have one of the indicated states. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public UserState[] userStates {
            get {
                return this.userStatesField;
            }
            set {
                this.userStatesField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card with a 
    ///   challenge count no less than this value. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> MinChallengeCount {
            get {
                return this.minChallengeCountField;
            }
            set {
                this.minChallengeCountField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card with a 
    ///   challenge count no greater than this value. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> MaxChallengeCount {
            get {
                return this.maxChallengeCountField;
            }
            set {
                this.maxChallengeCountField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card with a least 
    ///   used cell usage count no less than this value. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> MinLeastUsedCellUsageCount {
            get {
                return this.minLeastUsedCellUsageCountField;
            }
            set {
                this.minLeastUsedCellUsageCountField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card with a least 
    ///   used cell usage count no greater than this value. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> MaxLeastUsedCellUsageCount {
            get {
                return this.maxLeastUsedCellUsageCountField;
            }
            set {
                this.maxLeastUsedCellUsageCountField = value;
            }
        }
        
    /// <datatype>
    ///   CardUsageThresholdIndicator[]
    /// </datatype>
    /// <value>
    ///   If specified, returns only cards or users who have a card whose usage 
    ///   threshold indicator matches one of the given values. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public CardUsageThresholdIndicator[] CardUsageThresholdIndicator {
            get {
                return this.cardUsageThresholdIndicatorField;
            }
            set {
                this.cardUsageThresholdIndicatorField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns only users with a temporary PIN, or 
    ///   cards or tokens whose user has a temporary PIN. 
    ///   If specified as false, returns only users without a temporary PIN, or 
    ///   cards or tokens whose user does not have a temporary PIN. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> hasPIN {
            get {
                return this.hasPINField;
            }
            set {
                this.hasPINField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, only users with a temporary PIN with at least this many uses 
    ///   remaining, or cards or tokens whose user has a temporary PIN with at 
    ///   least this many uses remaining will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> minNumTempPINUses {
            get {
                return this.minNumTempPINUsesField;
            }
            set {
                this.minNumTempPINUsesField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, only users with a temporary PIN with at most this many uses 
    ///   remaining, or cards or tokens whose user has a temporary PIN with at 
    ///   most this many uses remaining will be returned. 
    ///   Temporary PINs with an unlimited number of uses will not be matched if 
    ///   this value is specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxNumTempPINUses {
            get {
                return this.maxNumTempPINUsesField;
            }
            set {
                this.maxNumTempPINUsesField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If set, only users with a temporary PIN that expires on or after this 
    ///   date, or cards or tokens whose user has a temporary PIN that expires 
    ///   on or after this date will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> tempPINExpireStartDate {
            get {
                return this.tempPINExpireStartDateField;
            }
            set {
                this.tempPINExpireStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If set, only users with a temporary PIN that expires on or before this 
    ///   date, or cards or tokens whose user has a temporary PIN that expires 
    ///   on or before this date will be returned. 
    ///   Temporary PINs that are set to never expire will not be matched if 
    ///   this value is specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> tempPINExpireEndDate {
            get {
                return this.tempPINExpireEndDateField;
            }
            set {
                this.tempPINExpireEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns only users with a personal verification 
    ///   number (PVN), or cards or tokens whose user has a PVN. 
    ///   If specified as false, returns only users without a PVN, or cards or 
    ///   tokens whose user does not have a PVN. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> hasPVN {
            get {
                return this.hasPVNField;
            }
            set {
                this.hasPVNField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns only users with a password, or cards or 
    ///   tokens whose user has a password. 
    ///   If specified as false, returns only users without a password, or cards 
    ///   or tokens whose user does not have a password. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> hasPassword {
            get {
                return this.hasPasswordField;
            }
            set {
                this.hasPasswordField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns only users that require a personal 
    ///   verification number (PVN) change, or cards or tokens whose user requires a 
    ///   PVN change. 
    ///   If specified as false, returns only users that do not require a PVN 
    ///   change, or cards or tokens whose user does not require a PVN change. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> pvnChangeRequired {
            get {
                return this.pvnChangeRequiredField;
            }
            set {
                this.pvnChangeRequiredField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only users who have a PVN last change date on or 
    ///   after the given date, or cards or tokens whose user has a PVN last 
    ///   change date on or after the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> pvnLastChangeStartDate {
            get {
                return this.pvnLastChangeStartDateField;
            }
            set {
                this.pvnLastChangeStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only users who have a PVN last change date on or 
    ///   before the given date, or cards or tokens whose user has a PVN last 
    ///   change date on or before the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> pvnLastChangeEndDate {
            get {
                return this.pvnLastChangeEndDateField;
            }
            set {
                this.pvnLastChangeEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns only users that require a password 
    ///   change, or cards or tokens whose user requires a password change. 
    ///   If specified as false, returns only users that do not require a 
    ///   password change, or cards or tokens whose user does not require a password 
    ///   change. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> passwordChangeRequired {
            get {
                return this.passwordChangeRequiredField;
            }
            set {
                this.passwordChangeRequiredField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only users who have a password expiry date on or 
    ///   after the given date, or cards or tokens whose user has a password 
    ///   expiring on or after the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> passwordExpireStartDate {
            get {
                return this.passwordExpireStartDateField;
            }
            set {
                this.passwordExpireStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only users who have a password expiry date on or 
    ///   before the given date, or cards or tokens whose user has a password 
    ///   expiring on or before the given date. 
    ///   Passwords set to never expire will not be matched if this value is 
    ///   set. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> passwordExpireEndDate {
            get {
                return this.passwordExpireEndDateField;
            }
            set {
                this.passwordExpireEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only users who have a password last change date 
    ///   on or after the given date, or cards or tokens whose user last 
    ///   changed their password on or after the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> passwordLastChangeStartDate {
            get {
                return this.passwordLastChangeStartDateField;
            }
            set {
                this.passwordLastChangeStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only users who have a password last change date 
    ///   on or before the given date, or cards or tokens whose user last 
    ///   changed their password on or before the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> passwordLastChangeEndDate {
            get {
                return this.passwordLastChangeEndDateField;
            }
            set {
                this.passwordLastChangeEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only users who have an activation expiry date on 
    ///   or after the given date, or cards or tokens whose user has an 
    ///   activation expiry date on or after the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> activationExpireStartDate {
            get {
                return this.activationExpireStartDateField;
            }
            set {
                this.activationExpireStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only users who have an activation expiry date on 
    ///   or before the given date, or cards or tokens whose user has an 
    ///   activation expiry date on or before the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> activationExpireEndDate {
            get {
                return this.activationExpireEndDateField;
            }
            set {
                this.activationExpireEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   ActivationCodeFilter
    /// </datatype>
    /// <value>
    ///   If specified, returns only users whose activation state matches the 
    ///   given state, or cards or tokens whose user has an activation state 
    ///   matching the given state. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<ActivationCodeFilter> activationExpireCode {
            get {
                return this.activationExpireCodeField;
            }
            set {
                this.activationExpireCodeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns only users that are allowed to use 
    ///   one-time password (OTP), or cards or tokens whose user is allowed to use 
    ///   an OTP. 
    ///   If specified as true, returns only users that are not allowed to use 
    ///   an OTP, or cards or tokens whose user is not allowed to use an OTP. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> otpAllowed {
            get {
                return this.otpAllowedField;
            }
            set {
                this.otpAllowedField = value;
            }
        }
        
    /// <datatype>
    ///   AttributeState[]
    /// </datatype>
    /// <value>
    ///   If specified, returns users whose otpDeliveryEnabled attribute is one 
    ///   of the indicated states, or cards or tokens whose user has an 
    ///   otpDeliveryEnabled attribute matching one of the indicated states. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AttributeState[] otpDeliveryEnabled {
            get {
                return this.otpDeliveryEnabledField;
            }
            set {
                this.otpDeliveryEnabledField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns only users who have contact information, 
    ///   or cards or tokens whose user has contact information. If specified 
    ///   as false, returns only users who do not have contact information, or 
    ///   cards or tokens whose user does not have contact information. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> hasContactInfo {
            get {
                return this.hasContactInfoField;
            }
            set {
                this.hasContactInfoField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, returns only users with at least this many contact information 
    ///   that refer to a delivery mechanism other than the special "NONE" 
    ///   mechanism, or cards or tokens whose user matches this criteria. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> minUsableContactInfo {
            get {
                return this.minUsableContactInfoField;
            }
            set {
                this.minUsableContactInfoField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, returns only users with at most this many contact information 
    ///   that refer to a delivery mechanism other than the special "NONE" 
    ///   mechanism, or cards or tokens whose user matches this criteria. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxUsableContactInfo {
            get {
                return this.maxUsableContactInfoField;
            }
            set {
                this.maxUsableContactInfoField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, only users with at least this many locations in their location 
    ///   history, or cards or tokens whose user has at least this many 
    ///   locations in their location history, will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> minNumLocations {
            get {
                return this.minNumLocationsField;
            }
            set {
                this.minNumLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, only users with at most this many locations in their location 
    ///   history, or cards or tokens whose user has at most this many 
    ///   locations in their location history, will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxNumLocations {
            get {
                return this.maxNumLocationsField;
            }
            set {
                this.maxNumLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns only users who are locked out, or cards 
    ///   or tokens whose user is locked out. 
    ///   If specified as false, returns only users who are not locked out, or 
    ///   cards or tokens whose user is not locked out. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> locked {
            get {
                return this.lockedField;
            }
            set {
                this.lockedField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, returns only tokens or users who have a token whose 
    ///   vendorid matches the given value. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string tokenVendorId {
            get {
                return this.tokenVendorIdField;
            }
            set {
                this.tokenVendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, returns only tokens with a serial number matching this 
    ///   value, or users who have a token with a serial number matching this 
    ///   value. The '*' character can be included for wildcard matching. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string tokenSerialNumber {
            get {
                return this.tokenSerialNumberField;
            }
            set {
                this.tokenSerialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only tokens or users who have a token whose load 
    ///   date is after the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> tokenLoadStartDate {
            get {
                return this.tokenLoadStartDateField;
            }
            set {
                this.tokenLoadStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only tokens or users who have a token whose load 
    ///   date is before the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> tokenLoadEndDate {
            get {
                return this.tokenLoadEndDateField;
            }
            set {
                this.tokenLoadEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only tokens or users who have a token whose last 
    ///   used date is after the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> tokenLastUsedStartDate {
            get {
                return this.tokenLastUsedStartDateField;
            }
            set {
                this.tokenLastUsedStartDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   If specified, returns only tokens or users who have a token whose last 
    ///   used date is before the given date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> tokenLastUsedEndDate {
            get {
                return this.tokenLastUsedEndDateField;
            }
            set {
                this.tokenLastUsedEndDateField = value;
            }
        }
        
    /// <datatype>
    ///   State[]
    /// </datatype>
    /// <value>
    ///   If specified, returns only tokens or users who have a token whose 
    ///   state matches one of the given values. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public State[] tokenStates {
            get {
                return this.tokenStatesField;
            }
            set {
                this.tokenStatesField = value;
            }
        }
        
    /// <datatype>
    ///   State[]
    /// </datatype>
    /// <value>
    ///   If set, only tokens not in any of these states, or users who have no 
    ///   tokens with any of the states in this list will be returned. For 
    ///   example, if this list includes both CURRENT and PENDING in a call to 
    ///   userList, only users with no tokens, or users whose only tokens are in the 
    ///   HOLD_PENDING, HOLD or CANCELED states will be returned. No users 
    ///   with CURRENT or PENDING tokens will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public State[] absentTokenStates {
            get {
                return this.absentTokenStatesField;
            }
            set {
                this.absentTokenStatesField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, only users with at least this many question/answer (Q/A) pairs 
    ///   defined, or cards or tokens whose user has at least this many Q/A 
    ///   pairs, will be returned. 
    ///   To find all users with Q/A pairs defined, set this value to 1. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> minNumQa {
            get {
                return this.minNumQaField;
            }
            set {
                this.minNumQaField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, only users with at most this many question/answer (Q/A) pairs 
    ///   defined, or cards or tokens whose user has at most this many Q/A 
    ///   pairs, will be returned. 
    ///   To find all users with no Q/A pairs, set this value to 0.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxNumQa {
            get {
                return this.maxNumQaField;
            }
            set {
                this.maxNumQaField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, only users with at least this many machine secrets (registered 
    ///   machines), or cards or tokens whose user has at least this many 
    ///   machine secrets, will be returned. To find all users who have machine 
    ///   secrets, or cards or tokens whose user has machine secrets, set this 
    ///   value to 1. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> minNumMachineSecrets {
            get {
                return this.minNumMachineSecretsField;
            }
            set {
                this.minNumMachineSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If set, only users with at most this many machine secrets (registered 
    ///   machines), or cards or tokens whose user has at most this many 
    ///   machine secrets, will be returned. To find all users who do not have any 
    ///   machine secrets, or cards or tokens whose user does not have any 
    ///   machine secrets, set this value to 1. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxNumMachineSecrets {
            get {
                return this.maxNumMachineSecretsField;
            }
            set {
                this.maxNumMachineSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns any user who has mutual authentication 
    ///   secrets, or any card or token whose user has mutual authentication 
    ///   secrets. If specified as false, only users who do not have mutual 
    ///   authentication secrets, or cards or tokens whose user does not have any 
    ///   mutual authentication secrets, will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> hasAuthenticationSecrets {
            get {
                return this.hasAuthenticationSecretsField;
            }
            set {
                this.hasAuthenticationSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, returns any user who has a role, or cards or 
    ///   tokens whose user has a role. 
    ///   If specified as false, only users who do not have a role, or cards or 
    ///   tokens whose user does not have a role, will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> hasRole {
            get {
                return this.hasRoleField;
            }
            set {
                this.hasRoleField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If specified, only users who have at least one of the roles in this 
    ///   list, or cards or tokens whose user has at least one of the roles in 
    ///   this list, will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] roles {
            get {
                return this.rolesField;
            }
            set {
                this.rolesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   An invalid user is a user that doesn't pass data integrity. In the 
    ///   case of LDAP, this is a likely indication that the user has been renamed 
    ///   in the repository without being renamed within Entrust 
    ///   IdentityGuard. If this flag is set to true, only users that pass data integrity 
    ///   will be returned. If this flag is set to false, only users that don't 
    ///   pass data integrity will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> invalidUsers {
            get {
                return this.invalidUsersField;
            }
            set {
                this.invalidUsersField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of users, cards or tokens to return.
    ///   If not specified or the value is 0 or less, it defaults to 100. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxReturn {
            get {
                return this.maxReturnField;
            }
            set {
                this.maxReturnField = value;
            }
        }
        
    /// <datatype>
    ///   integer
    /// </datatype>
    /// <value>
    ///   The nextUser number. If specified, indicates that searching should 
    ///   start at the given user. This value is used to get the next set of 
    ///   users, cards, or tokens following a previous search. 
    ///   The value to set here is the nextUser value from the previous search 
    ///   results. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer", IsNullable=true)]
        public string nextUser {
            get {
                return this.nextUserField;
            }
            set {
                this.nextUserField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the possible user states.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum UserState {
        
    /// <value>
    ///   The user account is active within the system and is allowed to 
    ///   authenticate. 
    ///   Users in the ACTIVE state can be changed to the SUSPENDED state at any 
    ///   time. 
    /// </value>
        ACTIVE,
        
    /// <value>
    ///   The user's account is suspended, and the user is not allowed to 
    ///   authenticate to the system. 
    ///   Accounts in the SUSPENDED state can be changed to the ACTIVE state at 
    ///   any time. 
    /// </value>
        SUSPENDED,
    }
    
    /// <summary>
    ///   Defines the possible card usage threshold indicator values. The 
    ///   CardUsageThresholdIndicator value indicates whether the card's challenge 
    ///   count or least-used cell usage count has reached either the replacement 
    ///   or warning threshold as defined in policy. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum CardUsageThresholdIndicator {
        
    /// <value>
    ///   Placeholder in case new indicator values are added in future releases. 
    ///   This value should never be used in calls to the admin service, and 
    ///   if it is returned to the application then the application needs to be 
    ///   updated to use the latest version of the admin service. 
    /// </value>
        UNKNOWN,
        
    /// <value>
    ///   Indicates that no usage threshold has been reached.
    /// </value>
        NONE,
        
    /// <value>
    ///   Indicates that the warning threshold for either the number of 
    ///   challenges or the least-used cell count has been reached. Cards with this 
    ///   indicator value can still be used to authenticate, but a new card should 
    ///   be issued to the user. 
    /// </value>
        WARNING,
        
    /// <value>
    ///   Indicates that the replacement threshold for either the number of 
    ///   challenges or the least-used cell count has been reached. Cards with this 
    ///   indicator are automatically put in to the HOLD state when used to 
    ///   authenticate. The user to which the card belongs should be issued a 
    ///   replacement card as soon as possible. 
    /// </value>
        REPLACEMENT,
    }
    
    /// <summary>
    ///   Defines possible Activation states for search queries.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum ActivationCodeFilter {
        
    /// <value>
    ///   State for users who have no activation information set.
    /// </value>
        NOTSET,
        
    /// <value>
    ///   State for users who have successfully activated.
    /// </value>
        ACTIVATED,
        
    /// <value>
    ///   State for users who are expected to go through an activation process 
    ///   but have not yet done so. 
    /// </value>
        NOTACTIVATED,
    }
    
    /// <summary>
    ///   Defines the value of an attribute when the attribute can take on a 
    ///   Boolean value, or can be set to use the relevant value defined in the 
    ///   policy. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum AttributeState {
        
    /// <value>
    ///   The attribute has the Boolean value true.
    /// </value>
        TRUE,
        
    /// <value>
    ///   The attribute has the Boolean value false.
    /// </value>
        FALSE,
        
    /// <value>
    ///   The attribute has been set to use whatever corresponding Boolean value 
    ///   is defined in the policy. 
    /// </value>
        USEPOLICY,
    }
    
    /// <summary>
    ///   This structure contains the information returned by a call to 
    ///   userTokenUnlock 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenUnlockResult {
        
        private UserTokenInfo tokenField;
        
        private string unlockCodeField;
        
    /// <datatype>
    ///   UserTokenInfo
    /// </datatype>
    /// <value>
    ///   The token that was unlocked.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenInfo token {
            get {
                return this.tokenField;
            }
            set {
                this.tokenField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The code that can be used to unlock the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string unlockCode {
            get {
                return this.unlockCodeField;
            }
            set {
                this.unlockCodeField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenUnlock. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenUnlockCallParms {
        
        private string useridField;
        
        private UserTokenFilter filterField;
        
        private string challengeField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user who owns the token to be unlocked.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which token is to be unlocked. This filter must 
    ///   specify a single token. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The unlock challenge generated by the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string challenge {
            get {
                return this.challengeField;
            }
            set {
                this.challengeField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a filter to limit which tokens are returned for a user. If 
    ///   both VendorId/SerialNumber and State are set, VendorId/SerialNumber is 
    ///   used. If neither are set, all tokens for the user are returned. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenFilter {
        
        private string vendorIdField;
        
        private string serialNumberField;
        
        private State[] stateField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Tokens that match the given vendor Id.
    ///   This value is ignored if the serialNumber is not specified. If a 
    ///   serial number is specified and this value is not, then the default token 
    ///   vendor is assumed, and any token from the default token vendor 
    ///   matching the given serial number is returned. Note that this value can 
    ///   contain either the name or id of the token vendor. Either value will match 
    ///   the token vendor. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string VendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Tokens that match the given serial number.
    ///   The value can include the '*' character for wildcard matching. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string SerialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   State[]
    /// </datatype>
    /// <value>
    ///   Tokens that match one of the given states.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public State[] State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenChallengeAuthenticate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenChallengeAuthenticateCallParms {
        
        private string useridField;
        
        private UserTokenFilter filterField;
        
        private string responseField;
        
        private System.Nullable<bool> obeyLockoutField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to authenticate using a token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which token is to be used for authentication. 
    ///   The filter must evaluate to a single token. The token must support 
    ///   challenge. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The response to authenticate.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string response {
            get {
                return this.responseField;
            }
            set {
                this.responseField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If this flag is true, this operation will check the user's current 
    ///   lockout and update the lockout based on whether the response 
    ///   authenticates. If this flag is false, this operation will ignore lockout. If not 
    ///   set, this flag defaults to false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> obeyLockout {
            get {
                return this.obeyLockoutField;
            }
            set {
                this.obeyLockoutField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenAuthenticate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenAuthenticateCallParms {
        
        private string useridField;
        
        private UserTokenFilter filterField;
        
        private string responseField;
        
        private System.Nullable<bool> obeyLockoutField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to authenticate using a token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which token is to be used for authentication. 
    ///   The filter must evaluate to a single token. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The response to authenticate.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string response {
            get {
                return this.responseField;
            }
            set {
                this.responseField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If this flag is true, this operation will check the user's current 
    ///   lockout and update the lockout based on whether the response 
    ///   authenticates. If this flag is false, this operation will ignore lockout. If not 
    ///   set, this flag defaults to false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> obeyLockout {
            get {
                return this.obeyLockoutField;
            }
            set {
                this.obeyLockoutField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenChallengeGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenChallengeGetCallParms {
        
        private string useridField;
        
        private UserTokenFilter filterField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user which owns the token for which a challenge will be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which token is to be used to generate the 
    ///   challenge. The filter must evaluate to a single token and that token must 
    ///   support challenges. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenUnassign. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenUnassignCallParms {
        
        private string useridField;
        
        private UserTokenFilter filterField;
        
        private UserTokenParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to unassign tokens from.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which tokens are to be unassigned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenParms
    /// </datatype>
    /// <value>
    ///   May contain a new comment for the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when assigning or modifying a user 
    ///   token. All values can be null indicating that the default is used for 
    ///   assign or the value is not changed for modify. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenParms {
        
        private System.Nullable<State> stateField;
        
        private System.Nullable<bool> resetTokenField;
        
        private string resetTokenResponse1Field;
        
        private string resetTokenResponse2Field;
        
        private string commentField;
        
    /// <datatype>
    ///   State
    /// </datatype>
    /// <value>
    ///   The state of the token. If set when assigning a token to a user, this 
    ///   must be one of PENDING. 
    ///   HOLD_PENDING, CURRENT, or HOLD. If not specified when assigning a 
    ///   token to a user, the token state is set to PENDING. 
    ///   This state is also subject to the restriction that a user can have at 
    ///   most one token in either of the PENDING or HOLD_PENDING states, and 
    ///   at most one token in either of the CURRENT or HOLD states. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<State> State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If specified as true, the token will be reset.
    ///   Note that some token implementations require that one or two token 
    ///   responses be included with the token reset request. These responses are 
    ///   specified in the resetTokenResponse1 and resetTokenResponse2 
    ///   attributes. 
    ///   This value is ignored when assigning a token to a user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> resetToken {
            get {
                return this.resetTokenField;
            }
            set {
                this.resetTokenField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   To reset a token, some token implementations require one or two token 
    ///   responses. If required, this attribute specifies the first response. 
    ///   If this attribute is specified, the resetToken attribute is ignored. 
    ///   This value is ignored when assigning a token to a user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string resetTokenResponse1 {
            get {
                return this.resetTokenResponse1Field;
            }
            set {
                this.resetTokenResponse1Field = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   To reset a token, some token implementations require two token 
    ///   responses. If specified, this attribute specifies the second response. 
    ///   This value is ignored when assigning a token to a user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string resetTokenResponse2 {
            get {
                return this.resetTokenResponse2Field;
            }
            set {
                this.resetTokenResponse2Field = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The token comment. If not set when assigning a token to a user, the 
    ///   existing token comments are preserved. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenSetCallParms {
        
        private string useridField;
        
        private UserTokenFilter filterField;
        
        private UserTokenParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to update tokens for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which tokens are to be updated.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenParms
    /// </datatype>
    /// <value>
    ///   The parameters to update each token with.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenGetCallParms {
        
        private string useridField;
        
        private UserTokenFilter filterField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to get tokens for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which tokens are to be returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenDeleteCallParms {
        
        private string useridField;
        
        private UserTokenFilter filterField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to delete tokens for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which tokens are to be deleted.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userTokenAssign. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserTokenAssignCallParms {
        
        private string useridField;
        
        private string vendorIdField;
        
        private string serialNumberField;
        
        private UserTokenParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to assign a token to.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The vendor id of the token to assign to the user. If not specified, 
    ///   the default vendor is used. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string vendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the token to assign to the user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string serialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenParms
    /// </datatype>
    /// <value>
    ///   The parameters for the new token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserTokenParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   The data returned from a card export operation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class CardExportResult {
        
        private string numCardsField;
        
        private string infoField;
        
    /// <datatype>
    ///   integer
    /// </datatype>
    /// <value>
    ///   The number of cards exported.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer")]
        public string numCards {
            get {
                return this.numCardsField;
            }
            set {
                this.numCardsField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Information about the card export.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string info {
            get {
                return this.infoField;
            }
            set {
                this.infoField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userCardExport. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardExportCallParms {
        
        private UserFilter filterField;
        
        private NameValue[] parmsField;
        
    /// <datatype>
    ///   UserFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which cards are to be exported
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   NameValue[]
    /// </datatype>
    /// <value>
    ///   A list of parameters. Not currently used.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public NameValue[] parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   The data returned from a userCardList operation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardListResult {
        
        private UserCardInfo[] cardsField;
        
        private string nextUserField;
        
    /// <datatype>
    ///   UserCardInfo[]
    /// </datatype>
    /// <value>
    ///   The list of cards.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public UserCardInfo[] cards {
            get {
                return this.cardsField;
            }
            set {
                this.cardsField = value;
            }
        }
        
    /// <datatype>
    ///   integer
    /// </datatype>
    /// <value>
    ///   The next user number. If set to a non-zero value, indicates that this 
    ///   result only includes a subset of the results, and additional user 
    ///   cards have not yet been returned. This value can be included in the 
    ///   filter for a further search to continue the search at the next user. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer", IsNullable=true)]
        public string nextUser {
            get {
                return this.nextUserField;
            }
            set {
                this.nextUserField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned about a user card.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardInfo {
        
        private string useridField;
        
        private string userNameField;
        
        private string groupField;
        
        private string serialNumberField;
        
        private State stateField;
        
        private System.DateTime createDateField;
        
        private System.Nullable<System.DateTime> expireDateField;
        
        private System.Nullable<System.DateTime> supersededDateField;
        
        private Grid gridField;
        
        private System.Nullable<int> challengeCountField;
        
        private System.Nullable<int> leastUsedCellUsageCountField;
        
        private System.Nullable<CardUsageThresholdIndicator> cardUsageThresholdIndicatorField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
        private System.Nullable<bool> preproducedField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID that owns the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user name of the user ID that owns the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string UserName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group of the user ID that owns the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string SerialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   State
    /// </datatype>
    /// <value>
    ///   The state of the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public State State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The create date of the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime CreateDate {
            get {
                return this.createDateField;
            }
            set {
                this.createDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The expiry date of the card. A value of Date(0) indicates the card 
    ///   doesn't have an expiry date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> ExpireDate {
            get {
                return this.expireDateField;
            }
            set {
                this.expireDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The supersede date of the card. This is the date beyond which the card 
    ///   cannot be used to authenticate because a newer card exists. 
    ///   A value of null indicates that the card has not been superseded. A 
    ///   value of Date(0) indicates a superseded card that can be used until the 
    ///   expiry date is reached. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> SupersededDate {
            get {
                return this.supersededDateField;
            }
            set {
                this.supersededDateField = value;
            }
        }
        
    /// <datatype>
    ///   Grid
    /// </datatype>
    /// <value>
    ///   The contents of the card. The value will be null if the operation used 
    ///   to retrieve the card did not request the grid, or if the caller does 
    ///   not have permission to view the grid. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public Grid Grid {
            get {
                return this.gridField;
            }
            set {
                this.gridField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of times this card has been used in successful 
    ///   authentication. This value will be null if usage statistics are not gathered. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> ChallengeCount {
            get {
                return this.challengeCountField;
            }
            set {
                this.challengeCountField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of times the least used cell on the card has been used in a 
    ///   successfully authenticated challenge. 
    ///   This value will be null if usage statistics are not gathered. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> LeastUsedCellUsageCount {
            get {
                return this.leastUsedCellUsageCountField;
            }
            set {
                this.leastUsedCellUsageCountField = value;
            }
        }
        
    /// <datatype>
    ///   CardUsageThresholdIndicator
    /// </datatype>
    /// <value>
    ///   An indicator that either the challenge count or the least-used cell 
    ///   usage count has reached its replacement or warning usage threshold as 
    ///   defined in policy. 
    ///   This value will be null if usage statistics are not gathered. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<CardUsageThresholdIndicator> CardUsageThresholdIndicator {
            get {
                return this.cardUsageThresholdIndicatorField;
            }
            set {
                this.cardUsageThresholdIndicatorField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The comment for the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   An indicator for whether this card was created as a preproduced card. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> Preproduced {
            get {
                return this.preproducedField;
            }
            set {
                this.preproducedField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userCardList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardListCallParms {
        
        private UserFilter filterField;
        
        private CardGetParms parmsField;
        
    /// <datatype>
    ///   UserFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which cards are to be returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   CardGetParms
    /// </datatype>
    /// <value>
    ///   Parameters that control what information is returned for each card. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public CardGetParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userCardUnassign. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardUnassignCallParms {
        
        private string useridField;
        
        private UserCardFilter filterField;
        
        private UserCardParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to unassign cards from.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserCardFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which cards are to be unassigned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserCardFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   UserCardParms
    /// </datatype>
    /// <value>
    ///   May contain a new comment for the card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserCardParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when creating or modifying a user card. 
    ///   All values can be null indicating that the default is used when 
    ///   creating a card, or the value is not changed when modifying a card. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardParms {
        
        private string serialNumberField;
        
        private System.Nullable<long> lifetimeField;
        
        private System.Nullable<long> supersedeField;
        
        private System.Nullable<State> stateField;
        
        private System.Nullable<int> challengeCountField;
        
        private System.Nullable<int> leastUsedCellUsageCountField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   If specified, indicates that instead of creating a new card, an 
    ///   existing preproduced card will be assigned to this user. This parameter is 
    ///   ignored by the userCardSet and userCardUnassign operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string SerialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The lifetime of the card in milliseconds. The value must be a 
    ///   non-negative integer. A value of 0 means the card has an infinite lifetime. 
    ///   If not set for userCardCreate, defaults to the value set in the 
    ///   policy. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<long> Lifetime {
            get {
                return this.lifetimeField;
            }
            set {
                this.lifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The superseded lifetime of a card, in milliseconds. During card 
    ///   creation, this value will define the superseded lifetime of an existing 
    ///   card that is superseded by the card being created or assigned to the 
    ///   user. If not set for user card creation, the superseded lifetime value 
    ///   in the policy is used. 
    ///   During card update, this applies to the card being updated. A value of 
    ///   0 means the card has an infinite superseded lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<long> Supersede {
            get {
                return this.supersedeField;
            }
            set {
                this.supersedeField = value;
            }
        }
        
    /// <datatype>
    ///   State
    /// </datatype>
    /// <value>
    ///   The state of the card. If set during user card creation, this must be 
    ///   one of PENDING, HOLD_PENDING, CURRENT, or HOLD. If not specified for 
    ///   user card creation, the card state is set to PENDING. 
    ///   This state is also subject to the restriction that a user can have at 
    ///   most one card in either of the PENDING or HOLD_PENDING states, and at 
    ///   most one card in either of the CURRENT or HOLD states. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<State> State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of times this card has been used in successful 
    ///   authentication. If not set, this parameter will not be used. This parameter is 
    ///   ignored by user card creation. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> ChallengeCount {
            get {
                return this.challengeCountField;
            }
            set {
                this.challengeCountField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of times the least used cell on the card has been used in a 
    ///   successfully authenticated challenge. If not set, this parameter 
    ///   will not be used. This parameter is ignored when creating a card. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> LeastUsedCellUsageCount {
            get {
                return this.leastUsedCellUsageCountField;
            }
            set {
                this.leastUsedCellUsageCountField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The card comment. If this value is not set when creating a new card, 
    ///   it defaults to an empty string. If it is not set when assigning a 
    ///   pre-produced card to a user, the existing pre-produced card comments are 
    ///   preserved. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userCardSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardSetCallParms {
        
        private string useridField;
        
        private UserCardFilter filterField;
        
        private UserCardParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to update cards for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserCardFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which cards are to be updated.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserCardFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   UserCardParms
    /// </datatype>
    /// <value>
    ///   The parameters to update each card with.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserCardParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userCardGet 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardGetCallParms {
        
        private string useridField;
        
        private UserCardFilter filterField;
        
        private CardGetParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to get cards for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserCardFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which cards are to be returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserCardFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   CardGetParms
    /// </datatype>
    /// <value>
    ///   Parameters that control what information is returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public CardGetParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userCardDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardDeleteCallParms {
        
        private string useridField;
        
        private UserCardFilter filterField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to delete cards for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserCardFilter
    /// </datatype>
    /// <value>
    ///   The filter indicating which cards are to be deleted
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserCardFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userCardCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCardCreateCallParms {
        
        private string useridField;
        
        private UserCardParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to create a card for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserCardParms
    /// </datatype>
    /// <value>
    ///   The parameters that set the options for the new card.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserCardParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userPVNGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPVNGetCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to get the personal verification number (PVN) for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userPVNDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPVNDeleteCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to delete the personal verification number (PVN) for. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when modifying a user's personal 
    ///   verification number (PVN). 
    ///   Either PVN or AutoGenerate may be specified.
    ///   The ChangeRequired flag may also be specified.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPVNSetParms {
        
        private string oldPVNField;
        
        private string pVNField;
        
        private System.Nullable<bool> autoGenerateField;
        
        private System.Nullable<bool> changeRequiredField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The old PVN value that the user currently has.
    ///   If provided, then the old PVN value is validated before a new PVN 
    ///   value will be assigned. 
    ///   If OldPVN is specified, then PVN must also be specified. If the old 
    ///   PVN does not need to be validated when specifying a new PVN, or if not 
    ///   specifying a new PVN, then leave this as null. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string OldPVN {
            get {
                return this.oldPVNField;
            }
            set {
                this.oldPVNField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The new PVN value to assign to the user, replacing their existing 
    ///   value. This value must be numeric, and must obey the PVN Length rule as 
    ///   defined by policy. 
    ///   If not assigning a new PVN, leave as null.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string PVN {
            get {
                return this.pVNField;
            }
            set {
                this.pVNField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, indicates a random PVN value should be generated and assigned 
    ///   to the user, replacing their existing value. 
    ///   If not autogenerating a new PVN, leave as null.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> AutoGenerate {
            get {
                return this.autoGenerateField;
            }
            set {
                this.autoGenerateField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, indicates that the user will be required to change their PVN 
    ///   value. If false, indicates that the user will not be required to 
    ///   change their PVN value. If not modifying the change required state, then 
    ///   leave this as null. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ChangeRequired {
            get {
                return this.changeRequiredField;
            }
            set {
                this.changeRequiredField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userPVNSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPVNSetCallParms {
        
        private string useridField;
        
        private UserPVNSetParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to modify a personal verification number (PVN) for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserPVNSetParms
    /// </datatype>
    /// <value>
    ///   The parameters for modifying the personal verification number (PVN). 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserPVNSetParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when creating a user's personal 
    ///   verification number (PVN). 
    ///   Either PVN or AutoGenerate must be specified.
    ///   The ChangeRequired flag may be specified.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPVNCreateParms {
        
        private string pVNField;
        
        private System.Nullable<bool> autoGenerateField;
        
        private System.Nullable<bool> changeRequiredField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The new PVN value to assign to the user.
    ///   This value must be numeric, and must obey the PVN Length rule as 
    ///   defined by policy. 
    ///   If using AutoGenerate, leave this as null.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string PVN {
            get {
                return this.pVNField;
            }
            set {
                this.pVNField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, indicates a random PVN value should be generated and assigned 
    ///   to the user. 
    ///   If specifying the PVN value, leave this as null.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> AutoGenerate {
            get {
                return this.autoGenerateField;
            }
            set {
                this.autoGenerateField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, indicates that the user will be required to change their PVN 
    ///   value. If false, indicates that the user will not be required to 
    ///   change their PVN value. Note that the policy may not allow setting this 
    ///   value to false. 
    ///   If left as null, the user will be required to change their PVN. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ChangeRequired {
            get {
                return this.changeRequiredField;
            }
            set {
                this.changeRequiredField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userPVNCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPVNCreateCallParms {
        
        private string useridField;
        
        private UserPVNCreateParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to create a personal verification number (PVN) for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserPVNCreateParms
    /// </datatype>
    /// <value>
    ///   The parameters for creating the personal verification number (PVN). 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserPVNCreateParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userPasswordDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPasswordDeleteCallParms {
        
        private string useridField;
        
        private System.Nullable<bool> keepHistoryField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user for which to delete the password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates whether to keep the password history. Default is to delete 
    ///   the history. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> keepHistory {
            get {
                return this.keepHistoryField;
            }
            set {
                this.keepHistoryField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userPasswordGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPasswordGetCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user for which to get the password information.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userPasswordSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPasswordSetCallParms {
        
        private string useridField;
        
        private UserPasswordParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user for which to modify the password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserPasswordParms
    /// </datatype>
    /// <value>
    ///   The parameters for the password modification.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserPasswordParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when creating or modifying a user 
    ///   password. All values can be null, indicating that the default is used for 
    ///   create or the value is not changed for modify. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPasswordParms {
        
        private string passwordField;
        
        private System.Nullable<bool> autoGenerateField;
        
        private System.Nullable<int> daysToExpiryField;
        
        private System.Nullable<bool> changeRequiredField;
        
        private System.Nullable<bool> clearPasswordHistoryField;
        
        private System.Nullable<bool> clearRetrievablePasswordField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The password value. Must be null if autoGenerate is used.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Password {
            get {
                return this.passwordField;
            }
            set {
                this.passwordField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, indicates a random password will be generated.
    ///   Default is false during password creation.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> AutoGenerate {
            get {
                return this.autoGenerateField;
            }
            set {
                this.autoGenerateField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The lifetime of the password in days. The value must be a non-negative 
    ///   integer. A value of 0 means the password has infinite lifetime. 
    ///   When modifying a password and setting this value, the expiry date will 
    ///   be calculated from the current date, not the date the password was 
    ///   created. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> DaysToExpiry {
            get {
                return this.daysToExpiryField;
            }
            set {
                this.daysToExpiryField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates if a password change will be required by user.
    ///   Default is true during password creation.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ChangeRequired {
            get {
                return this.changeRequiredField;
            }
            set {
                this.changeRequiredField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates if the password history must be cleared.
    ///   Default is false during password creation.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ClearPasswordHistory {
            get {
                return this.clearPasswordHistoryField;
            }
            set {
                this.clearPasswordHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates if the retrievable password must be cleared.
    ///   Default is false during password creation.
    ///   Setting this to true will generate a fault if autoGenerate is also set 
    ///   to true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ClearRetrievablePassword {
            get {
                return this.clearRetrievablePasswordField;
            }
            set {
                this.clearRetrievablePasswordField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userPasswordCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPasswordCreateCallParms {
        
        private string useridField;
        
        private UserPasswordParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user for which to create a password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserPasswordParms
    /// </datatype>
    /// <value>
    ///   The parameters for the new password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserPasswordParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userOTPGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserOTPGetCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to get the one-time password (OTP) for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userOTPDeliver. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserOTPDeliverCallParms {
        
        private string useridField;
        
        private string contactInfoLabelField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to deliver the one-time password (OTP) for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The contactinfo to deliver the one-time password (OTP) to.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string contactInfoLabel {
            get {
                return this.contactInfoLabelField;
            }
            set {
                this.contactInfoLabelField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userOTPDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserOTPDeleteCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to delete the one-time password (OTP) for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when creating or modifying a user's 
    ///   one-time password (OTP). All values can be null, indicating that the 
    ///   default is used for create or the value is not changed for modify. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserOTPParms {
        
        private System.Nullable<bool> forceField;
        
        private System.Nullable<long> lifetimeField;
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true for OTP create, indicates an existing OTP is replaced. 
    ///   Otherwise, an existing OTP results in an error. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> Force {
            get {
                return this.forceField;
            }
            set {
                this.forceField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The lifetime of the OTP in milliseconds. The value must be a 
    ///   non-negative integer. If set to 0, the OTP is valid until it is used. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<long> Lifetime {
            get {
                return this.lifetimeField;
            }
            set {
                this.lifetimeField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userOTPCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserOTPCreateCallParms {
        
        private string useridField;
        
        private UserOTPParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to create a one-time password (OTP) for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserOTPParms
    /// </datatype>
    /// <value>
    ///   The parameters for the new one-time password (OTP).
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserOTPParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userMachineSecretList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserMachineSecretListCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to list machine secret for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userMachineSecretSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserMachineSecretSetCallParms {
        
        private string useridField;
        
        private string machineNonceField;
        
        private MachineSecretParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to update the machine secret for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The machine secret to update.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string machineNonce {
            get {
                return this.machineNonceField;
            }
            set {
                this.machineNonceField = value;
            }
        }
        
    /// <datatype>
    ///   MachineSecretParms
    /// </datatype>
    /// <value>
    ///   The parameters controlling what is updated.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public MachineSecretParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters used when creating or modifying a machine 
    ///   secret. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class MachineSecretParms {
        
        private string machineLabelField;
        
        private string machineNonceField;
        
        private NameValue[] applicationDataField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The machine label. This value can be set during create or can be 
    ///   modified for an existing machine secret. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string machineLabel {
            get {
                return this.machineLabelField;
            }
            set {
                this.machineLabelField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The machine nonce. If not specified when creating a machine secret, 
    ///   IdentityGuard will generate a random value. This value can not be 
    ///   modified for an existing machine secret. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string machineNonce {
            get {
                return this.machineNonceField;
            }
            set {
                this.machineNonceField = value;
            }
        }
        
    /// <datatype>
    ///   NameValue[]
    /// </datatype>
    /// <value>
    ///   The application data. May be null or an empty array if the machine 
    ///   secret doesn't have any application data. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public NameValue[] applicationData {
            get {
                return this.applicationDataField;
            }
            set {
                this.applicationDataField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userMachineSecretGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserMachineSecretGetCallParms {
        
        private string useridField;
        
        private string machineNonceField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to get the machine secret for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The machine secret to get.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string machineNonce {
            get {
                return this.machineNonceField;
            }
            set {
                this.machineNonceField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userMachineSecretDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserMachineSecretDeleteCallParms {
        
        private string useridField;
        
        private string machineNonceField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to delete the machine secret for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The machine secret to delete.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string machineNonce {
            get {
                return this.machineNonceField;
            }
            set {
                this.machineNonceField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userMachineSecretCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserMachineSecretCreateCallParms {
        
        private string useridField;
        
        private MachineSecretParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID to create a machine secret for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   MachineSecretParms
    /// </datatype>
    /// <value>
    ///   The parameters for the new machine secret.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public MachineSecretParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userPINSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPINSetCallParms {
        
        private string useridField;
        
        private UserPINParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to update the PIN for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserPINParms
    /// </datatype>
    /// <value>
    ///   The parameters controlling what is updated.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserPINParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when creating or modifying a user PIN. 
    ///   All values can be null, indicating that the default is used for create 
    ///   or the value is not changed for modify. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPINParms {
        
        private System.Nullable<bool> forceField;
        
        private System.Nullable<long> lifetimeField;
        
        private System.Nullable<int> maxUsesField;
        
        private string commentField;
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true when creating a PIN, indicates an existing PIN is replaced. 
    ///   Otherwise, an existing PIN results in an error. This parameter is 
    ///   ignored by userPINSet. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> Force {
            get {
                return this.forceField;
            }
            set {
                this.forceField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The lifetime of the PIN in milliseconds. The value must be a 
    ///   non-negative integer. A value of 0 means the PIN has infinite lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<long> Lifetime {
            get {
                return this.lifetimeField;
            }
            set {
                this.lifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of times the PIN can be used. The value must be a 
    ///   non-negative integer. A value of 0 means that the PIN can be used an unlimited 
    ///   number of times. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> MaxUses {
            get {
                return this.maxUsesField;
            }
            set {
                this.maxUsesField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The PIN comment. If not specified when creating a new PIN, it defaults 
    ///   to empty string. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userPINGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPINGetCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to get the PIN for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userPINDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPINDeleteCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to delete the PIN for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userPINCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPINCreateCallParms {
        
        private string useridField;
        
        private UserPINParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID to create a PIN for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserPINParms
    /// </datatype>
    /// <value>
    ///   The parameters for the new PIN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserPINParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userContactInfoSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserContactInfoSetCallParms {
        
        private string useridField;
        
        private string labelField;
        
        private UserContactInfoParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to update the ContactInfo for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The label of the Contactinfo to be updated.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string label {
            get {
                return this.labelField;
            }
            set {
                this.labelField = value;
            }
        }
        
    /// <datatype>
    ///   UserContactInfoParms
    /// </datatype>
    /// <value>
    ///   The parameters controlling what is updated.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserContactInfoParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when creating or modifying a user 
    ///   contactinfo instance. All values can be null indicating that the default is 
    ///   used for create or the value is not changed for modify. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserContactInfoParms {
        
        private string contactInfoLabelField;
        
        private string valueField;
        
        private string deliveryConfigLabelField;
        
        private System.Nullable<bool> defaultContactInfoField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The label of the contact info to be created or modified.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string contactInfoLabel {
            get {
                return this.contactInfoLabelField;
            }
            set {
                this.contactInfoLabelField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The value of the user contact info.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The label of the delivery configuration that is associated with this 
    ///   user contact info. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string deliveryConfigLabel {
            get {
                return this.deliveryConfigLabelField;
            }
            set {
                this.deliveryConfigLabelField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this user contact info instance is default. The 
    ///   delivery configuration associated with this contact info is used for 
    ///   out-of-band data delivery when no contact info is specified for delivery. 
    ///   Defaults to false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> defaultContactInfo {
            get {
                return this.defaultContactInfoField;
            }
            set {
                this.defaultContactInfoField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userContactInfoGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserContactInfoGetCallParms {
        
        private string useridField;
        
        private string[] labelsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to get the ContactInfo for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The labels of user ContactInfo to be returned.
    ///   If not specified, all contact info are returned.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] labels {
            get {
                return this.labelsField;
            }
            set {
                this.labelsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userContactInfoDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserContactInfoDeleteCallParms {
        
        private string useridField;
        
        private string[] labelsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to delete the ContactInfo for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The labels of the ContactInfo to be deleted.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] labels {
            get {
                return this.labelsField;
            }
            set {
                this.labelsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userContactInfoCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserContactInfoCreateCallParms {
        
        private string useridField;
        
        private UserContactInfoParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID to create a ContactInfo for.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserContactInfoParms
    /// </datatype>
    /// <value>
    ///   The parameters for the new ContactInfo.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserContactInfoParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines information about an out-of-band delivery configuration. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class DeliveryConfigInfo {
        
        private DeliveryConfigType typeField;
        
        private string configLabelField;
        
        private string displayNameField;
        
    /// <datatype>
    ///   DeliveryConfigType
    /// </datatype>
    /// <value>
    ///   The type of this out-of-band delivery configuration.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public DeliveryConfigType type {
            get {
                return this.typeField;
            }
            set {
                this.typeField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The delivery configuration label, which is how particular 
    ///   configurations are identified when making calls to the admin service. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string configLabel {
            get {
                return this.configLabelField;
            }
            set {
                this.configLabelField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user-friendly display name.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string displayName {
            get {
                return this.displayNameField;
            }
            set {
                this.displayNameField = value;
            }
        }
    }
    
    /// <summary>
    ///   The type of the out-of-band delivery configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum DeliveryConfigType {
        
    /// <value>
    ///   A delivery configuration that will deliver information by making a 
    ///   telephone call. 
    /// </value>
        PHONE,
        
    /// <value>
    ///   A delivery configuration that will deliver information by e-mail. 
    /// </value>
        EMAIL,
        
    /// <value>
    ///   A delivery configuration that uses its own method of delivering 
    ///   information, not covered by any of the other types. 
    /// </value>
        OTHER,
    }
    
    /// <summary>
    ///   Defines a list of delivery configuration.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class DeliveryConfigInfoList {
        
        private DeliveryConfigInfo[] deliveryConfigInfoField;
        
    /// <datatype>
    ///   DeliveryConfigInfo[]
    /// </datatype>
    /// <value>
    ///   Information about delivery configuration.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public DeliveryConfigInfo[] deliveryConfigInfo {
            get {
                return this.deliveryConfigInfoField;
            }
            set {
                this.deliveryConfigInfoField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the data returned from the userList operation.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserListResult {
        
        private UserInfo[] usersField;
        
        private string nextUserField;
        
    /// <datatype>
    ///   UserInfo[]
    /// </datatype>
    /// <value>
    ///   The users returned.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public UserInfo[] users {
            get {
                return this.usersField;
            }
            set {
                this.usersField = value;
            }
        }
        
    /// <datatype>
    ///   integer
    /// </datatype>
    /// <value>
    ///   The nextUser number. If set to a non-zero value, indicates that 
    ///   additional users remain to be returned. 
    ///   This value can be included in the filter for a further search to 
    ///   continue the search at the next user. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer", IsNullable=true)]
        public string nextUser {
            get {
                return this.nextUserField;
            }
            set {
                this.nextUserField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines information returned about a user.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserInfo {
        
        private string useridField;
        
        private string userNameField;
        
        private string groupField;
        
        private string repositoryField;
        
        private ContactInfo[] contactInfoListField;
        
        private string[] aliasesField;
        
        private string fullNameField;
        
        private bool badDataField;
        
        private int failureCountField;
        
        private System.Nullable<System.DateTime> lockoutDateField;
        
        private SharedSecret[] sharedSecretsField;
        
        private NameValue[] qaSecretsField;
        
        private NameValue[] authenticationSecretsField;
        
        private MachineSecretInfo[] machineSecretsField;
        
        private UserPINInfo pINField;
        
        private UserOTPInfo oTPField;
        
        private bool oTPAllowedField;
        
        private bool usePolicyForOTPDeliveryEnabledField;
        
        private System.Nullable<bool> oTPDeliveryEnabledField;
        
        private UserPVNInfo pVNField;
        
        private UserPasswordInfo passwordField;
        
        private ActivationInfo activationInfoField;
        
        private UserCardInfo[] cardsField;
        
        private UserTokenInfo[] tokensField;
        
        private System.Nullable<UserState> userStateField;
        
        private string suspendReasonField;
        
        private string[] rolesField;
        
        private UserLocation[] userLocationsField;
        
        private bool usePolicyForMaxLocationHistorySizeField;
        
        private System.Nullable<int> maxLocationHistorySizeField;
        
        private bool usePolicyForCheckVelocityField;
        
        private System.Nullable<bool> checkVelocityField;
        
        private bool usePolicyForCheckIPAddressInLocationHistoryField;
        
        private System.Nullable<bool> checkIPAddressInLocationHistoryField;
        
        private bool usePolicyForExpectedLocationsField;
        
        private ExpectedLocation[] expectedLocationsField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID of the user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user name portion of the user ID.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string UserName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group of the user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the repository that the user's information is stored in. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Repository {
            get {
                return this.repositoryField;
            }
            set {
                this.repositoryField = value;
            }
        }
        
    /// <datatype>
    ///   ContactInfo[]
    /// </datatype>
    /// <value>
    ///   The user's contact information.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public ContactInfo[] ContactInfoList {
            get {
                return this.contactInfoListField;
            }
            set {
                this.contactInfoListField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The aliases of this user.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] Aliases {
            get {
                return this.aliasesField;
            }
            set {
                this.aliasesField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The full name of the user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string FullName {
            get {
                return this.fullNameField;
            }
            set {
                this.fullNameField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if the user data has integrity errors. In the case 
    ///   of an LDAP repository, an integrity error may indicate that the user's 
    ///   name has changed in the repository without having been changed in 
    ///   Entrust IdentityGuard. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool BadData {
            get {
                return this.badDataField;
            }
            set {
                this.badDataField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of failed authentications remaining before the user is 
    ///   locked out. A value of 0 indicates user is locked out. A negative value 
    ///   indicates the user will never be locked out due to failing 
    ///   authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int FailureCount {
            get {
                return this.failureCountField;
            }
            set {
                this.failureCountField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date on which the lockout will expire.
    ///   The value is only meaningful if the FailureCount is 0. A value of 
    ///   Date(0) means the lockout will not expire (i.e., it must be cleared by an 
    ///   administrator). 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> LockoutDate {
            get {
                return this.lockoutDateField;
            }
            set {
                this.lockoutDateField = value;
            }
        }
        
    /// <datatype>
    ///   SharedSecret[]
    /// </datatype>
    /// <value>
    ///   The user's shared secrets. May be null or an empty array if the user 
    ///   doesn't have any shared secrets. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public SharedSecret[] SharedSecrets {
            get {
                return this.sharedSecretsField;
            }
            set {
                this.sharedSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   NameValue[]
    /// </datatype>
    /// <value>
    ///   The user's QA authentication values. This attribute will have a null 
    ///   value if the administrator doesn't have QA authentication values or 
    ///   doesn't have the userGetQa permission. If the administrator doesn't 
    ///   have the userQaView permission, the answers will not be included in the 
    ///   returned value. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public NameValue[] QaSecrets {
            get {
                return this.qaSecretsField;
            }
            set {
                this.qaSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   NameValue[]
    /// </datatype>
    /// <value>
    ///   The user's mutual authentication secrets. May be null or an empty 
    ///   array if the user doesn't have any authentication secrets. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public NameValue[] AuthenticationSecrets {
            get {
                return this.authenticationSecretsField;
            }
            set {
                this.authenticationSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   MachineSecretInfo[]
    /// </datatype>
    /// <value>
    ///   The user's machine secrets. May be null or an empty array if the user 
    ///   doesn't have any machine secrets. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public MachineSecretInfo[] MachineSecrets {
            get {
                return this.machineSecretsField;
            }
            set {
                this.machineSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   UserPINInfo
    /// </datatype>
    /// <value>
    ///   The user's PIN. Null if the user doesn't have a PIN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public UserPINInfo PIN {
            get {
                return this.pINField;
            }
            set {
                this.pINField = value;
            }
        }
        
    /// <datatype>
    ///   UserOTPInfo
    /// </datatype>
    /// <value>
    ///   The user's one-time password (OTP). Null if the user doesn't have an 
    ///   OTP. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public UserOTPInfo OTP {
            get {
                return this.oTPField;
            }
            set {
                this.oTPField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if the user can use an OTP for authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool OTPAllowed {
            get {
                return this.oTPAllowedField;
            }
            set {
                this.oTPAllowedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, use the policy setting for OTPDeliveryEnabled. If false, 
    ///   OTPDeliveryEnabled indicates whether or not OTP delivery is allowed. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool usePolicyForOTPDeliveryEnabled {
            get {
                return this.usePolicyForOTPDeliveryEnabledField;
            }
            set {
                this.usePolicyForOTPDeliveryEnabledField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if the OTP can be delivered via an out-of-band 
    ///   delivery mechanism to this user. 
    ///   This value is ignored if usePolicyForOTPDeliveryEnabled is true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> OTPDeliveryEnabled {
            get {
                return this.oTPDeliveryEnabledField;
            }
            set {
                this.oTPDeliveryEnabledField = value;
            }
        }
        
    /// <datatype>
    ///   UserPVNInfo
    /// </datatype>
    /// <value>
    ///   The user's personal verification number (PVN).
    ///   Null if the user doesn't have a PVN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public UserPVNInfo PVN {
            get {
                return this.pVNField;
            }
            set {
                this.pVNField = value;
            }
        }
        
    /// <datatype>
    ///   UserPasswordInfo
    /// </datatype>
    /// <value>
    ///   The user's password.
    ///   Null if the user doesn't have a password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public UserPasswordInfo Password {
            get {
                return this.passwordField;
            }
            set {
                this.passwordField = value;
            }
        }
        
    /// <datatype>
    ///   ActivationInfo
    /// </datatype>
    /// <value>
    ///   The activation information for the user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public ActivationInfo ActivationInfo {
            get {
                return this.activationInfoField;
            }
            set {
                this.activationInfoField = value;
            }
        }
        
    /// <datatype>
    ///   UserCardInfo[]
    /// </datatype>
    /// <value>
    ///   The user's cards. May be null or an empty array if the user doesn't 
    ///   have any cards. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public UserCardInfo[] Cards {
            get {
                return this.cardsField;
            }
            set {
                this.cardsField = value;
            }
        }
        
    /// <datatype>
    ///   UserTokenInfo[]
    /// </datatype>
    /// <value>
    ///   The user's tokens. May be null or an empty array if the user doesn't 
    ///   have any tokens. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public UserTokenInfo[] Tokens {
            get {
                return this.tokensField;
            }
            set {
                this.tokensField = value;
            }
        }
        
    /// <datatype>
    ///   UserState
    /// </datatype>
    /// <value>
    ///   The user's state.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<UserState> UserState {
            get {
                return this.userStateField;
            }
            set {
                this.userStateField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The reason for the user's suspension, if the user's state is 
    ///   SUSPENDED. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string SuspendReason {
            get {
                return this.suspendReasonField;
            }
            set {
                this.suspendReasonField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of the roles assigned to this user.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] Roles {
            get {
                return this.rolesField;
            }
            set {
                this.rolesField = value;
            }
        }
        
    /// <datatype>
    ///   UserLocation[]
    /// </datatype>
    /// <value>
    ///   The list of locations that this user has authenticated from.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public UserLocation[] userLocations {
            get {
                return this.userLocationsField;
            }
            set {
                this.userLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, use the policy setting for maxLocationHistorySize. If false, 
    ///   maxLocationHistorySize indicates the maximum location history size. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool usePolicyForMaxLocationHistorySize {
            get {
                return this.usePolicyForMaxLocationHistorySizeField;
            }
            set {
                this.usePolicyForMaxLocationHistorySizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of the user location history list. This attribute 
    ///   will not be set if usePolicyForMaxLocationHistorySize is true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxLocationHistorySize {
            get {
                return this.maxLocationHistorySizeField;
            }
            set {
                this.maxLocationHistorySizeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, use the policy setting for checkVelocity. If false, 
    ///   checkVelocity indicates whether or not to perform the velocity check when 
    ///   authenticating an IP address. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool usePolicyForCheckVelocity {
            get {
                return this.usePolicyForCheckVelocityField;
            }
            set {
                this.usePolicyForCheckVelocityField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, perform the velocity check when authenticating an IP address. 
    ///   This attribute will not be set if usePolicyForCheckVelocity is true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> checkVelocity {
            get {
                return this.checkVelocityField;
            }
            set {
                this.checkVelocityField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, use the policy setting for checkIPAddressInLocationHistory. 
    ///   If false, checkIPAddressInLocationHistory indicates whether or not to 
    ///   check the IP address when comparing a location against the user's 
    ///   location history. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool usePolicyForCheckIPAddressInLocationHistory {
            get {
                return this.usePolicyForCheckIPAddressInLocationHistoryField;
            }
            set {
                this.usePolicyForCheckIPAddressInLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, check the IP address when comparing a location against the 
    ///   user's location history. This attribute will not be set if 
    ///   usePolicyForCheckIPAddressInLocationHistory is true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> checkIPAddressInLocationHistory {
            get {
                return this.checkIPAddressInLocationHistoryField;
            }
            set {
                this.checkIPAddressInLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, this user uses the expected locations settings defined in 
    ///   policy. Otherwise, the per-user expectedLocations setting is used. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool usePolicyForExpectedLocations {
            get {
                return this.usePolicyForExpectedLocationsField;
            }
            set {
                this.usePolicyForExpectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   ExpectedLocation[]
    /// </datatype>
    /// <value>
    ///   A list of locations the user can authenticate from. This value is 
    ///   ignored if usePolicyForExpectedLocations is true. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public ExpectedLocation[] expectedLocations {
            get {
                return this.expectedLocationsField;
            }
            set {
                this.expectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Optional descriptive comments about this user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comments {
            get {
                return this.commentsField;
            }
            set {
                this.commentsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the user contact information.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class ContactInfo {
        
        private string contactInfoLabelField;
        
        private string valueField;
        
        private string deliveryConfigLabelField;
        
        private bool defaultContactInfoField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user contact info label.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string contactInfoLabel {
            get {
                return this.contactInfoLabelField;
            }
            set {
                this.contactInfoLabelField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The value of the user contact info.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The label of the delivery configuration that is associated with this 
    ///   user contact info. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string deliveryConfigLabel {
            get {
                return this.deliveryConfigLabelField;
            }
            set {
                this.deliveryConfigLabelField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this user contact info instance is default. The 
    ///   delivery configuration associated with this contact info is used for 
    ///   out-of-band data delivery when no contact info is specified for delivery. 
    ///   Defaults to false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool defaultContactInfo {
            get {
                return this.defaultContactInfoField;
            }
            set {
                this.defaultContactInfoField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a shared secret. Shared secrets are name/value pairs that can 
    ///   be set and retrieved during user authentication. They can be used to 
    ///   allow an application to store details about a user that are only 
    ///   released after a user has successfully authenticated, possibly allowing 
    ///   the application to perform further authentication of the user. 
    ///   <p>
    ///   Shared secrets are not used by Entrust IdentityGuard for 
    ///   authentication purposes. 
    ///   </p>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:commonV3")]
    public partial class SharedSecret {
        
        private string nameField;
        
        private string valueField;
        
        private System.Nullable<bool> writeOnlyField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the shared secret. This name is unique for each user. 
    ///   <p>
    ///   Note that this value can be omitted, however, this is only to allow 
    ///   the server to treat it being missing as a non-fatal error (rather than 
    ///   a schema validation error). This value should always be specified. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The value of the shared secret.
    ///   <p>
    ///   Note that this value can be omitted, however, this is only to allow 
    ///   the server to treat it being missing as a non-fatal error (rather than 
    ///   a schema validation error). This value should always be specified. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, indicates that the client application can only write and 
    ///   remove the value but can not view it. In this case, only system 
    ///   administrators can view the secret. This value defaults to false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> WriteOnly {
            get {
                return this.writeOnlyField;
            }
            set {
                this.writeOnlyField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information stored as a machine secret.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class MachineSecretInfo {
        
        private string machineLabelField;
        
        private string machineNonceField;
        
        private string sequenceNonceField;
        
        private NameValue[] applicationDataField;
        
        private System.DateTime createDateField;
        
        private System.Nullable<System.DateTime> lastUsedDateField;
        
        private System.DateTime expiryDateField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The machine label.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string machineLabel {
            get {
                return this.machineLabelField;
            }
            set {
                this.machineLabelField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The machine nonce.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string machineNonce {
            get {
                return this.machineNonceField;
            }
            set {
                this.machineNonceField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The sequence nonce.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string sequenceNonce {
            get {
                return this.sequenceNonceField;
            }
            set {
                this.sequenceNonceField = value;
            }
        }
        
    /// <datatype>
    ///   NameValue[]
    /// </datatype>
    /// <value>
    ///   The application data. May be null or an empty array if the machine 
    ///   secret doesn't have any application data. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public NameValue[] applicationData {
            get {
                return this.applicationDataField;
            }
            set {
                this.applicationDataField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date the machine secret was created.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime CreateDate {
            get {
                return this.createDateField;
            }
            set {
                this.createDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date the machine secret was last used to authenticate.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> LastUsedDate {
            get {
                return this.lastUsedDateField;
            }
            set {
                this.lastUsedDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date after which this machine secret can not be used for 
    ///   authentication. 
    ///   A value of Date(0) means this machine secret can be used indefinitely. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime ExpiryDate {
            get {
                return this.expiryDateField;
            }
            set {
                this.expiryDateField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned when querying a user PIN.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPINInfo {
        
        private string useridField;
        
        private string userNameField;
        
        private string groupField;
        
        private int numUsesField;
        
        private System.DateTime createDateField;
        
        private System.Nullable<System.DateTime> expireDateField;
        
        private string[] pINField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID that owns the PIN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user name of the user ID that owns the PIN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string UserName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group of the user ID that owns the PIN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of uses remaining for the PIN. A value less than 0 
    ///   indicates infinite uses. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int NumUses {
            get {
                return this.numUsesField;
            }
            set {
                this.numUsesField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date the PIN was created.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime CreateDate {
            get {
                return this.createDateField;
            }
            set {
                this.createDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date the PIN will expire. A value of Date(0) indicates the PIN 
    ///   doesn't have an expiry date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> ExpireDate {
            get {
                return this.expireDateField;
            }
            set {
                this.expireDateField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The value of the PIN.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] PIN {
            get {
                return this.pINField;
            }
            set {
                this.pINField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The comment for the PIN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned when querying a user's one-time 
    ///   password (OTP). 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserOTPInfo {
        
        private string useridField;
        
        private string userNameField;
        
        private string groupField;
        
        private System.DateTime createDateField;
        
        private System.Nullable<System.DateTime> expireDateField;
        
        private string oTPField;
        
        private string[] rolesGrantingAccessField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID that owns the OTP.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user name of the user ID that owns the OTP.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string UserName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group of the user ID that owns the OTP.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date the OTP was created.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime CreateDate {
            get {
                return this.createDateField;
            }
            set {
                this.createDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date the OTP will expire. A value of Date(0) indicates the OTP 
    ///   doesn't have an expiry date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> ExpireDate {
            get {
                return this.expireDateField;
            }
            set {
                this.expireDateField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The value of one-time password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string OTP {
            get {
                return this.oTPField;
            }
            set {
                this.oTPField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned when querying a user's personal 
    ///   verification number (PVN). 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPVNInfo {
        
        private string useridField;
        
        private string userNameField;
        
        private string groupField;
        
        private string pVNField;
        
        private System.DateTime lastChangeDateField;
        
        private bool changeRequiredField;
        
        private string[] rolesGrantingAccessField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID that owns the PVN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user name of the user ID that owns the PVN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string UserName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group of the user ID that owns the PVN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The value of the personal verification number.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string PVN {
            get {
                return this.pVNField;
            }
            set {
                this.pVNField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date when the PVN was last changed.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime LastChangeDate {
            get {
                return this.lastChangeDateField;
            }
            set {
                this.lastChangeDateField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates if the personal verification number must be changed by the 
    ///   user. True means the user is required to change their PVN. False means 
    ///   it is optional for the user to change their PVN. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool ChangeRequired {
            get {
                return this.changeRequiredField;
            }
            set {
                this.changeRequiredField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned when querying a user Password. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserPasswordInfo {
        
        private string useridField;
        
        private string userNameField;
        
        private string groupField;
        
        private System.Nullable<PasswordStorage> passwordStorageField;
        
        private string retrievablePasswordField;
        
        private System.Nullable<System.DateTime> lastChangeDateField;
        
        private System.Nullable<System.DateTime> expireDateField;
        
        private System.Nullable<bool> changeRequiredField;
        
        private System.Nullable<int> historySizeField;
        
        private string[] rolesGrantingAccessField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID that owns the Password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user name of the user ID that owns the Password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string UserName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group of the user ID that owns the Password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   PasswordStorage
    /// </datatype>
    /// <value>
    ///   The method used to encode this password in the repository.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<PasswordStorage> PasswordStorage {
            get {
                return this.passwordStorageField;
            }
            set {
                this.passwordStorageField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The retrievable password returned if available and proper permissions 
    ///   granted to admin. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string RetrievablePassword {
            get {
                return this.retrievablePasswordField;
            }
            set {
                this.retrievablePasswordField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date the Password was last changed.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> LastChangeDate {
            get {
                return this.lastChangeDateField;
            }
            set {
                this.lastChangeDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date the Password will expire. A value of Date(0) indicates the 
    ///   Password doesn't have an expiry date. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> ExpireDate {
            get {
                return this.expireDateField;
            }
            set {
                this.expireDateField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates if a password change is required.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ChangeRequired {
            get {
                return this.changeRequiredField;
            }
            set {
                this.changeRequiredField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of password values stored in the history.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> HistorySize {
            get {
                return this.historySizeField;
            }
            set {
                this.historySizeField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned when querying user Activation state. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class ActivationInfo {
        
        private string useridField;
        
        private string userNameField;
        
        private string groupField;
        
        private System.Nullable<System.DateTime> expireDateField;
        
        private bool notSetField;
        
        private bool activatedField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user name.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string UserName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group of the user ID.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date the Activation period will expire.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> ExpireDate {
            get {
                return this.expireDateField;
            }
            set {
                this.expireDateField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates if the Activation expiry was not set.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool NotSet {
            get {
                return this.notSetField;
            }
            set {
                this.notSetField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates if the user is Activated.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool Activated {
            get {
                return this.activatedField;
            }
            set {
                this.activatedField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a user location.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserLocation {
        
        private bool privateAddressField;
        
        private string iPAddressField;
        
        private string countryField;
        
        private string countryNameField;
        
        private string regionField;
        
        private string regionNameField;
        
        private string cityField;
        
        private string iSPField;
        
        private System.Nullable<float> latitudeField;
        
        private System.Nullable<float> longitudeField;
        
        private System.DateTime lastAuthenticationField;
        
        private System.DateTime expiryDateField;
        
        private int numAuthenticationsField;
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the IP address is a private IP address as defined by RFC 
    ///   1918. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool privateAddress {
            get {
                return this.privateAddressField;
            }
            set {
                this.privateAddressField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The IP address of the location.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string IPAddress {
            get {
                return this.iPAddressField;
            }
            set {
                this.iPAddressField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The country code of the location.
    ///   Private IP addresses do not have a country.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string country {
            get {
                return this.countryField;
            }
            set {
                this.countryField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The country name of the location.
    ///   Private IP addresses do not have a country.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string countryName {
            get {
                return this.countryNameField;
            }
            set {
                this.countryNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The region code of the location.
    ///   Private IP addresses do not have a region.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string region {
            get {
                return this.regionField;
            }
            set {
                this.regionField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The region name of the location.
    ///   Private IP addresses do not have a region.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string regionName {
            get {
                return this.regionNameField;
            }
            set {
                this.regionNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The city of the location.
    ///   Private IP addresses do not have a city.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string city {
            get {
                return this.cityField;
            }
            set {
                this.cityField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The ISP of the location.
    ///   Private IP addresses do not have an ISP.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string ISP {
            get {
                return this.iSPField;
            }
            set {
                this.iSPField = value;
            }
        }
        
    /// <datatype>
    ///   float
    /// </datatype>
    /// <value>
    ///   The latitude of the location.
    ///   Private IP addresses do not have a latitude.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<float> latitude {
            get {
                return this.latitudeField;
            }
            set {
                this.latitudeField = value;
            }
        }
        
    /// <datatype>
    ///   float
    /// </datatype>
    /// <value>
    ///   The longitude of the location.
    ///   Private IP addresses do not have a longitude.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<float> longitude {
            get {
                return this.longitudeField;
            }
            set {
                this.longitudeField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The last time the user authenticated from this location.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime lastAuthentication {
            get {
                return this.lastAuthenticationField;
            }
            set {
                this.lastAuthenticationField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   After the expiry time, this location will no longer be considered when 
    ///   performing IP authentication. A value of Date(0) means this location 
    ///   does not expire. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime expiryDate {
            get {
                return this.expiryDateField;
            }
            set {
                this.expiryDateField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of times the user has authenticated from this location. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int numAuthentications {
            get {
                return this.numAuthenticationsField;
            }
            set {
                this.numAuthenticationsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines an expected location.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class ExpectedLocation {
        
        private bool privateAddressField;
        
        private string countryField;
        
        private string countryNameField;
        
        private string regionField;
        
        private string regionNameField;
        
        private string cityField;
        
        private string iSPField;
        
        private string iPAddressField;
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, this expected location is a private IP address as defined by 
    ///   RFC 1918. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool privateAddress {
            get {
                return this.privateAddressField;
            }
            set {
                this.privateAddressField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The optional country code of the location.
    ///   Private IP addresses do not have a country.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string country {
            get {
                return this.countryField;
            }
            set {
                this.countryField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The optional country name of the location.
    ///   This argument is ignored when creating or modifying an 
    ///   ExpectedLocation. 
    ///   Private IP addresses do not have a country.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string countryName {
            get {
                return this.countryNameField;
            }
            set {
                this.countryNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The optional region code of the location.
    ///   This argument is ignored when creating or modifying an 
    ///   ExpectedLocation. An expected location can only have a region code if it also has a 
    ///   country code. 
    ///   Private IP addresses do not have a region.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string region {
            get {
                return this.regionField;
            }
            set {
                this.regionField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The optional region name of the location.
    ///   An expected location can only have a region name if it also has a 
    ///   country code. 
    ///   Private IP addresses do not have a region.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string regionName {
            get {
                return this.regionNameField;
            }
            set {
                this.regionNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The optional city of the location.
    ///   Private IP addresses do not have a city.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string city {
            get {
                return this.cityField;
            }
            set {
                this.cityField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The optional ISP of the location.
    ///   Private IP addresses do not have an ISP.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string ISP {
            get {
                return this.iSPField;
            }
            set {
                this.iSPField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The optional IP Address of the location.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string IPAddress {
            get {
                return this.iPAddressField;
            }
            set {
                this.iPAddressField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserListCallParms {
        
        private UserFilter filterField;
        
        private UserGetParms parmsField;
        
    /// <datatype>
    ///   UserFilter
    /// </datatype>
    /// <value>
    ///   The search filter, specifying which users should be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
        
    /// <datatype>
    ///   UserGetParms
    /// </datatype>
    /// <value>
    ///   Parameters controlling what information is returned for each user. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public UserGetParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines information returned about a user.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserGetParms {
        
        private System.Nullable<bool> getCardsField;
        
        private System.Nullable<bool> getGridField;
        
        private System.Nullable<bool> getPINField;
        
        private System.Nullable<bool> getSharedSecretsField;
        
        private System.Nullable<bool> getOTPField;
        
        private System.Nullable<bool> getPVNField;
        
        private System.Nullable<bool> getPasswordField;
        
        private System.Nullable<bool> getTokensField;
        
        private System.Nullable<bool> getQASecretsField;
        
        private System.Nullable<bool> getAuthenticationSecretsField;
        
        private System.Nullable<bool> getMachineSecretsField;
        
        private System.Nullable<bool> getUserContactInfoField;
        
        private System.Nullable<bool> getExpectedLocationsField;
        
        private System.Nullable<bool> getLocationHistoryField;
        
        private System.Nullable<bool> getActivationExpiryInfoField;
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user cards. If not set, defaults to true.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getCards {
            get {
                return this.getCardsField;
            }
            set {
                this.getCardsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, and returning cards for the user, includes the card grid. If 
    ///   not set, defaults to false. 
    ///   Even if requested, the card grid will not be returned if the caller 
    ///   does not have permission to view grids. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getGrid {
            get {
                return this.getGridField;
            }
            set {
                this.getGridField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user PIN. If not set, defaults to true.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getPIN {
            get {
                return this.getPINField;
            }
            set {
                this.getPINField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user shared secrets. If not set, defaults to true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getSharedSecrets {
            get {
                return this.getSharedSecretsField;
            }
            set {
                this.getSharedSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user OTP. If not set, defaults to true.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getOTP {
            get {
                return this.getOTPField;
            }
            set {
                this.getOTPField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user PVN. If not set, defaults to true.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getPVN {
            get {
                return this.getPVNField;
            }
            set {
                this.getPVNField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user Password. If not set, defaults to true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getPassword {
            get {
                return this.getPasswordField;
            }
            set {
                this.getPasswordField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user tokens. If not set, defaults to false.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getTokens {
            get {
                return this.getTokensField;
            }
            set {
                this.getTokensField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user QA secrets. If not set, defaults to false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getQASecrets {
            get {
                return this.getQASecretsField;
            }
            set {
                this.getQASecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user authentication secrets. If not set, defaults to 
    ///   false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getAuthenticationSecrets {
            get {
                return this.getAuthenticationSecretsField;
            }
            set {
                this.getAuthenticationSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user machine secrets. If not set, defaults to false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getMachineSecrets {
            get {
                return this.getMachineSecretsField;
            }
            set {
                this.getMachineSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user contact info. If not set, defaults to false. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getUserContactInfo {
            get {
                return this.getUserContactInfoField;
            }
            set {
                this.getUserContactInfoField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user's expected locations.
    ///   If not set, defaults to false.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getExpectedLocations {
            get {
                return this.getExpectedLocationsField;
            }
            set {
                this.getExpectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user's location history.
    ///   If not set, defaults to false.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getLocationHistory {
            get {
                return this.getLocationHistoryField;
            }
            set {
                this.getLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, returns user's Activation information.
    ///   If not set, defaults to false.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> getActivationExpiryInfo {
            get {
                return this.getActivationExpiryInfoField;
            }
            set {
                this.getActivationExpiryInfoField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserSetCallParms {
        
        private string useridField;
        
        private UserParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID to update
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserParms
    /// </datatype>
    /// <value>
    ///   The updated values to set into the user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the parameters passed when creating or modifying a user. All 
    ///   values can be null indicating that the default is used when creating a 
    ///   user, or the value is not changed when modifying a user. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserParms {
        
        private string useridField;
        
        private string groupField;
        
        private string repositoryField;
        
        private System.Nullable<UserState> userStateField;
        
        private string suspendReasonField;
        
        private ContactInfo[] contactInfoListField;
        
        private string[] aliasesField;
        
        private System.Nullable<bool> addAliasesField;
        
        private string[] removeAliasesField;
        
        private string fullNameField;
        
        private System.Nullable<bool> clearlockoutField;
        
        private System.Nullable<bool> clearMachineSecretsField;
        
        private string[] removeMachineSecretsField;
        
        private SharedSecret[] sharedSecretsField;
        
        private System.Nullable<bool> mergeSecretsField;
        
        private string[] removeSharedSecretsField;
        
        private System.Nullable<bool> removeAllSecretsField;
        
        private NameValue[] qaSecretsField;
        
        private System.Nullable<bool> mergeQaSecretsField;
        
        private string[] removeQaSecretsField;
        
        private System.Nullable<bool> removeAllQaSecretsField;
        
        private NameValue[] authenticationSecretsField;
        
        private System.Nullable<bool> mergeAuthenticationSecretsField;
        
        private string[] removeAuthenticationSecretsField;
        
        private System.Nullable<bool> removeAllAuthenticationSecretsField;
        
        private string[] rolesField;
        
        private System.Nullable<bool> mergeRolesField;
        
        private string[] removeRolesField;
        
        private System.Nullable<bool> oTPAllowedField;
        
        private System.Nullable<bool> usePolicyForOTPDeliveryEnabledField;
        
        private System.Nullable<bool> oTPDeliveryEnabledField;
        
        private System.Nullable<bool> usePolicyForMaxLocationHistorySizeField;
        
        private System.Nullable<int> maxLocationHistorySizeField;
        
        private System.Nullable<bool> removeAllLocationHistoryField;
        
        private string[] removeLocationHistoryField;
        
        private string[] addLocationHistoryField;
        
        private System.Nullable<bool> usePolicyForCheckVelocityField;
        
        private System.Nullable<bool> checkVelocityField;
        
        private System.Nullable<bool> usePolicyForCheckIPAddressInLocationHistoryField;
        
        private System.Nullable<bool> checkIPAddressInLocationHistoryField;
        
        private System.Nullable<bool> usePolicyForExpectedLocationsField;
        
        private ExpectedLocation[] expectedLocationsField;
        
        private System.Nullable<bool> addExpectedLocationsField;
        
        private System.Nullable<bool> removeExpectedLocationsField;
        
        private System.Nullable<ActivationExpiryCode> activationExpiryCodeField;
        
        private System.Nullable<int> activationDaysToExpiryField;
        
        private string commentsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   This parameter only applies to the modify operation, and is ignored by 
    ///   other operations. This value is the old value of a user ID and 
    ///   indicates that the user ID is to be modified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group of the user. When creating a user, if the user ID includes 
    ///   the group, then this value must be null or match the group in the user 
    ///   ID. 
    ///   During creation, if the group is not specified in the user ID nor in 
    ///   this value, then the user is created in the group flagged as the 
    ///   default. 
    ///   When modifying a user, this value can change the group to which the 
    ///   user belongs. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Group {
            get {
                return this.groupField;
            }
            set {
                this.groupField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the repository that the user's information is to be stored 
    ///   in. If specified, this must be one of the repositories in the list 
    ///   of repositories assigned to the user's group. 
    ///   When modifying a user, this value can change the repository in which 
    ///   the user's data is stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Repository {
            get {
                return this.repositoryField;
            }
            set {
                this.repositoryField = value;
            }
        }
        
    /// <datatype>
    ///   UserState
    /// </datatype>
    /// <value>
    ///   The user's state.
    ///   The default during user creation is ACTIVE.
    ///   When modifying a user, if this is ACTIVE, the SuspendReason is 
    ///   cleared. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<UserState> UserState {
            get {
                return this.userStateField;
            }
            set {
                this.userStateField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   A free-format string indicating the reason for a user suspension. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string SuspendReason {
            get {
                return this.suspendReasonField;
            }
            set {
                this.suspendReasonField = value;
            }
        }
        
    /// <datatype>
    ///   ContactInfo[]
    /// </datatype>
    /// <value>
    ///   The user's contact information.
    ///   If specified when modifying a user, the user's contact information 
    ///   list will be replaced by the list in this parameter. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public ContactInfo[] ContactInfoList {
            get {
                return this.contactInfoListField;
            }
            set {
                this.contactInfoListField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The user's aliases.
    ///   If specified during a userSet operation and addAliases is false or 
    ///   null, then the user's existing aliases are replaced by this list. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] Aliases {
            get {
                return this.aliasesField;
            }
            set {
                this.aliasesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the aliases listed in the Aliases attribute are merged with 
    ///   the existing values instead of replacing the existing values. If not 
    ///   specified, this value defaults to false. This parameter only applies 
    ///   to the user set operation, and is ignored by other operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> addAliases {
            get {
                return this.addAliasesField;
            }
            set {
                this.addAliasesField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   A list of aliases to remove from the user. This list is applied after 
    ///   new aliases are added. This parameter only applies to the user set 
    ///   operation, and is ignored by other operations. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] removeAliases {
            get {
                return this.removeAliasesField;
            }
            set {
                this.removeAliasesField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The full name of the user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string FullName {
            get {
                return this.fullNameField;
            }
            set {
                this.fullNameField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, clear the lockout of the user. If not specified, this 
    ///   value defaults to false. This parameter only applies to the user set 
    ///   operation, and is ignored by other operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> Clearlockout {
            get {
                return this.clearlockoutField;
            }
            set {
                this.clearlockoutField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, clears the machine secrets of the user.
    ///   If not specified, this value defaults to false.
    ///   This parameter only applies to the user set operation, and is ignored 
    ///   by other operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ClearMachineSecrets {
            get {
                return this.clearMachineSecretsField;
            }
            set {
                this.clearMachineSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If clearMachineSecrets is not set or set to false this attribute can 
    ///   define a list of machine secret nonces that will be removed from the 
    ///   user. All listed nonces must exist for the user or an error will be 
    ///   returned. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] removeMachineSecrets {
            get {
                return this.removeMachineSecretsField;
            }
            set {
                this.removeMachineSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   SharedSecret[]
    /// </datatype>
    /// <value>
    ///   A list of shared secrets to assign to the user.
    ///   If specified during a userSet operation and MergeSecrets is false or 
    ///   null, then the user's existing shared secrets are replaced by this 
    ///   list. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public SharedSecret[] SharedSecrets {
            get {
                return this.sharedSecretsField;
            }
            set {
                this.sharedSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, the SharedSecrets list is merged with the existing 
    ///   values. If not specified, this value defaults to false. This parameter 
    ///   only applies to the user set operation, and is ignored by other 
    ///   operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> MergeSecrets {
            get {
                return this.mergeSecretsField;
            }
            set {
                this.mergeSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   A list of shared secret names to be removed.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RemoveSharedSecrets {
            get {
                return this.removeSharedSecretsField;
            }
            set {
                this.removeSharedSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, remove all shared secrets. If specified, this value 
    ///   takes precedence over RemoveSharedSecrets. If not specified it defaults 
    ///   to false. This parameter only applies to the user set operation, and 
    ///   is ignored by other operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> RemoveAllSecrets {
            get {
                return this.removeAllSecretsField;
            }
            set {
                this.removeAllSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   NameValue[]
    /// </datatype>
    /// <value>
    ///   Question and answer pairs that will be used for QA authentication. 
    ///   If specified during a userSet operation and MergeQaSecrets is false or 
    ///   null, then the user's existing question and answer pairs are 
    ///   replaced by this list. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public NameValue[] QaSecrets {
            get {
                return this.qaSecretsField;
            }
            set {
                this.qaSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, the QaSecrets list is merged with the existing values. 
    ///   If not specified, this value defaults to false. This parameter only 
    ///   applies to the user set operation, and is ignored by other 
    ///   operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> MergeQaSecrets {
            get {
                return this.mergeQaSecretsField;
            }
            set {
                this.mergeQaSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   A list of questions to remove from the list of question and answer 
    ///   pairs. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RemoveQaSecrets {
            get {
                return this.removeQaSecretsField;
            }
            set {
                this.removeQaSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, remove all QA secrets. If specified, this value takes 
    ///   precedence over RemoveQaSecrets. If not specified it defaults to 
    ///   false. This parameter only applies to the user set operation, and is 
    ///   ignored by other operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> RemoveAllQaSecrets {
            get {
                return this.removeAllQaSecretsField;
            }
            set {
                this.removeAllQaSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   NameValue[]
    /// </datatype>
    /// <value>
    ///   Secrets to use to allow an application to authenticate itself to the 
    ///   user. 
    ///   If specified during a userSet operation and MergeAuthenticationSecrets 
    ///   is false or null, then the user's existing mutual authentication 
    ///   secrets are replaced by this list. 
    ///   <p>
    ///   Note that it is up to the application to perform any encoding required 
    ///   so that the mutual authentication secrets can be stored as a string. 
    ///   For example, if the secret is a JPEG image then this image must be 
    ///   encoded as a string before being set here, and the calling application 
    ///   must know how to convert such a string back to the original JPEG 
    ///   image. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public NameValue[] AuthenticationSecrets {
            get {
                return this.authenticationSecretsField;
            }
            set {
                this.authenticationSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, the AuthenticationSecrets list is merged with the 
    ///   existing values. If not specified, this value defaults to false. This 
    ///   parameter only applies to the user set operation, and is ignored by 
    ///   other operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> MergeAuthenticationSecrets {
            get {
                return this.mergeAuthenticationSecretsField;
            }
            set {
                this.mergeAuthenticationSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   A list of authentication secret names to be removed.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RemoveAuthenticationSecrets {
            get {
                return this.removeAuthenticationSecretsField;
            }
            set {
                this.removeAuthenticationSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, removes all authentication secrets.
    ///   If specified, this value takes precedence over 
    ///   RemoveAuthenticationSecrets. If not specified it defaults to false. This parameter only 
    ///   applies to the user set operation, and is ignored by other operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> RemoveAllAuthenticationSecrets {
            get {
                return this.removeAllAuthenticationSecretsField;
            }
            set {
                this.removeAllAuthenticationSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of the roles assigned to this user.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] Roles {
            get {
                return this.rolesField;
            }
            set {
                this.rolesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, the Roles list is merged with the existing values. If 
    ///   not specified, this value defaults to false. This parameter only 
    ///   applies to the user set operation, and is ignored by other operations. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> MergeRoles {
            get {
                return this.mergeRolesField;
            }
            set {
                this.mergeRolesField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   A list of roles names to be removed from the user's list of roles. If 
    ///   both MergeRoles is true and this list is non-empty, then this list of 
    ///   roles is removed first, then the other roles specified are merged. 
    ///   It is an error to remove a role that is not already assigned to the 
    ///   user. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] RemoveRoles {
            get {
                return this.removeRolesField;
            }
            set {
                this.removeRolesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Set the flag indicating if the user is allowed to use a one-time 
    ///   password (OTP) for authentication. 
    ///   If not specified at user creation time, defaults to true.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> OTPAllowed {
            get {
                return this.oTPAllowedField;
            }
            set {
                this.oTPAllowedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, use the policy setting for OTPDeliveryEnabled.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> usePolicyForOTPDeliveryEnabled {
            get {
                return this.usePolicyForOTPDeliveryEnabledField;
            }
            set {
                this.usePolicyForOTPDeliveryEnabledField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if the OTP can be delivered via out-of-band delivery 
    ///   mechanism to this user. 
    ///   This value is ignored if usePolicyForOTPDeliveryEnabled is true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> OTPDeliveryEnabled {
            get {
                return this.oTPDeliveryEnabledField;
            }
            set {
                this.oTPDeliveryEnabledField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, use the policy for maxLocationHistorySize.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> usePolicyForMaxLocationHistorySize {
            get {
                return this.usePolicyForMaxLocationHistorySizeField;
            }
            set {
                this.usePolicyForMaxLocationHistorySizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of the user location history list. This attribute can 
    ///   not be set if usePolicyForMaxLocationHistorySize is set to true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxLocationHistorySize {
            get {
                return this.maxLocationHistorySizeField;
            }
            set {
                this.maxLocationHistorySizeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, remove all entries from the user's location history list. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> removeAllLocationHistory {
            get {
                return this.removeAllLocationHistoryField;
            }
            set {
                this.removeAllLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   A list of IP addresses of locations to be removed from the user's 
    ///   location history list. 
    ///   This setting is ignored if removeAllLocationHistory is true.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] removeLocationHistory {
            get {
                return this.removeLocationHistoryField;
            }
            set {
                this.removeLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   A list of IP addresses of locations to be added from the user's 
    ///   location history list. 
    ///   This setting is applied after the removeAllLocationHistory or 
    ///   removeLocationHistory arguments. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] addLocationHistory {
            get {
                return this.addLocationHistoryField;
            }
            set {
                this.addLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, use the policy for checkVelocity.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> usePolicyForCheckVelocity {
            get {
                return this.usePolicyForCheckVelocityField;
            }
            set {
                this.usePolicyForCheckVelocityField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the velocity check is performed when authenticating an IP 
    ///   address. 
    ///   This attribute can not be set if usePolicyForCheckVelocity is set to 
    ///   true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> checkVelocity {
            get {
                return this.checkVelocityField;
            }
            set {
                this.checkVelocityField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If set to true, use the policy for checkIPAddressInLocationHistory. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> usePolicyForCheckIPAddressInLocationHistory {
            get {
                return this.usePolicyForCheckIPAddressInLocationHistoryField;
            }
            set {
                this.usePolicyForCheckIPAddressInLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the IP address is compared when comparing a location against 
    ///   a user's location history. 
    ///   This attribute can not be set if 
    ///   usePolicyForCheckIPAddressInLocationHistory is set to true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> checkIPAddressInLocationHistory {
            get {
                return this.checkIPAddressInLocationHistoryField;
            }
            set {
                this.checkIPAddressInLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the expected location settings in policy are used instead of 
    ///   the per user settings. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> usePolicyForExpectedLocations {
            get {
                return this.usePolicyForExpectedLocationsField;
            }
            set {
                this.usePolicyForExpectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   ExpectedLocation[]
    /// </datatype>
    /// <value>
    ///   The expected locations list is a list of locations that users are 
    ///   expected to authenticate from. Users authenticated from an expected 
    ///   location may require less authentication. 
    ///   <p>
    ///   This attribute is ignored if the usePolicyForExpectedLocations is set 
    ///   to true. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public ExpectedLocation[] expectedLocations {
            get {
                return this.expectedLocationsField;
            }
            set {
                this.expectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   The expected locations list is a list of locations that users are 
    ///   expected to authenticate from. Users authenticated from an expected 
    ///   location may require less authentication. 
    ///   <p>
    ///   If this attribute is set to true, the locations in the 
    ///   expectedLocations attribute will be added to the current value. This attribute will 
    ///   be ignored if the expectedLocation attribute is not set. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> addExpectedLocations {
            get {
                return this.addExpectedLocationsField;
            }
            set {
                this.addExpectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   The expected locations list is a list of locations that users are 
    ///   expected to authenticate from. Users authenticated from an expected 
    ///   location may require less authentication. 
    ///   <p>
    ///   If this attribute is set, the locations in the expectedLocations 
    ///   attribute will be removed from the current value. This attribute is 
    ///   ignored if the expectedLocations attribute is not set or the 
    ///   addExpectedLocations attribute is set. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> removeExpectedLocations {
            get {
                return this.removeExpectedLocationsField;
            }
            set {
                this.removeExpectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   ActivationExpiryCode
    /// </datatype>
    /// <value>
    ///   The code for setting the user Activation Expiry.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<ActivationExpiryCode> ActivationExpiryCode {
            get {
                return this.activationExpiryCodeField;
            }
            set {
                this.activationExpiryCodeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of days until the Activation period expiry.
    ///   This parameter must be null unless the ActivationExpiryCode is set to 
    ///   NUMDAYS. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> ActivationDaysToExpiry {
            get {
                return this.activationDaysToExpiryField;
            }
            set {
                this.activationDaysToExpiryField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Optional descriptive comments about this user.
    ///   Defaults to an empty string if not specified during user creation. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string Comments {
            get {
                return this.commentsField;
            }
            set {
                this.commentsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the choices for setting the activation expiry of a user. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum ActivationExpiryCode {
        
    /// <value>
    ///   No activation expiry date has been set.
    /// </value>
        NOTSET,
        
    /// <value>
    ///   The user has successfully activated. This state cannot be used when 
    ///   creating a new user. When modifying user information, this state can 
    ///   only be used when the user has an active card or token. 
    /// </value>
        ACTIVATED,
        
    /// <value>
    ///   Use the activation expiry values configured in the policy.
    /// </value>
        USEPOLICY,
        
    /// <value>
    ///   Set an explicit number of days until the activation period expires. 
    /// </value>
        NUMDAYS,
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userGetOriginalId. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserGetOriginalIdCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID to query.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserGetCallParms {
        
        private string useridField;
        
        private UserGetParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID to query.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserGetParms
    /// </datatype>
    /// <value>
    ///   Parameters controlling what information is returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public UserGetParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserDeleteCallParms {
        
        private string useridField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user to delete.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to userCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserCreateCallParms {
        
        private string useridField;
        
        private UserParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user ID of the user to create
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string userid {
            get {
                return this.useridField;
            }
            set {
                this.useridField = value;
            }
        }
        
    /// <datatype>
    ///   UserParms
    /// </datatype>
    /// <value>
    ///   The parameters for the new user.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a list of RepositoryInfo.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RepositoryInfoList {
        
        private RepositoryInfo[] repositoryInfoField;
        
    /// <datatype>
    ///   RepositoryInfo[]
    /// </datatype>
    /// <value>
    ///   Information about repositories.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public RepositoryInfo[] repositoryInfo {
            get {
                return this.repositoryInfoField;
            }
            set {
                this.repositoryInfoField = value;
            }
        }
    }
    
    /// <summary>
    ///   Information about a repository where Entrust IdentityGuard will store 
    ///   data. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RepositoryInfo {
        
        private string nameField;
        
        private RepositoryType typeField;
        
        private bool defaultRepositoryField;
        
        private bool canAssignToGroupField;
        
        private string descriptionField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the repository.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   RepositoryType
    /// </datatype>
    /// <value>
    ///   The type of the repository.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public RepositoryType type {
            get {
                return this.typeField;
            }
            set {
                this.typeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this repository is the default repository used to 
    ///   store user information. This is used when creating a new group and no 
    ///   repositories are specifically assigned to the group. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool defaultRepository {
            get {
                return this.defaultRepositoryField;
            }
            set {
                this.defaultRepositoryField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this repository can be assigned to a group's list of 
    ///   repositories. 
    ///   This flag may be false in the case of file-based repositories used to 
    ///   store pre-produced cards. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool canAssignToGroup {
            get {
                return this.canAssignToGroupField;
            }
            set {
                this.canAssignToGroupField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   A description of the repository.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines possible types for repositories.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum RepositoryType {
        
    /// <value>
    ///   The repository is a Directory that is accessed by LDAP.
    /// </value>
        LDAP,
        
    /// <value>
    ///   The repository is a database that is accessed using a Java Database 
    ///   (JDBC) driver. 
    /// </value>
        DATABASE,
        
    /// <value>
    ///   The repository is a file stored on the Entrust IdentityGuard server. 
    /// </value>
        FILE,
        
    /// <value>
    ///   The repository is a type that does not fit any of the other 
    ///   classifications. 
    /// </value>
        OTHER,
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   repositoryGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RepositoryGetCallParms {
        
        private string repositoryNameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the repository to retrieve. If nil, then information about 
    ///   the default user repository is retrieved.. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string repositoryName {
            get {
                return this.repositoryNameField;
            }
            set {
                this.repositoryNameField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a list of GroupInfo.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GroupInfoList {
        
        private GroupInfo[] groupInfoField;
        
    /// <datatype>
    ///   GroupInfo[]
    /// </datatype>
    /// <value>
    ///   Information about a group.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public GroupInfo[] groupInfo {
            get {
                return this.groupInfoField;
            }
            set {
                this.groupInfoField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines information about a group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GroupInfo {
        
        private string nameField;
        
        private bool defaultGroupField;
        
        private string policyField;
        
        private string[] repositoryField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the group.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this group is the default, and is used in situations 
    ///   where no group is specified but a group is required, such as user 
    ///   creation. If false, this is not the default group. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool defaultGroup {
            get {
                return this.defaultGroupField;
            }
            set {
                this.defaultGroupField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the policy associated with the group.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string policy {
            get {
                return this.policyField;
            }
            set {
                this.policyField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The names of the repositories that users in this group may be stored 
    ///   in. If this value is nil, it means that users in this group will be 
    ///   stored in the repository flagged as the default. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] repository {
            get {
                return this.repositoryField;
            }
            set {
                this.repositoryField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] rolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Optional descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the filter to limit which groups are to be returned from the 
    ///   groupList operation. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GroupFilter {
        
        private string[] policiesField;
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If specified, provides a list of policy names and returns only groups 
    ///   using those policies. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] policies {
            get {
                return this.policiesField;
            }
            set {
                this.policiesField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to groupList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GroupListCallParms {
        
        private GroupFilter filterField;
        
    /// <datatype>
    ///   GroupFilter
    /// </datatype>
    /// <value>
    ///   A filter limiting which groups are returned.
    ///   If nil, all groups are returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public GroupFilter filter {
            get {
                return this.filterField;
            }
            set {
                this.filterField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to groupSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GroupSetCallParms {
        
        private string groupNameField;
        
        private GroupParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the group to update.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string groupName {
            get {
                return this.groupNameField;
            }
            set {
                this.groupNameField = value;
            }
        }
        
    /// <datatype>
    ///   GroupParms
    /// </datatype>
    /// <value>
    ///   Parameters controlling the modification of the group.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public GroupParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the group.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GroupParms {
        
        private string nameField;
        
        private System.Nullable<bool> defaultGroupField;
        
        private string policyField;
        
        private string[] repositoriesField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   When passed in a call to groupSet, this specifies a new name for the 
    ///   group. If this is included in a call to groupCreate it is ignored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this group is the default, and is used in situations 
    ///   where no group is specified. If false, this is not the default 
    ///   group. There must always be exactly one group flagged as being the 
    ///   default. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> defaultGroup {
            get {
                return this.defaultGroupField;
            }
            set {
                this.defaultGroupField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the policy associated with the group.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string policy {
            get {
                return this.policyField;
            }
            set {
                this.policyField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The names of the repositories that users in this group may be stored 
    ///   in. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] repositories {
            get {
                return this.repositoriesField;
            }
            set {
                this.repositoriesField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Optional descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to groupGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GroupGetCallParms {
        
        private string groupNameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the group list to retrieve. If null, it indicates the 
    ///   default group should be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string groupName {
            get {
                return this.groupNameField;
            }
            set {
                this.groupNameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   groupDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GroupDeleteCallParms {
        
        private string groupNameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the group to delete.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string groupName {
            get {
                return this.groupNameField;
            }
            set {
                this.groupNameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   groupCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class GroupCreateCallParms {
        
        private string groupNameField;
        
        private GroupParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the group to create.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string groupName {
            get {
                return this.groupNameField;
            }
            set {
                this.groupNameField = value;
            }
        }
        
    /// <datatype>
    ///   GroupParms
    /// </datatype>
    /// <value>
    ///   Parameters controlling the creation of the group.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public GroupParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the filter to limit which roles are to be returned from the 
    ///   roleList operation. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RoleFilter {
        
        private System.Nullable<bool> systemRoleField;
        
        private string[] permissionsField;
        
        private System.Nullable<bool> allPermissionsField;
        
        private string[] policiesField;
        
        private System.Nullable<bool> allPoliciesField;
        
        private string[] groupsField;
        
        private System.Nullable<bool> allGroupsField;
        
        private System.Nullable<bool> ownGroupField;
        
        private string[] rolesField;
        
        private System.Nullable<bool> allRolesField;
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, only the built-in system roles will be returned. If false, 
    ///   only roles that have been created since the system was installed will 
    ///   be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> systemRole {
            get {
                return this.systemRoleField;
            }
            set {
                this.systemRoleField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If specified, provides a list of permission names and returns only 
    ///   roles where one of these names is explicitly included in the role's 
    ///   permission list. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] permissions {
            get {
                return this.permissionsField;
            }
            set {
                this.permissionsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, only roles where the permission list is the special "all" 
    ///   list will be returned. If false, only roles where the permission list is 
    ///   not the special "all" list will be returned. 
    ///   Specifying both a non-empty list for permissions and setting this 
    ///   value to true is invalid and will result in no roles being returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allPermissions {
            get {
                return this.allPermissionsField;
            }
            set {
                this.allPermissionsField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If specified, provides a list of policy names and returns only roles 
    ///   where one of these names is explicitly included in the role's policy 
    ///   list. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] policies {
            get {
                return this.policiesField;
            }
            set {
                this.policiesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, only roles where the policy list is the special "all" list 
    ///   will be returned. If false, only roles where the policy list is not the 
    ///   special "all" list will be returned. 
    ///   Specifying both a non-empty list for policies and setting this value 
    ///   to true is invalid and will result in no roles being returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allPolicies {
            get {
                return this.allPoliciesField;
            }
            set {
                this.allPoliciesField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If specified, provides a list of group names and returns only roles 
    ///   where one of these names is explicitly included in the role's group 
    ///   list. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] groups {
            get {
                return this.groupsField;
            }
            set {
                this.groupsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, only roles where the group list is the special "all" list 
    ///   will be returned. If false, only roles where the group list is not the 
    ///   special "all" list will be returned. 
    ///   Specifying both a non-empty list for groups and setting this value to 
    ///   true is invalid and will result in no roles being returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allGroups {
            get {
                return this.allGroupsField;
            }
            set {
                this.allGroupsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, only roles where the group list is the special "own" list 
    ///   will be returned. If false, only roles where the group list is not the 
    ///   special "own" list will be returned. 
    ///   Specifying both a non-empty list for groups and setting this value to 
    ///   true is invalid and will result in no roles being returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ownGroup {
            get {
                return this.ownGroupField;
            }
            set {
                this.ownGroupField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   If specified, provides a list of role names and returns only roles 
    ///   where one of these names is explicitly included in the role's role list. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] roles {
            get {
                return this.rolesField;
            }
            set {
                this.rolesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, only roles where the role list is the special "all" list will 
    ///   be returned. If false, only roles where the role list is not the 
    ///   special "all" list will be returned. 
    ///   Specifying both a non-empty list for roles and setting this value to 
    ///   true is invalid and will result in no roles being returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allRoles {
            get {
                return this.allRolesField;
            }
            set {
                this.allRolesField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to roleList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RoleListCallParms {
        
        private RoleFilter parmsField;
        
    /// <datatype>
    ///   RoleFilter
    /// </datatype>
    /// <value>
    ///   Parameters controlling which role to retrieve.
    ///   If nil, then all roles are retrieved.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public RoleFilter parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to roleGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RoleSetCallParms {
        
        private string roleNameField;
        
        private RoleParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the role to modify.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string roleName {
            get {
                return this.roleNameField;
            }
            set {
                this.roleNameField = value;
            }
        }
        
    /// <datatype>
    ///   RoleParms
    /// </datatype>
    /// <value>
    ///   Parameters controlling the modification of the role.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public RoleParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines information about a role when creating or modifying a role. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RoleParms {
        
        private string nameField;
        
        private System.Nullable<bool> allPermissionsField;
        
        private string[] permissionsField;
        
        private System.Nullable<bool> allPoliciesField;
        
        private string[] policyListField;
        
        private System.Nullable<bool> allGroupsField;
        
        private System.Nullable<bool> ownGroupField;
        
        private string[] groupListField;
        
        private System.Nullable<bool> allRolesField;
        
        private string[] roleListField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   When specified in a call to roleSet, this is the new name for the 
    ///   role. It is ignored if specified in a call to roleCreate. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this role grants all permissions.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allPermissions {
            get {
                return this.allPermissionsField;
            }
            set {
                this.allPermissionsField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of the permissions that this role grants. If 
    ///   allPermissions is true, this list must be empty or nil. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] permissions {
            get {
                return this.permissionsField;
            }
            set {
                this.permissionsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this role grants access to all policies.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allPolicies {
            get {
                return this.allPoliciesField;
            }
            set {
                this.allPoliciesField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of policies that this role grants access to. If 
    ///   allPolicies is true, this list must be empty or nil. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] policyList {
            get {
                return this.policyListField;
            }
            set {
                this.policyListField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this role grants access to all groups.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allGroups {
            get {
                return this.allGroupsField;
            }
            set {
                this.allGroupsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, when assigned to an administrator, this role grants access to 
    ///   users who belong to the same group as the administrator. At most one 
    ///   of allGroups and ownGroup can be true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ownGroup {
            get {
                return this.ownGroupField;
            }
            set {
                this.ownGroupField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of the groups that this role grants access to. 
    ///   If either allGroups or ownGroup is true, this list must be empty or 
    ///   nil. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] groupList {
            get {
                return this.groupListField;
            }
            set {
                this.groupListField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this role grants access to all roles.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allRoles {
            get {
                return this.allRolesField;
            }
            set {
                this.allRolesField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of the roles that this role grants access to. If 
    ///   allRoles is true, this list must be empty or nil. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] roleList {
            get {
                return this.roleListField;
            }
            set {
                this.roleListField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Descriptive comments about this role, that could be used to provide a 
    ///   full description of this role's intended purpose. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to roleGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RoleGetCallParms {
        
        private string roleNameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the role to retrieve.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string roleName {
            get {
                return this.roleNameField;
            }
            set {
                this.roleNameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to roleDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RoleDeleteCallParms {
        
        private string roleNameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the role to delete.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string roleName {
            get {
                return this.roleNameField;
            }
            set {
                this.roleNameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to roleCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RoleCreateCallParms {
        
        private string roleNameField;
        
        private RoleParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the role to create.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string roleName {
            get {
                return this.roleNameField;
            }
            set {
                this.roleNameField = value;
            }
        }
        
    /// <datatype>
    ///   RoleParms
    /// </datatype>
    /// <value>
    ///   Parameters controlling the creation of the role.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public RoleParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines information about a role.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RoleInfo {
        
        private string nameField;
        
        private bool systemRoleField;
        
        private bool allPermissionsField;
        
        private string[] permissionsField;
        
        private bool allPoliciesField;
        
        private string[] policyListField;
        
        private bool allGroupsField;
        
        private bool ownGroupField;
        
        private string[] groupListField;
        
        private bool allRolesField;
        
        private string[] roleListField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the role.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this role is a built-in system role, or one that 
    ///   was created after the system was installed. The built-in system roles 
    ///   cannot be modified with roleSet, nor can they be deleted with 
    ///   roleDelete. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool systemRole {
            get {
                return this.systemRoleField;
            }
            set {
                this.systemRoleField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this role grants all permissions.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool allPermissions {
            get {
                return this.allPermissionsField;
            }
            set {
                this.allPermissionsField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of the permissions granted by the role. Any 
    ///   permission not included in this list is not allowed for the role. 
    ///   If allPermissions is true, this list will be nil.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] permissions {
            get {
                return this.permissionsField;
            }
            set {
                this.permissionsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this role grants access to all policies.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool allPolicies {
            get {
                return this.allPoliciesField;
            }
            set {
                this.allPoliciesField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of policies that this role grants access to. If 
    ///   allPolicies is true, this list will be filled in with the names of 
    ///   all policies in the system. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] policyList {
            get {
                return this.policyListField;
            }
            set {
                this.policyListField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this role grants access to all groups.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool allGroups {
            get {
                return this.allGroupsField;
            }
            set {
                this.allGroupsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, when assigned to an administrator, this role grants access to 
    ///   users who belong to the same group as the administrator. At most one 
    ///   of allGroups and ownGroup can be true. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool ownGroup {
            get {
                return this.ownGroupField;
            }
            set {
                this.ownGroupField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of the groups that this role grants access to. 
    ///   If allGroups is true, this list will be filled in with the names of 
    ///   all groups in the system. 
    ///   If ownGroup is true, this list will have a single entry which is the 
    ///   name of the caller's group. 
    ///   In general, the allGroups and ownGroup flags should be checked before 
    ///   this list. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] groupList {
            get {
                return this.groupListField;
            }
            set {
                this.groupListField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this role grants access to all roles.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool allRoles {
            get {
                return this.allRolesField;
            }
            set {
                this.allRolesField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of the names of the roles that this role grants access to. If 
    ///   allRoles is true, this list will be filled in with the names of all 
    ///   roles in the system. 
    ///   In general, the allRoles flag should be checked before this list. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] roleList {
            get {
                return this.roleListField;
            }
            set {
                this.roleListField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] rolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Descriptive comments about this role.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a list of RoleInfo.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RoleInfoList {
        
        private RoleInfo[] roleInfoField;
        
    /// <datatype>
    ///   RoleInfo[]
    /// </datatype>
    /// <value>
    ///   List of information about roles.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public RoleInfo[] roleInfo {
            get {
                return this.roleInfoField;
            }
            set {
                this.roleInfoField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a permission that may be included in a role's list of 
    ///   permissions. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class Permission {
        
        private string nameField;
        
        private string[] dependenciesField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of a permission.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   An optional list of names of permissions that this permission depends 
    ///   on. To be included in a role's permission list, all of the 
    ///   permissions named in this list must also be included. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] dependencies {
            get {
                return this.dependenciesField;
            }
            set {
                this.dependenciesField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a list of permissions.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PermissionsList {
        
        private Permission[] permissionsField;
        
    /// <datatype>
    ///   Permission[]
    /// </datatype>
    /// <value>
    ///   The list of permissions.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public Permission[] Permissions {
            get {
                return this.permissionsField;
            }
            set {
                this.permissionsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   passwordRulesGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PasswordRulesGetCallParms {
        
        private string nameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the password policy to retrieve. If null, it indicates the 
    ///   default policy should be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to pinSpecGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PinSpecGetCallParms {
        
        private string nameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the temporary PIN specification policy to retrieve. 
    ///   If null, it indicates the default policy should be returned.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   cardSpecGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class CardSpecGetCallParms {
        
        private string nameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the card specification policy to retrieve. If null, it 
    ///   indicates the default policy should be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   userSpecGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserSpecGetCallParms {
        
        private string nameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the user specification policy to retrieve. If null, it 
    ///   indicates the default policy should be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a list of PolicyInfo.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PolicyInfoList {
        
        private PolicyInfo[] policyInfoField;
        
    /// <datatype>
    ///   PolicyInfo[]
    /// </datatype>
    /// <value>
    ///   Information about a policy.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public PolicyInfo[] policyInfo {
            get {
                return this.policyInfoField;
            }
            set {
                this.policyInfoField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines basic information about a policy.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PolicyInfo {
        
        private string nameField;
        
        private bool defaultPolicyField;
        
        private UserSpecInfo userSpecField;
        
        private CardSpecInfo cardSpecField;
        
        private PINSpecInfo pinSpecField;
        
        private PasswordRulesInfo passwordRulesField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, it means this policy is the default, and is used in 
    ///   situations where no policy is specified but a policy is required, such as 
    ///   during group creation. If false, this is not the default policy. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool defaultPolicy {
            get {
                return this.defaultPolicyField;
            }
            set {
                this.defaultPolicyField = value;
            }
        }
        
    /// <datatype>
    ///   UserSpecInfo
    /// </datatype>
    /// <value>
    ///   The user specification for this policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public UserSpecInfo userSpec {
            get {
                return this.userSpecField;
            }
            set {
                this.userSpecField = value;
            }
        }
        
    /// <datatype>
    ///   CardSpecInfo
    /// </datatype>
    /// <value>
    ///   The card specification for this policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public CardSpecInfo cardSpec {
            get {
                return this.cardSpecField;
            }
            set {
                this.cardSpecField = value;
            }
        }
        
    /// <datatype>
    ///   PINSpecInfo
    /// </datatype>
    /// <value>
    ///   The PIN specification for this policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PINSpecInfo pinSpec {
            get {
                return this.pinSpecField;
            }
            set {
                this.pinSpecField = value;
            }
        }
        
    /// <datatype>
    ///   PasswordRulesInfo
    /// </datatype>
    /// <value>
    ///   The password rules for this policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PasswordRulesInfo passwordRules {
            get {
                return this.passwordRulesField;
            }
            set {
                this.passwordRulesField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] rolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Descriptive comments about this policy, that could be used to provide 
    ///   a full description of this policy's intended purpose. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a user specification policy.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserSpecInfo {
        
        private string nameField;
        
        private int maxAliasesField;
        
        private int maxContactInfoNumberField;
        
        private int maxFailuresField;
        
        private int lockoutTimeField;
        
        private int maxSecretSizeField;
        
        private int maxSecretNumberField;
        
        private AuthenticationType[] genericAuthTypeField;
        
        private AuthenticationType[] enhancedGenericAuthTypeField;
        
        private AuthenticationType[] machineAuthTypeField;
        
        private AuthenticationType[] authTypeCanViewSecretsField;
        
        private AuthenticationType[] authTypeCanModifySecretsField;
        
        private int maxMachineSecretsField;
        
        private int maxMachineSecretsSizeField;
        
        private bool machineSecretRequiresMachineNonceField;
        
        private bool machineSecretRequiresSequenceNonceField;
        
        private int machineSecretRequiresAppDataField;
        
        private int machineSecretAllowsBadAppDataField;
        
        private int machineSecretLifetimeField;
        
        private int maxAuthSecretsField;
        
        private int maxAuthSecretsSizeField;
        
        private int maxQuestionsField;
        
        private int maxQASizeField;
        
        private int qAChallengeSizeField;
        
        private int minQAChallengeSizeField;
        
        private int maxQAChallengeSizeField;
        
        private int qaDefaultWrongAnswersAllowedField;
        
        private int qaMaximumWrongAnswersAllowedField;
        
        private bool qaInexactMatchAllowedField;
        
        private string[] oTPCellAlphabetField;
        
        private CellReplacement[] oTPCellReplacementsField;
        
        private int oTPLifetimeField;
        
        private int oTPLengthField;
        
        private bool oTPDeliveryEnabledField;
        
        private bool returnAuthSecretWithChallField;
        
        private bool autoUnassignTokensField;
        
        private bool allowDataSignatureField;
        
        private int pVNLengthField;
        
        private bool pVNChangeRequiredOnAdminResetField;
        
        private AuthenticationType[] authTypesRequiringPVNField;
        
        private int numDaysForActivationField;
        
        private AuthenticationType[] activationAuthTypesField;
        
        private bool checkIPAddressInLocationHistoryField;
        
        private int maxLocationHistorySizeField;
        
        private int locationHistoryLifetimeField;
        
        private int maxVelocityField;
        
        private bool checkVelocityField;
        
        private CountryInfo[] countryBlacklistField;
        
        private ExpectedLocation[] expectedLocationsField;
        
        private int maxUserExpectedLocationsSizeField;
        
        private AuthFailureType[] normalRejectField;
        
        private AuthFailureType[] normalChallengeField;
        
        private AuthSuccessType normalAuthenticatedField;
        
        private AuthFailureType[] enhancedRejectField;
        
        private AuthFailureType[] enhancedChallengeField;
        
        private AuthSuccessType enhancedAuthenticatedField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the user specification policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of aliases that can be assigned to a user. A value 
    ///   of 0 means that users are not allowed to have aliases. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxAliases {
            get {
                return this.maxAliasesField;
            }
            set {
                this.maxAliasesField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of contact information entries for a user. A value 
    ///   of 0 means that no contact informantion can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxContactInfoNumber {
            get {
                return this.maxContactInfoNumberField;
            }
            set {
                this.maxContactInfoNumberField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of consecutive authentication failures allowed before a 
    ///   user is locked out. A value of 0 means the user is never locked out, no 
    ///   matter how many times they fail to authenticate. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxFailures {
            get {
                return this.maxFailuresField;
            }
            set {
                this.maxFailuresField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of minutes a user remains locked out. A value of 0 means 
    ///   the user remains locked out until unlocked by an administrator. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int lockoutTime {
            get {
                return this.lockoutTimeField;
            }
            set {
                this.lockoutTimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of the shared secrets for a user, in kilobytes. A 
    ///   value of 0 means that users are not allowed to have shared secrets. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxSecretSize {
            get {
                return this.maxSecretSizeField;
            }
            set {
                this.maxSecretSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of shared secrets for a user. A value of 0 means 
    ///   that users are not allowed to have shared secrets. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxSecretNumber {
            get {
                return this.maxSecretNumberField;
            }
            set {
                this.maxSecretNumberField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can be used for generic 
    ///   authentication operations with a normal security level. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] genericAuthType {
            get {
                return this.genericAuthTypeField;
            }
            set {
                this.genericAuthTypeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can be used for generic 
    ///   authentication operations with an enhanced security level. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] enhancedGenericAuthType {
            get {
                return this.enhancedGenericAuthTypeField;
            }
            set {
                this.enhancedGenericAuthTypeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can be used for machine registration 
    ///   authentication operations. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] machineAuthType {
            get {
                return this.machineAuthTypeField;
            }
            set {
                this.machineAuthTypeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can view mutual authentication 
    ///   secrets and shared secrets during authentication operations. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] authTypeCanViewSecrets {
            get {
                return this.authTypeCanViewSecretsField;
            }
            set {
                this.authTypeCanViewSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can modify mutual authentication 
    ///   secrets and shared secrets during authentication operations. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] authTypeCanModifySecrets {
            get {
                return this.authTypeCanModifySecretsField;
            }
            set {
                this.authTypeCanModifySecretsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of machine secrets for a user. A value of 0 means 
    ///   that no machine secrets can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxMachineSecrets {
            get {
                return this.maxMachineSecretsField;
            }
            set {
                this.maxMachineSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of a single machine secret for a user, in kilobytes. 
    ///   A value of 0 means that no machine secrets can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxMachineSecretsSize {
            get {
                return this.maxMachineSecretsSizeField;
            }
            set {
                this.maxMachineSecretsSizeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if machine secrets must contain the machine nonce 
    ///   when used for authentication. 
    ///   If this flag is false, the machineSecretRequiresAppData setting will 
    ///   be greater than 0, and the machineSecretAllowsBadAppData setting will 
    ///   be 0. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool machineSecretRequiresMachineNonce {
            get {
                return this.machineSecretRequiresMachineNonceField;
            }
            set {
                this.machineSecretRequiresMachineNonceField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if machine secrets must contain the sequence nonce 
    ///   when used for authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool machineSecretRequiresSequenceNonce {
            get {
                return this.machineSecretRequiresSequenceNonceField;
            }
            set {
                this.machineSecretRequiresSequenceNonceField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   A count indicating how many application data values must be contained 
    ///   in a machine secret used for authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int machineSecretRequiresAppData {
            get {
                return this.machineSecretRequiresAppDataField;
            }
            set {
                this.machineSecretRequiresAppDataField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   A count indicating how many application data values in a machine 
    ///   secret being used for authentication can be bad before validation fails. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int machineSecretAllowsBadAppData {
            get {
                return this.machineSecretAllowsBadAppDataField;
            }
            set {
                this.machineSecretAllowsBadAppDataField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   Machine secret lifetime in hours. A value of 0 means an infinite 
    ///   lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int machineSecretLifetime {
            get {
                return this.machineSecretLifetimeField;
            }
            set {
                this.machineSecretLifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of authentication secrets for a user. A value of 0 
    ///   means that no authentication secrets can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxAuthSecrets {
            get {
                return this.maxAuthSecretsField;
            }
            set {
                this.maxAuthSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of authentication secrets for a user, in kilobytes. A 
    ///   value of 0 means that no authentication secrets can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxAuthSecretsSize {
            get {
                return this.maxAuthSecretsSizeField;
            }
            set {
                this.maxAuthSecretsSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of question and answer pairs for a user. A value of 
    ///   0 means that no question and answer pairs can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxQuestions {
            get {
                return this.maxQuestionsField;
            }
            set {
                this.maxQuestionsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of question and answer (QA) pairs stored for a user, 
    ///   in kilobytes. A value of 0 means that no QA pairs can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxQASize {
            get {
                return this.maxQASizeField;
            }
            set {
                this.maxQASizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of questions in a QA challenge.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int QAChallengeSize {
            get {
                return this.qAChallengeSizeField;
            }
            set {
                this.qAChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The minimum number of questions allowed in a question and answer 
    ///   challenge when the call to obtain such a challenge overrides the default. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int minQAChallengeSize {
            get {
                return this.minQAChallengeSizeField;
            }
            set {
                this.minQAChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of questions allowed in a question and answer 
    ///   challenge when the call to obtain such a challenge overrides the default. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxQAChallengeSize {
            get {
                return this.maxQAChallengeSizeField;
            }
            set {
                this.maxQAChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The default number of wrong answers that are allowed in response to a 
    ///   question and answer challenge and still have the response be 
    ///   considered correct. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int qaDefaultWrongAnswersAllowed {
            get {
                return this.qaDefaultWrongAnswersAllowedField;
            }
            set {
                this.qaDefaultWrongAnswersAllowedField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of wrong answers that are allowed in response to a 
    ///   question and answer challenge and still have the response be 
    ///   considered correct. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int qaMaximumWrongAnswersAllowed {
            get {
                return this.qaMaximumWrongAnswersAllowedField;
            }
            set {
                this.qaMaximumWrongAnswersAllowedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if word substitutions can be used when comparing the 
    ///   answer and response in a question and answer challenge. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool qaInexactMatchAllowed {
            get {
                return this.qaInexactMatchAllowedField;
            }
            set {
                this.qaInexactMatchAllowedField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The characters that can appear in a one-time password (OTP).
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] OTPCellAlphabet {
            get {
                return this.oTPCellAlphabetField;
            }
            set {
                this.oTPCellAlphabetField = value;
            }
        }
        
    /// <datatype>
    ///   CellReplacement[]
    /// </datatype>
    /// <value>
    ///   A list of characters that are replaced in a one-time password (OTP) 
    ///   response before it is validated. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public CellReplacement[] OTPCellReplacements {
            get {
                return this.oTPCellReplacementsField;
            }
            set {
                this.oTPCellReplacementsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The lifetime in seconds of a one-time password (OTP). A value of 0 
    ///   means an infinite lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int OTPLifetime {
            get {
                return this.oTPLifetimeField;
            }
            set {
                this.oTPLifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of characters in a one-time password (OTP).
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int OTPLength {
            get {
                return this.oTPLengthField;
            }
            set {
                this.oTPLengthField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if a user's one-time password (OTP) can be delivered 
    ///   via an out-of-band delivery mechanism. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool OTPDeliveryEnabled {
            get {
                return this.oTPDeliveryEnabledField;
            }
            set {
                this.oTPDeliveryEnabledField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if mutual authentication secrets can be returned with 
    ///   a challenge. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool ReturnAuthSecretWithChall {
            get {
                return this.returnAuthSecretWithChallField;
            }
            set {
                this.returnAuthSecretWithChallField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if user tokens are automatically unassigned when the 
    ///   user they belong to is deleted. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool AutoUnassignTokens {
            get {
                return this.autoUnassignTokensField;
            }
            set {
                this.autoUnassignTokensField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if user tokens can be used to perform the data 
    ///   signature operation during a TOKENRO authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool AllowDataSignature {
            get {
                return this.allowDataSignatureField;
            }
            set {
                this.allowDataSignatureField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The required length of new personal verification numbers (PVNs). 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int PVNLength {
            get {
                return this.pVNLengthField;
            }
            set {
                this.pVNLengthField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates whether a user is required to change their personal 
    ///   verification number (PVN) after it is set by an administrator. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool PVNChangeRequiredOnAdminReset {
            get {
                return this.pVNChangeRequiredOnAdminResetField;
            }
            set {
                this.pVNChangeRequiredOnAdminResetField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The authentication types that require a personal verification number 
    ///   to be provided when authenticating. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] AuthTypesRequiringPVN {
            get {
                return this.authTypesRequiringPVNField;
            }
            set {
                this.authTypesRequiringPVNField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of days for user activation.
    ///   A value of 0 means that the user has no grace period, they will need 
    ///   to activate their card or token immediately. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int numDaysForActivation {
            get {
                return this.numDaysForActivationField;
            }
            set {
                this.numDaysForActivationField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The authentication types that trigger user activation on first 
    ///   successful authentication. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] ActivationAuthTypes {
            get {
                return this.activationAuthTypesField;
            }
            set {
                this.activationAuthTypesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates if the IP address should be checked when comparing a 
    ///   location to entries in a user's location history. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool checkIPAddressInLocationHistory {
            get {
                return this.checkIPAddressInLocationHistoryField;
            }
            set {
                this.checkIPAddressInLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of a user's location history.
    ///   If a user exceeds this many locations, the least-recently used 
    ///   locations are removed from the list. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxLocationHistorySize {
            get {
                return this.maxLocationHistorySizeField;
            }
            set {
                this.maxLocationHistorySizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The lifetime (in days) of an entry in a user's location history. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int locationHistoryLifetime {
            get {
                return this.locationHistoryLifetimeField;
            }
            set {
                this.locationHistoryLifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum velocity (in km/h) a user can travel. This value is used 
    ///   when comparing a user's current location against previous locations 
    ///   during IP authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxVelocity {
            get {
                return this.maxVelocityField;
            }
            set {
                this.maxVelocityField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the velocity check is performed during IP authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool checkVelocity {
            get {
                return this.checkVelocityField;
            }
            set {
                this.checkVelocityField = value;
            }
        }
        
    /// <datatype>
    ///   CountryInfo[]
    /// </datatype>
    /// <value>
    ///   The country blacklist is a list of countries.
    ///   Users authenticating from these countries may not be allowed to 
    ///   authenticate or may require additional authentication. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public CountryInfo[] countryBlacklist {
            get {
                return this.countryBlacklistField;
            }
            set {
                this.countryBlacklistField = value;
            }
        }
        
    /// <datatype>
    ///   ExpectedLocation[]
    /// </datatype>
    /// <value>
    ///   The expected locations list is a list of locations that users are 
    ///   expected to authenticate from. Users authenticated from an expected 
    ///   location may require less authentication. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public ExpectedLocation[] expectedLocations {
            get {
                return this.expectedLocationsField;
            }
            set {
                this.expectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If the user has their own list of expected locations instead of 
    ///   relying on expectedLocations, this policy defines the maximum size of that 
    ///   list. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxUserExpectedLocationsSize {
            get {
                return this.maxUserExpectedLocationsSizeField;
            }
            set {
                this.maxUserExpectedLocationsSizeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthFailureType[]
    /// </datatype>
    /// <value>
    ///   A list of authentication failure types that will result in normal 
    ///   authentication requests being rejected. 
    ///   <p>
    ///   An authentication failure type must appear on one of the normalReject 
    ///   or normalChallenge lists, but cannot appear on both. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthFailureType[] normalReject {
            get {
                return this.normalRejectField;
            }
            set {
                this.normalRejectField = value;
            }
        }
        
    /// <datatype>
    ///   AuthFailureType[]
    /// </datatype>
    /// <value>
    ///   A list of authentication failure types that will result in normal 
    ///   authentication requests being challenged for additional authentication. 
    ///   <p>
    ///   An authentication failure type must appear on one of the normalReject 
    ///   or normalChallenge lists, but cannot appear on both. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthFailureType[] normalChallenge {
            get {
                return this.normalChallengeField;
            }
            set {
                this.normalChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthSuccessType
    /// </datatype>
    /// <value>
    ///   The authentication success types that will result in a normal 
    ///   authentication request being authenticated without requiring additional 
    ///   authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public AuthSuccessType normalAuthenticated {
            get {
                return this.normalAuthenticatedField;
            }
            set {
                this.normalAuthenticatedField = value;
            }
        }
        
    /// <datatype>
    ///   AuthFailureType[]
    /// </datatype>
    /// <value>
    ///   A list of authentication failure types that will result in enhanced 
    ///   authentication requests being rejected. 
    ///   <p>
    ///   An authentication failure type must appear on one of the 
    ///   enhancedReject or enhancedChallenge lists, but cannot appear on both. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthFailureType[] enhancedReject {
            get {
                return this.enhancedRejectField;
            }
            set {
                this.enhancedRejectField = value;
            }
        }
        
    /// <datatype>
    ///   AuthFailureType[]
    /// </datatype>
    /// <value>
    ///   A list of authentication failure types that will result in enhanced 
    ///   authentication requests being challenged for additional authentication. 
    ///   <p>
    ///   An authentication failure type must appear on one of the 
    ///   enhancedReject or enhancedChallenge lists, but cannot appear on both. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthFailureType[] enhancedChallenge {
            get {
                return this.enhancedChallengeField;
            }
            set {
                this.enhancedChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthSuccessType
    /// </datatype>
    /// <value>
    ///   The authentication success types that will result in a enhanced 
    ///   authentication request being authenticated without requiring additional 
    ///   authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public AuthSuccessType enhancedAuthenticated {
            get {
                return this.enhancedAuthenticatedField;
            }
            set {
                this.enhancedAuthenticatedField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] rolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a cell replacement element for the cell alphabet in a card, 
    ///   temporary PIN, or one-time password (OTP). 
    ///   Basically, this represents a mapping from a character not in the given 
    ///   alphabet to a character in the alphabet. 
    ///   <p>
    ///   This is useful in cases where multiple characters that may be entered 
    ///   by a user should be treated as the same character. 
    ///   For example, '0' is easily confused with 'o' and 'O', so you may 
    ///   define a cell alphabet containing the character '0', and have cell 
    ///   replacements mapping 'o' to '0', and 'O' to '0', making all of these 
    ///   characters equivalent for authentication purposes. 
    ///   </p>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class CellReplacement {
        
        private string fromField;
        
        private string toField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The character to be replaced. This character must not appear in the 
    ///   cell alphabet that the replacement is being applied to. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string from {
            get {
                return this.fromField;
            }
            set {
                this.fromField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The character it is replaced with. This character must appear in the 
    ///   cell alphabet that the replacement is being applied to. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string to {
            get {
                return this.toField;
            }
            set {
                this.toField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure provides information about a country.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class CountryInfo {
        
        private string countryCodeField;
        
        private string countryNameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The code of the country.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string countryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the country.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string countryName {
            get {
                return this.countryNameField;
            }
            set {
                this.countryNameField = value;
            }
        }
    }
    
    /// <summary>
    ///   The types of authentication failures that are considered by risk-based 
    ///   authentication when deciding if the user must be challenged or if 
    ///   the authentication is rejected. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum AuthFailureType {
        
    /// <value>
    ///   The current location is not in the user's location history.
    /// </value>
        LOCATION,
        
    /// <value>
    ///   The velocity required to move from existing locations to the current 
    ///   location exceeds the limit defined by policy. 
    /// </value>
        VELOCITY,
        
    /// <value>
    ///   The current IP address is on the IP blacklist.
    /// </value>
        IPBLACKLIST,
        
    /// <value>
    ///   The country of the current location is on the country blacklist. 
    /// </value>
        COUNTRYBLACKLIST,
        
    /// <value>
    ///   Machine authentication failed.
    /// </value>
        MACHINEAUTH,
    }
    
    /// <summary>
    ///   The types of authentication success that are considered by risk-based 
    ///   authentication when deciding if no additional authentication is 
    ///   required. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum AuthSuccessType {
        
    /// <value>
    ///   Any of successful IP or machine authentication is sufficient. 
    /// </value>
        ANY,
        
    /// <value>
    ///   Successful IP authentication is sufficient.
    /// </value>
        IP,
        
    /// <value>
    ///   Successful machine authentication is sufficient.
    /// </value>
        MACHINEAUTH,
        
    /// <value>
    ///   Successful IP and machine authentication are required.
    /// </value>
        ALL,
        
    /// <value>
    ///   The user requires additional authentication.
    /// </value>
        CHALLENGE,
    }
    
    /// <summary>
    ///   Defines a card specification policy. These values control how cards 
    ///   are used for authentication and how new cards are created. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class CardSpecInfo {
        
        private string nameField;
        
        private int numRowsField;
        
        private int numColumnsField;
        
        private int cellSizeField;
        
        private string[] cellAlphabetField;
        
        private CellReplacement[] cellReplacementsField;
        
        private int challengeSizeField;
        
        private int minChallengeSizeField;
        
        private int maxChallengeSizeField;
        
        private long lifetimeField;
        
        private long supersedeField;
        
        private bool sortChallengeField;
        
        private bool userInfoInChallengeField;
        
        private bool disableAnonymousAuthField;
        
        private ChallengeGenAlg challengeGenAlgField;
        
        private bool gatherUsageStatisticsField;
        
        private int leastUsedCellsPerChallengeField;
        
        private int challengeCountWarningThresholdField;
        
        private int challengeCountReplacementThresholdField;
        
        private int leastUsedCellWarningThresholdField;
        
        private int leastUsedCellReplacementThresholdField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the card specification policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of rows in cards created using this policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int numRows {
            get {
                return this.numRowsField;
            }
            set {
                this.numRowsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of columns in cards created using this policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int numColumns {
            get {
                return this.numColumnsField;
            }
            set {
                this.numColumnsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of characters in each cell of cards created using this 
    ///   policy. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int cellSize {
            get {
                return this.cellSizeField;
            }
            set {
                this.cellSizeField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The characters that can appear in a card cell.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] cellAlphabet {
            get {
                return this.cellAlphabetField;
            }
            set {
                this.cellAlphabetField = value;
            }
        }
        
    /// <datatype>
    ///   CellReplacement[]
    /// </datatype>
    /// <value>
    ///   A list of characters that are replaced in a challenge response before 
    ///   it is validated. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public CellReplacement[] cellReplacements {
            get {
                return this.cellReplacementsField;
            }
            set {
                this.cellReplacementsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of cells in a challenge.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int challengeSize {
            get {
                return this.challengeSizeField;
            }
            set {
                this.challengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The minimum number of cells in a challenge.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int minChallengeSize {
            get {
                return this.minChallengeSizeField;
            }
            set {
                this.minChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of cells in a challenge.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxChallengeSize {
            get {
                return this.maxChallengeSizeField;
            }
            set {
                this.maxChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The lifetime in days of a card created using this policy. A value of 0 
    ///   indicates that the card has infinite lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public long lifetime {
            get {
                return this.lifetimeField;
            }
            set {
                this.lifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The amount of time in days that a superseded card can be used after it 
    ///   is superseded. A value of 0 indicates that it can be used 
    ///   indefinitely. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public long supersede {
            get {
                return this.supersedeField;
            }
            set {
                this.supersedeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, challenges are sorted by column/row after generation. This 
    ///   makes it easier for people to respond to the challenge. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool sortChallenge {
            get {
                return this.sortChallengeField;
            }
            set {
                this.sortChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If false, the hasPin flag and serial number list are not included in 
    ///   challenges. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool userInfoInChallenge {
            get {
                return this.userInfoInChallengeField;
            }
            set {
                this.userInfoInChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, anonymous authentication operations are not allowed. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool disableAnonymousAuth {
            get {
                return this.disableAnonymousAuthField;
            }
            set {
                this.disableAnonymousAuthField = value;
            }
        }
        
    /// <datatype>
    ///   ChallengeGenAlg
    /// </datatype>
    /// <value>
    ///   Identifies the challenge generation algorithm being used.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public ChallengeGenAlg challengeGenAlg {
            get {
                return this.challengeGenAlgField;
            }
            set {
                this.challengeGenAlgField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates whether or not usage statistics are being gathered. This 
    ///   only applies when the RANDOM challenge generation algorithm is being 
    ///   used. When the LEASTUSED challenge generation algorithm is being used, 
    ///   usage statistics are always gathered, regardless of this setting. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool gatherUsageStatistics {
            get {
                return this.gatherUsageStatisticsField;
            }
            set {
                this.gatherUsageStatisticsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   Indicates the minimum number of least used cells that will be included 
    ///   in every generated challenge. Only applies when the LEASTUSED 
    ///   challenge generation algorithm is being used. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int leastUsedCellsPerChallenge {
            get {
                return this.leastUsedCellsPerChallengeField;
            }
            set {
                this.leastUsedCellsPerChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The challenge count warning threshold; represents a number of 
    ///   challenges that can be generated for a card and used to authenticate and when 
    ///   this number is reached, a warning will be logged each each time the 
    ///   card is used to authenticate. 
    ///   Once a card has been used to authenticate this many challenges it 
    ///   should be replaced. 
    ///   <p>
    ///   This threshold is used for the LEASTUSED challenge algorithm, or the 
    ///   RANDOM algorithm when gatherUsageStatistics has been set to true. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int challengeCountWarningThreshold {
            get {
                return this.challengeCountWarningThresholdField;
            }
            set {
                this.challengeCountWarningThresholdField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The challenge count replacement threshold; represents a number of 
    ///   challenges that can be generated for a card and used to authenticate and 
    ///   when this number is reached, the card will be moved to the HOLD state 
    ///   and can no longer be used to authenticate. 
    ///   Once a card has been used to authenticate this many challenges it must 
    ///   be replaced. 
    ///   <p>
    ///   This threshold is used for the LEASTUSED challenge algorithm, or the 
    ///   RANDOM algorithm when gatherUsageStatistics has been set to true. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int challengeCountReplacementThreshold {
            get {
                return this.challengeCountReplacementThresholdField;
            }
            set {
                this.challengeCountReplacementThresholdField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The least used cell warning threshold. The least used cell in a card 
    ///   is the cell that has been appeared the least number of times in a 
    ///   successfully authenticated challenge. When the least used cell in a card 
    ///   has been used a number of times equal to this threshold, a warning 
    ///   will be logged each each time the card is used to authenticate. The 
    ///   card should be replaced at this point. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int leastUsedCellWarningThreshold {
            get {
                return this.leastUsedCellWarningThresholdField;
            }
            set {
                this.leastUsedCellWarningThresholdField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The least used cell replacement threshold.
    ///   When the least used cell in a card has been used a number of times 
    ///   equal to this threshold, the card will be moved to the HOLD state and 
    ///   can no longer be used to authenticate. 
    ///   The card must be replaced at this point.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int leastUsedCellReplacementThreshold {
            get {
                return this.leastUsedCellReplacementThresholdField;
            }
            set {
                this.leastUsedCellReplacementThresholdField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] rolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the possible challenge generation algorithms for card 
    ///   GRID-based challenges. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum ChallengeGenAlg {
        
    /// <value>
    ///   Challenges select cells from the card completely at random, and 
    ///   challenges for the same user have no dependencies on prior challenges. It 
    ///   is possible, though extremely unlikely, that two consecutive 
    ///   challenges for the same user will be identical. 
    /// </value>
        RANDOM,
        
    /// <value>
    ///   Challenges select cells from the card randomly, but each challenge 
    ///   will include at least one cell with the lowest usage count, where a 
    ///   cell's usage count is the number of times it has been used to 
    ///   authenticate previous challenges. 
    /// </value>
        LEASTUSED,
    }
    
    /// <summary>
    ///   Defines a temporary PIN specification policy.
    ///   These values control how temporary PINs are used for authentication 
    ///   and how new temporary PINs are created. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PINSpecInfo {
        
        private string nameField;
        
        private int cellSizeField;
        
        private string[] cellAlphabetField;
        
        private CellReplacement[] cellReplacementsField;
        
        private int challengeSizeField;
        
        private long lifetimeField;
        
        private int maxUsesField;
        
        private bool autoDeleteField;
        
        private string[] rolesGrantingAccessField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the PIN specification policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of characters in each cell.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int cellSize {
            get {
                return this.cellSizeField;
            }
            set {
                this.cellSizeField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The characters that can appear in a cell.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] cellAlphabet {
            get {
                return this.cellAlphabetField;
            }
            set {
                this.cellAlphabetField = value;
            }
        }
        
    /// <datatype>
    ///   CellReplacement[]
    /// </datatype>
    /// <value>
    ///   A list of characters that are replaced in a challenge response before 
    ///   it is validated. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public CellReplacement[] cellReplacements {
            get {
                return this.cellReplacementsField;
            }
            set {
                this.cellReplacementsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of cells in a temporary PIN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int challengeSize {
            get {
                return this.challengeSizeField;
            }
            set {
                this.challengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The lifetime in hours of the temporary PIN. A value of 0 indicates 
    ///   that the PIN has infinite lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public long lifetime {
            get {
                return this.lifetimeField;
            }
            set {
                this.lifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of times the temporary PIN can be used for authentication. 
    ///   A value of 0 means the PIN can be used an infinite number of times. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxUses {
            get {
                return this.maxUsesField;
            }
            set {
                this.maxUsesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, a user's temporary PIN is automatically deleted after a 
    ///   successful grid or token authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool autoDelete {
            get {
                return this.autoDeleteField;
            }
            set {
                this.autoDeleteField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] rolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to policySet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PolicySetCallParms {
        
        private string nameField;
        
        private PolicyParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the policy to update.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   PolicyParms
    /// </datatype>
    /// <value>
    ///   Parameters that control the policy settings. Any policy settings not 
    ///   in this structure will not be updated. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PolicyParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Parameters that can be applied when creating or modifying a policy. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PolicyParms {
        
        private string nameField;
        
        private System.Nullable<bool> defaultPolicyField;
        
        private UserSpecParms userSpecField;
        
        private CardSpecParms cardSpecField;
        
        private PINSpecParms pinSpecField;
        
        private PasswordRulesParms passwordRulesField;
        
        private string commentField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   When modifying a policy, this element is the new name of the policy. 
    ///   When creating a policy, this value is ignored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, make this policy the default. Whichever policy is currently 
    ///   flagged as the default will be updated so that it is no longer the 
    ///   default. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> defaultPolicy {
            get {
                return this.defaultPolicyField;
            }
            set {
                this.defaultPolicyField = value;
            }
        }
        
    /// <datatype>
    ///   UserSpecParms
    /// </datatype>
    /// <value>
    ///   Parameters to apply to the user specification for this policy. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public UserSpecParms userSpec {
            get {
                return this.userSpecField;
            }
            set {
                this.userSpecField = value;
            }
        }
        
    /// <datatype>
    ///   CardSpecParms
    /// </datatype>
    /// <value>
    ///   Parameters to apply to the card specification for this policy. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public CardSpecParms cardSpec {
            get {
                return this.cardSpecField;
            }
            set {
                this.cardSpecField = value;
            }
        }
        
    /// <datatype>
    ///   PINSpecParms
    /// </datatype>
    /// <value>
    ///   Parameters to apply to the PIN specification for this policy. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public PINSpecParms pinSpec {
            get {
                return this.pinSpecField;
            }
            set {
                this.pinSpecField = value;
            }
        }
        
    /// <datatype>
    ///   PasswordRulesParms
    /// </datatype>
    /// <value>
    ///   Parameters to apply to the password rules for this policy.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public PasswordRulesParms passwordRules {
            get {
                return this.passwordRulesField;
            }
            set {
                this.passwordRulesField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Descriptive comments about this policy that could be used to provide a 
    ///   full description of this policy's intended purpose. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Parameters used to modify a user specification policy. All parameters 
    ///   are optional. 
    ///   <p>
    ///   Some of the parameters have restrictions that are affected by other 
    ///   parameters that may or may not be set. In this case, when modifying an 
    ///   existing policy, the resulting policy must obey the restrictions 
    ///   listed. For example, if only the QAChallengeSize parameter is included, 
    ///   the resulting policy must obey the restrictions placed on the 
    ///   QAChallengeSize. 
    ///   </p>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class UserSpecParms {
        
        private System.Nullable<int> maxAliasesField;
        
        private System.Nullable<int> maxContactInfoNumberField;
        
        private System.Nullable<int> maxFailuresField;
        
        private System.Nullable<int> lockoutTimeField;
        
        private System.Nullable<int> maxSecretSizeField;
        
        private System.Nullable<int> maxSecretNumberField;
        
        private AuthenticationType[] genericAuthTypeField;
        
        private AuthenticationType[] enhancedGenericAuthTypeField;
        
        private AuthenticationType[] machineAuthTypeField;
        
        private AuthenticationType[] authTypeCanViewSecretsField;
        
        private AuthenticationType[] authTypeCanModifySecretsField;
        
        private System.Nullable<int> maxMachineSecretsField;
        
        private System.Nullable<int> maxMachineSecretsSizeField;
        
        private System.Nullable<bool> machineSecretRequiresMachineNonceField;
        
        private System.Nullable<bool> machineSecretRequiresSequenceNonceField;
        
        private System.Nullable<int> machineSecretRequiresAppDataField;
        
        private System.Nullable<int> machineSecretAllowsBadAppDataField;
        
        private System.Nullable<int> machineSecretLifetimeField;
        
        private System.Nullable<int> maxAuthSecretsField;
        
        private System.Nullable<int> maxAuthSecretsSizeField;
        
        private System.Nullable<int> maxQuestionsField;
        
        private System.Nullable<int> maxQASizeField;
        
        private System.Nullable<int> qAChallengeSizeField;
        
        private System.Nullable<int> minQAChallengeSizeField;
        
        private System.Nullable<int> maxQAChallengeSizeField;
        
        private System.Nullable<int> qaDefaultWrongAnswersAllowedField;
        
        private System.Nullable<int> qaMaximumWrongAnswersAllowedField;
        
        private System.Nullable<bool> qaInexactMatchAllowedField;
        
        private string[] oTPCellAlphabetField;
        
        private CellReplacement[] oTPCellReplacementsField;
        
        private System.Nullable<int> oTPLifetimeField;
        
        private System.Nullable<int> oTPLengthField;
        
        private System.Nullable<bool> oTPDeliveryEnabledField;
        
        private System.Nullable<bool> returnAuthSecretWithChallField;
        
        private System.Nullable<bool> autoUnassignTokensField;
        
        private System.Nullable<bool> allowDataSignatureField;
        
        private System.Nullable<int> pVNLengthField;
        
        private System.Nullable<bool> pVNChangeRequiredOnAdminResetField;
        
        private AuthenticationType[] authTypesRequiringPVNField;
        
        private System.Nullable<int> numDaysForActivationField;
        
        private AuthenticationType[] activationAuthTypesField;
        
        private System.Nullable<bool> checkIPAddressInLocationHistoryField;
        
        private System.Nullable<int> maxLocationHistorySizeField;
        
        private System.Nullable<int> locationHistoryLifetimeField;
        
        private System.Nullable<int> maxVelocityField;
        
        private System.Nullable<bool> checkVelocityField;
        
        private string[] countryBlacklistField;
        
        private System.Nullable<bool> addCountryBlacklistField;
        
        private System.Nullable<bool> removeCountryBlacklistField;
        
        private ExpectedLocation[] expectedLocationsField;
        
        private System.Nullable<bool> addExpectedLocationsField;
        
        private System.Nullable<bool> removeExpectedLocationsField;
        
        private System.Nullable<int> maxUserExpectedLocationsSizeField;
        
        private AuthFailureType[] normalRejectField;
        
        private System.Nullable<bool> normalRejectAddField;
        
        private System.Nullable<bool> normalRejectRemoveField;
        
        private AuthFailureType[] normalChallengeField;
        
        private System.Nullable<bool> normalChallengeAddField;
        
        private System.Nullable<bool> normalChallengeRemoveField;
        
        private System.Nullable<AuthSuccessType> normalAuthenticatedField;
        
        private AuthFailureType[] enhancedRejectField;
        
        private System.Nullable<bool> enhancedRejectAddField;
        
        private System.Nullable<bool> enhancedRejectRemoveField;
        
        private AuthFailureType[] enhancedChallengeField;
        
        private System.Nullable<bool> enhancedChallengeAddField;
        
        private System.Nullable<bool> enhancedChallengeRemoveField;
        
        private System.Nullable<AuthSuccessType> enhancedAuthenticatedField;
        
        private string commentField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of aliases that can be assigned to a user. A value 
    ///   of 0 means that users are not allowed to have aliases. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxAliases {
            get {
                return this.maxAliasesField;
            }
            set {
                this.maxAliasesField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of contact information entries that can be created 
    ///   for a user. A value of 0 means that no contact information can be 
    ///   stored for a user. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxContactInfoNumber {
            get {
                return this.maxContactInfoNumberField;
            }
            set {
                this.maxContactInfoNumberField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of consecutive authentication failures allowed before a 
    ///   user is locked out. A value of 0 means the user is never locked out, no 
    ///   matter how many times they fail to authenticate. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxFailures {
            get {
                return this.maxFailuresField;
            }
            set {
                this.maxFailuresField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of minutes a user remains locked. A value of 0 means the 
    ///   user remains locked until unlocked by an administrator. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> lockoutTime {
            get {
                return this.lockoutTimeField;
            }
            set {
                this.lockoutTimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of the shared secrets for a user, in kilobytes. A 
    ///   value of 0 means that users are not allowed to have shared secrets. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxSecretSize {
            get {
                return this.maxSecretSizeField;
            }
            set {
                this.maxSecretSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of shared secrets for a user. A value of 0 means 
    ///   that users are not allowed to have shared secrets. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxSecretNumber {
            get {
                return this.maxSecretNumberField;
            }
            set {
                this.maxSecretNumberField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can be used for generic 
    ///   authentication operations with a normal security level. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] genericAuthType {
            get {
                return this.genericAuthTypeField;
            }
            set {
                this.genericAuthTypeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can be used for generic 
    ///   authentication operations with an enhanced security level. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] enhancedGenericAuthType {
            get {
                return this.enhancedGenericAuthTypeField;
            }
            set {
                this.enhancedGenericAuthTypeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can be used for machine registration 
    ///   authentication operations. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] machineAuthType {
            get {
                return this.machineAuthTypeField;
            }
            set {
                this.machineAuthTypeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can view mutual authentication 
    ///   secrets and shared secrets during authentication operations. This list 
    ///   cannot include the authentication type NONE. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] authTypeCanViewSecrets {
            get {
                return this.authTypeCanViewSecretsField;
            }
            set {
                this.authTypeCanViewSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The type of authentications that can modify mutual authentication 
    ///   secrets and shared secrets during authentication operations. This list 
    ///   cannot include the authentication type NONE. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] authTypeCanModifySecrets {
            get {
                return this.authTypeCanModifySecretsField;
            }
            set {
                this.authTypeCanModifySecretsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of machine secrets for a user. A value of 0 means 
    ///   that no machine secrets can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxMachineSecrets {
            get {
                return this.maxMachineSecretsField;
            }
            set {
                this.maxMachineSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of a single machine secret for a user, in kilobytes. 
    ///   A value of 0 means that no machine secrets can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxMachineSecretsSize {
            get {
                return this.maxMachineSecretsSizeField;
            }
            set {
                this.maxMachineSecretsSizeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if machine secrets must contain the machine nonce 
    ///   when used for authentication. 
    ///   To set this flag to false, the machineSecretRequiresAppData setting 
    ///   must be greater than 0, and the machineSecretAllowsBadAppData setting 
    ///   must be 0. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> machineSecretRequiresMachineNonce {
            get {
                return this.machineSecretRequiresMachineNonceField;
            }
            set {
                this.machineSecretRequiresMachineNonceField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if machine secrets must contain the sequence nonce 
    ///   when used for authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> machineSecretRequiresSequenceNonce {
            get {
                return this.machineSecretRequiresSequenceNonceField;
            }
            set {
                this.machineSecretRequiresSequenceNonceField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   A count indicating how many application data values in a machine 
    ///   secret being used for authentication can be bad before validation fails. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> machineSecretRequiresAppData {
            get {
                return this.machineSecretRequiresAppDataField;
            }
            set {
                this.machineSecretRequiresAppDataField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   A count indicating how many application data values in the machine 
    ///   secret can be bad before validation fails. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> machineSecretAllowsBadAppData {
            get {
                return this.machineSecretAllowsBadAppDataField;
            }
            set {
                this.machineSecretAllowsBadAppDataField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   Machine secret lifetime in hours. This must be a value between 0 and 
    ///   876000 inclusive. A value of 0 means infinite lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> machineSecretLifetime {
            get {
                return this.machineSecretLifetimeField;
            }
            set {
                this.machineSecretLifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of authentication secrets for a user. A value of 0 
    ///   means that no authentication secrets can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxAuthSecrets {
            get {
                return this.maxAuthSecretsField;
            }
            set {
                this.maxAuthSecretsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of authentication secrets for a user, in kilobytes. A 
    ///   value of 0 means that no authentication secrets can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxAuthSecretsSize {
            get {
                return this.maxAuthSecretsSizeField;
            }
            set {
                this.maxAuthSecretsSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of questions and answer pairs for a user. A value 
    ///   of 0 means that no question and answer pairs can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxQuestions {
            get {
                return this.maxQuestionsField;
            }
            set {
                this.maxQuestionsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of questions and answer (QA) pairs stored for a user, 
    ///   in kilobytes. A value of 0 means that no QA pairs can be stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxQASize {
            get {
                return this.maxQASizeField;
            }
            set {
                this.maxQASizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of questions in a QA challenge. This value must satisfy the 
    ///   restriction 
    ///   1&lt;=minQAChallengeSize&lt;=QAChallengeSize&lt;=maxQAChallengeSize 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> QAChallengeSize {
            get {
                return this.qAChallengeSizeField;
            }
            set {
                this.qAChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The minimum number of questions allowed in a question and answer 
    ///   challenge when the call to obtain such a challenge overrides the default. 
    ///   This value must satisfy the restriction 
    ///   1&lt;=minQAChallengeSize&lt;=QAChallengeSize&lt;=maxQAChallengeSize 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> minQAChallengeSize {
            get {
                return this.minQAChallengeSizeField;
            }
            set {
                this.minQAChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of questions allowed in a question and answer 
    ///   challenge when the call to obtain such a challenge overrides the default. 
    ///   This value must satisfy the restriction 
    ///   1&lt;=minQAChallengeSize&lt;=QAChallengeSize&lt;=maxQAChallengeSize 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxQAChallengeSize {
            get {
                return this.maxQAChallengeSizeField;
            }
            set {
                this.maxQAChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The default number of wrong answers that are allowed in response to a 
    ///   question and answer challenge and still have the response be 
    ///   considered correct. This value must satisfy the restriction 
    ///   0&lt;=qaDefaultWrongAnswersAllowed&lt;=qaMaximumWrongAnswersAllowed, and 
    ///   qaDefaultWrongAnswersAllowed must be less than QAChallengeSize 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> qaDefaultWrongAnswersAllowed {
            get {
                return this.qaDefaultWrongAnswersAllowedField;
            }
            set {
                this.qaDefaultWrongAnswersAllowedField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of wrong answers that are allowed in response to a 
    ///   question and answer challenge and still have the response be 
    ///   considered correct, when the call to authenticate such a challenge overrides 
    ///   the default. This value must satisfy the restriction 
    ///   0&lt;=qaDefaultWrongAnswersAllowed&lt;=qaMaximumWrongAnswersAllowed, and 
    ///   qaMaximumWrongAnswersAllowed must be less than maxQAChallengeSize 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> qaMaximumWrongAnswersAllowed {
            get {
                return this.qaMaximumWrongAnswersAllowedField;
            }
            set {
                this.qaMaximumWrongAnswersAllowedField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if word substitutions can be used when comparing the 
    ///   answer and response in a question and answer challenge. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> qaInexactMatchAllowed {
            get {
                return this.qaInexactMatchAllowedField;
            }
            set {
                this.qaInexactMatchAllowedField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The characters that can appear in a one-time password (OTP).
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] OTPCellAlphabet {
            get {
                return this.oTPCellAlphabetField;
            }
            set {
                this.oTPCellAlphabetField = value;
            }
        }
        
    /// <datatype>
    ///   CellReplacement[]
    /// </datatype>
    /// <value>
    ///   A list of characters that are replaced in a one-time password (OTP) 
    ///   response before it is validated. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public CellReplacement[] OTPCellReplacements {
            get {
                return this.oTPCellReplacementsField;
            }
            set {
                this.oTPCellReplacementsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The lifetime in seconds of a OTP. A value of 0 means an infinite 
    ///   lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> OTPLifetime {
            get {
                return this.oTPLifetimeField;
            }
            set {
                this.oTPLifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of characters in a one-time password (OTP).
    ///   Must be at least 1.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> OTPLength {
            get {
                return this.oTPLengthField;
            }
            set {
                this.oTPLengthField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if a user's one-time password (OTP) can be delivered 
    ///   via an out-of-band delivery mechanism. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> OTPDeliveryEnabled {
            get {
                return this.oTPDeliveryEnabledField;
            }
            set {
                this.oTPDeliveryEnabledField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if mutual authentication secrets can be returned with 
    ///   a challenge. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> ReturnAuthSecretWithChall {
            get {
                return this.returnAuthSecretWithChallField;
            }
            set {
                this.returnAuthSecretWithChallField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if user tokens are automatically unassigned when the 
    ///   user they belong to is deleted. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> autoUnassignTokens {
            get {
                return this.autoUnassignTokensField;
            }
            set {
                this.autoUnassignTokensField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if user tokens can be used to perform the data 
    ///   signature operation during a TOKENRO authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allowDataSignature {
            get {
                return this.allowDataSignatureField;
            }
            set {
                this.allowDataSignatureField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The required length of new personal verification numbers (PVNs). 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> PVNLength {
            get {
                return this.pVNLengthField;
            }
            set {
                this.pVNLengthField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates whether a user is required to change their personal 
    ///   verification number (PVN) after it is set by an administrator. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> PVNChangeRequiredOnAdminReset {
            get {
                return this.pVNChangeRequiredOnAdminResetField;
            }
            set {
                this.pVNChangeRequiredOnAdminResetField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The authentication types that require a personal verification number 
    ///   to be provided when authenticating. 
    ///   This list can only include the GRID, TOKENRO, TOKENCR and OTP 
    ///   authentication types. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] authTypesRequiringPVN {
            get {
                return this.authTypesRequiringPVNField;
            }
            set {
                this.authTypesRequiringPVNField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of days for user activation.
    ///   A value of 0 means that the user has no grace period, they will need 
    ///   to activate their card or token immediately. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> numDaysForActivation {
            get {
                return this.numDaysForActivationField;
            }
            set {
                this.numDaysForActivationField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType[]
    /// </datatype>
    /// <value>
    ///   The authentication types that trigger user activation on the first 
    ///   successful authentication with one of these types. This list can only 
    ///   include the GRID, TOKENRO, and TOKENCR authentication types. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthenticationType[] ActivationAuthTypes {
            get {
                return this.activationAuthTypesField;
            }
            set {
                this.activationAuthTypesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicate if the IP address should be checked when comparing a location 
    ///   to entries in a user's location history. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> checkIPAddressInLocationHistory {
            get {
                return this.checkIPAddressInLocationHistoryField;
            }
            set {
                this.checkIPAddressInLocationHistoryField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of a user's location history.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxLocationHistorySize {
            get {
                return this.maxLocationHistorySizeField;
            }
            set {
                this.maxLocationHistorySizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The lifetime (in days) of an entry in the user's location history. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> locationHistoryLifetime {
            get {
                return this.locationHistoryLifetimeField;
            }
            set {
                this.locationHistoryLifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum velocity (in km/h) a user can travel. This value is used 
    ///   when comparing a user's current location against previous locations 
    ///   during IP authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxVelocity {
            get {
                return this.maxVelocityField;
            }
            set {
                this.maxVelocityField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the velocity check is performed during IP authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> checkVelocity {
            get {
                return this.checkVelocityField;
            }
            set {
                this.checkVelocityField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The country blacklist is a list of country codes. Valid country codes 
    ///   can be obtained from the country information returned by the 
    ///   countryList operation. 
    ///   <p>
    ///   Users authenticating from these countries may not be allowed to 
    ///   authenticate or may require additional authentication. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] countryBlacklist {
            get {
                return this.countryBlacklistField;
            }
            set {
                this.countryBlacklistField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   The country blacklist is a list of country codes. Users authenticating 
    ///   from these countries may not be allowed to authenticate or may 
    ///   require additional authentication. 
    ///   <p>
    ///   If this attribute is set to true, the countries in the 
    ///   countryBlacklist attribute will be added to the current value. This attribute will 
    ///   be ignored if the countryBlacklist attribute is not set. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> addCountryBlacklist {
            get {
                return this.addCountryBlacklistField;
            }
            set {
                this.addCountryBlacklistField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   The country blacklist is a list of country codes. Users authenticating 
    ///   from these countries may not be allowed to authenticate or may 
    ///   require additional authentication. 
    ///   <p>
    ///   If this attribute is set, the countries in the countryBlacklist 
    ///   attribute will be removed from the current value. This attribute is ignored 
    ///   if the countryBlacklist is not set. 
    ///   or the addCountryBlacklist attribute is set.
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> removeCountryBlacklist {
            get {
                return this.removeCountryBlacklistField;
            }
            set {
                this.removeCountryBlacklistField = value;
            }
        }
        
    /// <datatype>
    ///   ExpectedLocation[]
    /// </datatype>
    /// <value>
    ///   The expected locations list is a list of locations that users are 
    ///   expected to authenticate from. Users authenticated from an expected 
    ///   location may require less authentication. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public ExpectedLocation[] expectedLocations {
            get {
                return this.expectedLocationsField;
            }
            set {
                this.expectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   The expected locations list is a list of locations that users are 
    ///   expected to authenticate from. Users authenticated from an expected 
    ///   location may require less authentication. 
    ///   <p>
    ///   If this attribute is set to true, the locations in the 
    ///   expectedLocations attribute will be added to the current value. This attribute will 
    ///   be ignored if the expectedLocation attribute is not set. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> addExpectedLocations {
            get {
                return this.addExpectedLocationsField;
            }
            set {
                this.addExpectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   The expected locations list is a list of locations that users are 
    ///   expected to authenticate from. Users authenticated from an expected 
    ///   location may require less authentication. 
    ///   <p>
    ///   If this attribute is set, the locations in the expectedLocations 
    ///   attribute will be removed from the current value. This attribute is 
    ///   ignored if the expectedLocations attribute is not set. or the 
    ///   addExpectedLocations attribute is set. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> removeExpectedLocations {
            get {
                return this.removeExpectedLocationsField;
            }
            set {
                this.removeExpectedLocationsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   If the user has their own list of expected locations instead of 
    ///   relying on expectedLocations, this policy defines the maximum size of that 
    ///   list. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxUserExpectedLocationsSize {
            get {
                return this.maxUserExpectedLocationsSizeField;
            }
            set {
                this.maxUserExpectedLocationsSizeField = value;
            }
        }
        
    /// <datatype>
    ///   AuthFailureType[]
    /// </datatype>
    /// <value>
    ///   If specified, a list of authentication failure types that will result 
    ///   in normal authentication requests being rejected. 
    ///   <p>
    ///   An authentication failure type must appear on one of the normalReject 
    ///   or normalChallenge lists, but cannot appear on both. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthFailureType[] normalReject {
            get {
                return this.normalRejectField;
            }
            set {
                this.normalRejectField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Add the values specified in the normalReject argument to the existing 
    ///   values instead of replacing the existing values. This argument is 
    ///   ignored if normalReject is not specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> normalRejectAdd {
            get {
                return this.normalRejectAddField;
            }
            set {
                this.normalRejectAddField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Remove the values specified in the normalReject argument from the 
    ///   existing values. 
    ///   This argument is ignored if normalReject is not specified or if 
    ///   normalRejectAdd is specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> normalRejectRemove {
            get {
                return this.normalRejectRemoveField;
            }
            set {
                this.normalRejectRemoveField = value;
            }
        }
        
    /// <datatype>
    ///   AuthFailureType[]
    /// </datatype>
    /// <value>
    ///   If specified, a list of authentication failure types that will result 
    ///   in normal authentication requests being challenged for additional 
    ///   authentication. 
    ///   <p>
    ///   An authentication failure type must appear on one of the normalReject 
    ///   or normalChallenge lists, but cannot appear on both. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthFailureType[] normalChallenge {
            get {
                return this.normalChallengeField;
            }
            set {
                this.normalChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Add the values specified in the normalChallenge argument to the 
    ///   existing values instead of replacing the existing values. This argument is 
    ///   ignored if normalChallenge is not specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> normalChallengeAdd {
            get {
                return this.normalChallengeAddField;
            }
            set {
                this.normalChallengeAddField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Remove the values specified in the normalChallenge argument from the 
    ///   existing values. This argument is ignored if normalChallenge is not 
    ///   specified or if normalChallengeAdd is specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> normalChallengeRemove {
            get {
                return this.normalChallengeRemoveField;
            }
            set {
                this.normalChallengeRemoveField = value;
            }
        }
        
    /// <datatype>
    ///   AuthSuccessType
    /// </datatype>
    /// <value>
    ///   If specified, the authentication success types that will result in a 
    ///   normal authentication request being authenticated without requiring 
    ///   additional authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<AuthSuccessType> normalAuthenticated {
            get {
                return this.normalAuthenticatedField;
            }
            set {
                this.normalAuthenticatedField = value;
            }
        }
        
    /// <datatype>
    ///   AuthFailureType[]
    /// </datatype>
    /// <value>
    ///   If specified, a list of authentication failure types that will result 
    ///   in enhanced authentication requests being rejected. 
    ///   <p>
    ///   This list must contain all of the values in the normalReject list. 
    ///   </p>
    ///   <p>
    ///   An authentication failure type must appear on one of the 
    ///   enhancedReject or enhancedChallenge lists, but cannot appear on both. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthFailureType[] enhancedReject {
            get {
                return this.enhancedRejectField;
            }
            set {
                this.enhancedRejectField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Add the values specified in the enhancedReject argument to the 
    ///   existing values instead of replacing the existing values. This argument is 
    ///   ignored if enhancedReject is not specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> enhancedRejectAdd {
            get {
                return this.enhancedRejectAddField;
            }
            set {
                this.enhancedRejectAddField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Remove the values specified in the enhancedReject argument from the 
    ///   existing values. This argument is ignored if enhancedReject is not 
    ///   specified or if enhancedRejectAdd is specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> enhancedRejectRemove {
            get {
                return this.enhancedRejectRemoveField;
            }
            set {
                this.enhancedRejectRemoveField = value;
            }
        }
        
    /// <datatype>
    ///   AuthFailureType[]
    /// </datatype>
    /// <value>
    ///   If specified, a list of authentication failure types that will result 
    ///   in enhanced authentication requests being challenged for additional 
    ///   authentication. 
    ///   <p>
    ///   An authentication failure type must appear on one of the 
    ///   enhancedReject or enhancedChallenge lists, but cannot appear on both. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public AuthFailureType[] enhancedChallenge {
            get {
                return this.enhancedChallengeField;
            }
            set {
                this.enhancedChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Add the values specified in the enhancedChallenge argument to the 
    ///   existing values instead of replacing the existing values. This argument 
    ///   is ignored if enhancedChallenge is not specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> enhancedChallengeAdd {
            get {
                return this.enhancedChallengeAddField;
            }
            set {
                this.enhancedChallengeAddField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Remove the values specified in the enhancedChallenge argument from the 
    ///   existing values. This argument is ignored if enhancedChallenge is 
    ///   not specified or if enhancedChallengeAdd is specified. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> enhancedChallengeRemove {
            get {
                return this.enhancedChallengeRemoveField;
            }
            set {
                this.enhancedChallengeRemoveField = value;
            }
        }
        
    /// <datatype>
    ///   AuthSuccessType
    /// </datatype>
    /// <value>
    ///   If specified, the authentication success types that will result in a 
    ///   enhanced authentication request being authenticated without requiring 
    ///   additional authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<AuthSuccessType> enhancedAuthenticated {
            get {
                return this.enhancedAuthenticatedField;
            }
            set {
                this.enhancedAuthenticatedField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Parameters used to modify a card specification policy.
    ///   All parameters are optional.
    ///   <p>
    ///   Some of the parameters have restrictions that are affected by other 
    ///   parameters that may or may not be set. In this case, when modifying an 
    ///   existing policy, the resulting policy must obey the restrictions 
    ///   listed. For example, if only the challengeSize parameter is included, the 
    ///   resulting policy must obey the restrictions placed on the 
    ///   challengeSize. 
    ///   </p>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class CardSpecParms {
        
        private System.Nullable<int> numRowsField;
        
        private System.Nullable<int> numColumnsField;
        
        private System.Nullable<int> cellSizeField;
        
        private string[] cellAlphabetField;
        
        private CellReplacement[] cellReplacementsField;
        
        private System.Nullable<int> challengeSizeField;
        
        private System.Nullable<int> minChallengeSizeField;
        
        private System.Nullable<int> maxChallengeSizeField;
        
        private System.Nullable<long> lifetimeField;
        
        private System.Nullable<long> supersedeField;
        
        private System.Nullable<bool> sortChallengeField;
        
        private System.Nullable<bool> userInfoInChallengeField;
        
        private System.Nullable<bool> disableAnonymousAuthField;
        
        private System.Nullable<ChallengeGenAlg> challengeGenAlgField;
        
        private System.Nullable<bool> gatherUsageStatisticsField;
        
        private System.Nullable<int> leastUsedCellsPerChallengeField;
        
        private System.Nullable<int> challengeCountWarningThresholdField;
        
        private System.Nullable<int> challengeCountReplacementThresholdField;
        
        private System.Nullable<int> leastUsedCellWarningThresholdField;
        
        private System.Nullable<int> leastUsedCellReplacementThresholdField;
        
        private string commentField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of rows in the card. Must be at least 1, and the product of 
    ///   numRows and numColumns must not exceed one million. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> numRows {
            get {
                return this.numRowsField;
            }
            set {
                this.numRowsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of columns in the card. Must be at least 1, and the product 
    ///   of numRows and numColumns must not exceed one million. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> numColumns {
            get {
                return this.numColumnsField;
            }
            set {
                this.numColumnsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of characters in each cell. This must be at least 1 and at 
    ///   most 20. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> cellSize {
            get {
                return this.cellSizeField;
            }
            set {
                this.cellSizeField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The characters that can appear in a cell.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] cellAlphabet {
            get {
                return this.cellAlphabetField;
            }
            set {
                this.cellAlphabetField = value;
            }
        }
        
    /// <datatype>
    ///   CellReplacement[]
    /// </datatype>
    /// <value>
    ///   A list of characters that are replaced in a challenge response before 
    ///   it is validated. This can be used to make challenge validation 
    ///   case-insensitive, or to make many similar-looking characters such as '1', 
    ///   'l', and 'I' all be treated as the same character during validation. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public CellReplacement[] cellReplacements {
            get {
                return this.cellReplacementsField;
            }
            set {
                this.cellReplacementsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The size of the challenge. The challenge size must obey the following 
    ///   constraint: 1 &lt;= minChallengeSize &lt;= challengeSize &lt;= 
    ///   maxChallengeSize &lt;= numRows * numColumns 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> challengeSize {
            get {
                return this.challengeSizeField;
            }
            set {
                this.challengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The minimum size of the challenge. Used to validate the size when the 
    ///   call to obtain a challenge specifies an explicit size. This must obey 
    ///   the following constraint: 1 &lt;= minChallengeSize &lt;= 
    ///   challengeSize &lt;= maxChallengeSize &lt;= numRows * numColumns 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> minChallengeSize {
            get {
                return this.minChallengeSizeField;
            }
            set {
                this.minChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum size of the challenge. Used to validate the size when the 
    ///   call to obtain a challenge specifies an explicit size. This must obey 
    ///   the following constraint: 1 &lt;= minChallengeSize &lt;= 
    ///   challengeSize &lt;= maxChallengeSize &lt;= numRows * numColumns 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxChallengeSize {
            get {
                return this.maxChallengeSizeField;
            }
            set {
                this.maxChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The lifetime in days of a card created using this policy.
    ///   This value must be at least 0 and at most 36500.
    ///   A value of 0 indicates that cards have infinite lifetime.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<long> lifetime {
            get {
                return this.lifetimeField;
            }
            set {
                this.lifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The amount of time in days that a superseded card can be used after it 
    ///   is superseded. 
    ///   This value must be at least 0 and at most 36500.
    ///   A value of 0 indicates that superseded cards can be used indefinitely. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<long> supersede {
            get {
                return this.supersedeField;
            }
            set {
                this.supersedeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, challenges are sorted by column/row after generation. 
    ///   Challenges sorted in this way are easier for a person to respond to. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> sortChallenge {
            get {
                return this.sortChallengeField;
            }
            set {
                this.sortChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If false, don't include the hasPin flag or serial number list in 
    ///   challenges. Including this information in a challenge may be classed as a 
    ///   leak of information since potentially anyone can ask for a challenge 
    ///   for any user in the system. On the other hand, this information can 
    ///   be useful to display to a user who is trying to authenticate, and for 
    ///   configuring the interface where the user responds to the challenge. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> userInfoInChallenge {
            get {
                return this.userInfoInChallengeField;
            }
            set {
                this.userInfoInChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, don't allow anonymous authentication operations for users in 
    ///   groups assigned this policy. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> disableAnonymousAuth {
            get {
                return this.disableAnonymousAuthField;
            }
            set {
                this.disableAnonymousAuthField = value;
            }
        }
        
    /// <datatype>
    ///   ChallengeGenAlg
    /// </datatype>
    /// <value>
    ///   Identifies the challenge generation algorithm being used.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<ChallengeGenAlg> challengeGenAlg {
            get {
                return this.challengeGenAlgField;
            }
            set {
                this.challengeGenAlgField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Indicates whether or not usage statistics should be gathered. This 
    ///   only applies when the RANDOM challenge generation algorithm is being 
    ///   used; when the LEASTUSED challenge generation algorithm is being used 
    ///   usage statistics are always gathered regardless of this setting. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> gatherUsageStatistics {
            get {
                return this.gatherUsageStatisticsField;
            }
            set {
                this.gatherUsageStatisticsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   Indicates the minimum number of least used cells that will be included 
    ///   in every generated challenge; only applies when the LEASTUSED 
    ///   challenge generation algorithm is being used. This value must be at least 
    ///   one, and cannot exceed the maximum challenge size. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> leastUsedCellsPerChallenge {
            get {
                return this.leastUsedCellsPerChallengeField;
            }
            set {
                this.leastUsedCellsPerChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The challenge count warning threshold. Once a card has been used to 
    ///   successfully answer this many challenges, the card should be replaced. 
    ///   When a card that has reached this threshold is used for an 
    ///   authentication, a warning message will be generated in the logs. 
    ///   <p>
    ///   This value must be at least one, and not exceed 
    ///   challengeCountReplacementThreshold. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> challengeCountWarningThreshold {
            get {
                return this.challengeCountWarningThresholdField;
            }
            set {
                this.challengeCountWarningThresholdField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The challenge count replacement threshold. Once this many challenges 
    ///   have been reached the card will automatically be moved to the HOLD 
    ///   state and must be replaced. 
    ///   <p>
    ///    This value must be at least challengeCountWarningThreshold.
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> challengeCountReplacementThreshold {
            get {
                return this.challengeCountReplacementThresholdField;
            }
            set {
                this.challengeCountReplacementThresholdField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The least used cell warning threshold. Once the least used cell on the 
    ///   card (the cell that has been used in a successful authentication the 
    ///   least number of times) has been used this many times, the card 
    ///   should be replaced. When a card that has reached this threshold is used 
    ///   for an authentication, a warning message will be generated in the logs. 
    ///   <p>
    ///   This value must be at least one, and not exceed 
    ///   leastUsedCellReplacementThreshold. 
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> leastUsedCellWarningThreshold {
            get {
                return this.leastUsedCellWarningThresholdField;
            }
            set {
                this.leastUsedCellWarningThresholdField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The least used cell replacement threshold.
    ///   Once the least-used cell on the card has been used this many times, 
    ///   the card will automatically be moved to the HOLD state and must be 
    ///   replaced. 
    ///   <p>
    ///    This value must be at least leastUsedCellWarningThreshold.
    ///   </p>
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> leastUsedCellReplacementThreshold {
            get {
                return this.leastUsedCellReplacementThresholdField;
            }
            set {
                this.leastUsedCellReplacementThresholdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Optional descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Parameters used to modify a temporary PIN specification policy. 
    ///   All parameters are optional.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PINSpecParms {
        
        private System.Nullable<int> cellSizeField;
        
        private string[] cellAlphabetField;
        
        private CellReplacement[] cellReplacementsField;
        
        private System.Nullable<int> challengeSizeField;
        
        private System.Nullable<long> lifetimeField;
        
        private System.Nullable<int> maxUsesField;
        
        private System.Nullable<bool> autoDeleteField;
        
        private string commentField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of characters in each cell.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> cellSize {
            get {
                return this.cellSizeField;
            }
            set {
                this.cellSizeField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The characters that can appear in a cell.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] cellAlphabet {
            get {
                return this.cellAlphabetField;
            }
            set {
                this.cellAlphabetField = value;
            }
        }
        
    /// <datatype>
    ///   CellReplacement[]
    /// </datatype>
    /// <value>
    ///   A list of characters that are replaced in a challenge response before 
    ///   it is validated. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public CellReplacement[] cellReplacements {
            get {
                return this.cellReplacementsField;
            }
            set {
                this.cellReplacementsField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of cells in a temporary PIN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> challengeSize {
            get {
                return this.challengeSizeField;
            }
            set {
                this.challengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   long
    /// </datatype>
    /// <value>
    ///   The lifetime in hours of a temporary PIN.
    ///   This value must be at least 0 and at most 876000.
    ///   A value of 0 indicates that the pin has infinite lifetime.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<long> lifetime {
            get {
                return this.lifetimeField;
            }
            set {
                this.lifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of times a temporary PIN can be used for authentication. A 
    ///   value of 0 means the pin can be used an unlimited number of times. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> maxUses {
            get {
                return this.maxUsesField;
            }
            set {
                this.maxUsesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, a user's temporary PIN is automatically deleted when a card 
    ///   is used to authenticate a challenge. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> autoDelete {
            get {
                return this.autoDeleteField;
            }
            set {
                this.autoDeleteField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Optional descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   Parameters used to modify a password policy.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PasswordRulesParms {
        
        private System.Nullable<int> minLengthField;
        
        private System.Nullable<int> lifetimeField;
        
        private System.Nullable<int> minLifetimeField;
        
        private System.Nullable<int> historyField;
        
        private System.Nullable<int> idleTimeoutField;
        
        private System.Nullable<bool> uppercaseField;
        
        private System.Nullable<bool> lowercaseField;
        
        private System.Nullable<bool> numberField;
        
        private System.Nullable<bool> specialField;
        
        private System.Nullable<AuthenticationType> secondAuthField;
        
        private System.Nullable<PasswordStorage> storageField;
        
        private string commentField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The minimum length of a password.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> minLength {
            get {
                return this.minLengthField;
            }
            set {
                this.minLengthField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The lifetime of a password in days. This must be a value between 0 and 
    ///   36500. A value of 0 means the password has an infinite lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> lifetime {
            get {
                return this.lifetimeField;
            }
            set {
                this.lifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The minimum lifetime of a password in days. This must be a value 
    ///   between 0 and 36500. A value of 0 means the password has no minimum 
    ///   lifetime. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> minLifetime {
            get {
                return this.minLifetimeField;
            }
            set {
                this.minLifetimeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of old passwords kept in history to prevent duplicates. 
    ///   This value must be at least 1. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> history {
            get {
                return this.historyField;
            }
            set {
                this.historyField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The time in minutes before a logged in but idle administration service 
    ///   session requires relogin. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> idleTimeout {
            get {
                return this.idleTimeoutField;
            }
            set {
                this.idleTimeoutField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the password requires an uppercase character.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> uppercase {
            get {
                return this.uppercaseField;
            }
            set {
                this.uppercaseField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the password requires a lowercase character.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> lowercase {
            get {
                return this.lowercaseField;
            }
            set {
                this.lowercaseField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the password requires a numeric character.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> number {
            get {
                return this.numberField;
            }
            set {
                this.numberField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the password requires a non-alphanumeric character.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> special {
            get {
                return this.specialField;
            }
            set {
                this.specialField = value;
            }
        }
        
    /// <datatype>
    ///   AuthenticationType
    /// </datatype>
    /// <value>
    ///   If set to one of the values GRID, TOKENRO or TOKENCR then an 
    ///   administrator will require this type of second factor authentication to login 
    ///   to the administration service. If set to the value NONE, the 
    ///   administrator will not require second factor authentication to login. No 
    ///   other authentication types can be specified. This value does not apply to 
    ///   master user login attempts. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<AuthenticationType> secondAuth {
            get {
                return this.secondAuthField;
            }
            set {
                this.secondAuthField = value;
            }
        }
        
    /// <datatype>
    ///   PasswordStorage
    /// </datatype>
    /// <value>
    ///   Indicates how the password will be stored in the repository.
    ///   This value does not apply to how master user passwords are stored. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<PasswordStorage> storage {
            get {
                return this.storageField;
            }
            set {
                this.storageField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   Optional descriptive comments.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string comment {
            get {
                return this.commentField;
            }
            set {
                this.commentField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to policyGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PolicyGetCallParms {
        
        private string nameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the policy to retrieve. If null, it indicates the default 
    ///   policy should be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   policyDelete. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PolicyDeleteCallParms {
        
        private string nameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the policy to delete
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   policyCreate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class PolicyCreateCallParms {
        
        private string nameField;
        
        private PolicyParms parmsField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the policy to create.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
    /// <datatype>
    ///   PolicyParms
    /// </datatype>
    /// <value>
    ///   Parameters that control the policy settings. Any policy settings not 
    ///   included in this structure will be assigned the relevant default 
    ///   value. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public PolicyParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure provides information about a Token Vendor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenVendorInfo {
        
        private string vendorIdField;
        
        private string vendorNameField;
        
        private bool defaultVendorField;
        
        private bool binaryField;
        
        private int minResetResponsesField;
        
        private int maxResetResponsesField;
        
        private bool requiresKeyField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The id of the token vendor.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string VendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the token vendor.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string VendorName {
            get {
                return this.vendorNameField;
            }
            set {
                this.vendorNameField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if this token vendor is the default. At most one token 
    ///   vendor will be the default. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool DefaultVendor {
            get {
                return this.defaultVendorField;
            }
            set {
                this.defaultVendorField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if the token data files loaded by this token vendor 
    ///   are binary or not. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool Binary {
            get {
                return this.binaryField;
            }
            set {
                this.binaryField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The minimum number of responses required for the token reset operation 
    ///   on tokens with this vendor. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int minResetResponses {
            get {
                return this.minResetResponsesField;
            }
            set {
                this.minResetResponsesField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The maximum number of responses used for the token reset operation on 
    ///   tokens with this vendor. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int maxResetResponses {
            get {
                return this.maxResetResponsesField;
            }
            set {
                this.maxResetResponsesField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if the token vendor requires a key when loading 
    ///   tokens. If a key is not required, then it is optional. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool requiresKey {
            get {
                return this.requiresKeyField;
            }
            set {
                this.requiresKeyField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   tokenVendorGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class TokenVendorGetCallParms {
        
        private string vendorIdField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The id of the token vendor being retrieved.
    ///   If null is specified for the vendor Id, the default token vendor will 
    ///   be returned. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string VendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to regionList. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RegionListCallParms {
        
        private string countryCodeField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The code of the country of the regions being retrieved.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string countryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure provides information about a region.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RegionInfo {
        
        private string countryCodeField;
        
        private string regionCodeField;
        
        private string regionNameField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The code of the country.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string countryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The code of the region.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string regionCode {
            get {
                return this.regionCodeField;
            }
            set {
                this.regionCodeField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the region.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string regionName {
            get {
                return this.regionNameField;
            }
            set {
                this.regionNameField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to regionGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class RegionGetCallParms {
        
        private string countryCodeField;
        
        private string regionCodeField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The code of the country of the region being retrieved.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string countryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The code of the region being retrieved.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string regionCode {
            get {
                return this.regionCodeField;
            }
            set {
                this.regionCodeField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to countryGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class CountryGetCallParms {
        
        private string countryCodeField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The code of the country being retrieved.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string countryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the location of an IP address.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:commonV3")]
    public partial class IPLocation {
        
        private bool privateAddressField;
        
        private string iPAddressField;
        
        private string countryField;
        
        private string countryNameField;
        
        private string regionField;
        
        private string regionNameField;
        
        private string cityField;
        
        private string iSPField;
        
        private System.Nullable<float> latitudeField;
        
        private System.Nullable<float> longitudeField;
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, this IP address is a private IP address as defined by RFC 
    ///   1918. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool privateAddress {
            get {
                return this.privateAddressField;
            }
            set {
                this.privateAddressField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The IP address of the location.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string IPAddress {
            get {
                return this.iPAddressField;
            }
            set {
                this.iPAddressField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The country code of the location.
    ///   Private IP addresses do not have a country.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string country {
            get {
                return this.countryField;
            }
            set {
                this.countryField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the country of the location.
    ///   Private IP addresses do not have a country.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string countryName {
            get {
                return this.countryNameField;
            }
            set {
                this.countryNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The region code of the location.
    ///   Private IP addresses do not have a region.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string region {
            get {
                return this.regionField;
            }
            set {
                this.regionField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The name of the region of the location.
    ///   Private IP addresses do not have a region.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string regionName {
            get {
                return this.regionNameField;
            }
            set {
                this.regionNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The city of the location.
    ///   Private IP addresses do not have a city.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string city {
            get {
                return this.cityField;
            }
            set {
                this.cityField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The ISP of the location.
    ///   Private IP addresses do not have an ISP.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string ISP {
            get {
                return this.iSPField;
            }
            set {
                this.iSPField = value;
            }
        }
        
    /// <datatype>
    ///   float
    /// </datatype>
    /// <value>
    ///   The latitude of the location.
    ///   Private IP addresses do not have a latitude.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<float> latitude {
            get {
                return this.latitudeField;
            }
            set {
                this.latitudeField = value;
            }
        }
        
    /// <datatype>
    ///   float
    /// </datatype>
    /// <value>
    ///   The longitude of the location.
    ///   Private IP addresses do not have a longitude.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<float> longitude {
            get {
                return this.longitudeField;
            }
            set {
                this.longitudeField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   ipLocationGet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class IPLocationGetCallParms {
        
        private string iPAddressField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The IP address whose location is being retrieved.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string IPAddress {
            get {
                return this.iPAddressField;
            }
            set {
                this.iPAddressField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   licenseCheck. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class LicenseCheckCallParms {
        
        private LicenseParms parmsField;
        
    /// <datatype>
    ///   LicenseParms
    /// </datatype>
    /// <value>
    ///   Parameters that include an installation and activation key.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public LicenseParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Parameters used to update the system license settings.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class LicenseParms {
        
        private string installKeyField;
        
        private string activationKeyField;
        
        private bool countUsersField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The installation key, supplied by Entrust.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string installKey {
            get {
                return this.installKeyField;
            }
            set {
                this.installKeyField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The activation key, supplied by Entrust.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string activationKey {
            get {
                return this.activationKeyField;
            }
            set {
                this.activationKeyField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag that controls whether or not a full user count is performed 
    ///   before updating the license. 
    ///   This is used to make sure the system has an accurate user count, but 
    ///   can be slow as it requires scanning every user entry in the 
    ///   repository. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool countUsers {
            get {
                return this.countUsersField;
            }
            set {
                this.countUsersField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to licenseSet. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class LicenseSetCallParms {
        
        private LicenseParms parmsField;
        
    /// <datatype>
    ///   LicenseParms
    /// </datatype>
    /// <value>
    ///   Parameters that include an installation and activation key.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public LicenseParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
    }
    
    /// <summary>
    ///   Information about the system license settings.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class LicenseInfo {
        
        private string numUsersField;
        
        private string maxUsersField;
        
        private System.Nullable<System.DateTime> expiryDateField;
        
        private string[] rolesGrantingAccessField;
        
    /// <datatype>
    ///   integer
    /// </datatype>
    /// <value>
    ///   The current number of users in the system.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer")]
        public string numUsers {
            get {
                return this.numUsersField;
            }
            set {
                this.numUsersField = value;
            }
        }
        
    /// <datatype>
    ///   integer
    /// </datatype>
    /// <value>
    ///   The maximum number of users that can exist in the system. The system 
    ///   will not allow more than this many users to be created. 
    ///   If this value is nil, there is no limit to the number of users in the 
    ///   system. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer", IsNullable=true)]
        public string maxUsers {
            get {
                return this.maxUsersField;
            }
            set {
                this.maxUsersField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date at which the license expires. The system will cease 
    ///   functioning after this date. 
    ///    If this value is nil, the current license never expires.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> expiryDate {
            get {
                return this.expiryDateField;
            }
            set {
                this.expiryDateField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   When this structure is returned by an admin service operation, this is 
    ///   the list of the names of the roles that granted access to this 
    ///   structure. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] rolesGrantingAccess {
            get {
                return this.rolesGrantingAccessField;
            }
            set {
                this.rolesGrantingAccessField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains the parameters passed in a call to 
    ///   changePassword. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class ChangePasswordCallParms {
        
        private LoginParms parmsField;
        
        private string newpasswordField;
        
    /// <datatype>
    ///   LoginParms
    /// </datatype>
    /// <value>
    ///   Parameters that includes the administrator ID and old password of the 
    ///   administrator that is changing their password. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public LoginParms parms {
            get {
                return this.parmsField;
            }
            set {
                this.parmsField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The new password of the administrator. This must conform to the 
    ///   password rules. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string newpassword {
            get {
                return this.newpasswordField;
            }
            set {
                this.newpasswordField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains details about the card that was used to 
    ///   authenticate a user. It is returned as part of the response after a user 
    ///   successfully authenticates. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:commonV3")]
    public partial class CardData {
        
        private string serialNumberField;
        
        private System.DateTime expiryDateField;
        
        private System.DateTime supersededDateField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the card used for authentication.
    ///   This will be empty if a temporary pin was used for authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string SerialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The expiry date of the card used for authentication.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime ExpiryDate {
            get {
                return this.expiryDateField;
            }
            set {
                this.expiryDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The supersede date of the card used for authentication.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public System.DateTime SupersededDate {
            get {
                return this.supersededDateField;
            }
            set {
                this.supersededDateField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains information about a token that can be used to 
    ///   authenticate. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:commonV3")]
    public partial class TokenData {
        
        private string vendorIdField;
        
        private string serialNumberField;
        
        private bool supportsDataSignatureField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The vendor id of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string VendorId {
            get {
                return this.vendorIdField;
            }
            set {
                this.vendorIdField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The serial number of the token.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string SerialNumber {
            get {
                return this.serialNumberField;
            }
            set {
                this.serialNumberField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if this token supports the data signature operation. 
    ///   Note that a value of true does not indicate if the user's policy 
    ///   allows the data signature operation to be performed. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool SupportsDataSignature {
            get {
                return this.supportsDataSignatureField;
            }
            set {
                this.supportsDataSignatureField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure contains information about a token challenge.
    ///   For a TOKENRO challenge, this includes a list of tokens that can be 
    ///   used to authenticate the challenge. For a TOKENCR challenge, this also 
    ///   includes the token challenge value that must be entered into the 
    ///   token to generate the token response. 
    ///   The token challenge also includes information about the temporary PIN 
    ///   that can be used to respond to a token challenge. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:commonV3")]
    public partial class TokenChallenge {
        
        private string challengeField;
        
        private TokenData[] tokensField;
        
        private System.Nullable<bool> hasTemporaryPINField;
        
        private string temporaryPINCellAlphabetField;
        
        private System.Nullable<int> temporaryPINCellSizeField;
        
        private System.Nullable<int> temporaryPINChallengeSizeField;
        
        private System.Nullable<bool> allowDataSignatureField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The token challenge. This value will only be set for TOKENCR 
    ///   authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string challenge {
            get {
                return this.challengeField;
            }
            set {
                this.challengeField = value;
            }
        }
        
    /// <datatype>
    ///   TokenData[]
    /// </datatype>
    /// <value>
    ///   The tokens that can be used to authenticate the challenge.
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public TokenData[] tokens {
            get {
                return this.tokensField;
            }
            set {
                this.tokensField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   Flag indicating if user has a temporary PIN.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> hasTemporaryPIN {
            get {
                return this.hasTemporaryPINField;
            }
            set {
                this.hasTemporaryPINField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The characters allowed in a temporary PIN challenge response. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string temporaryPINCellAlphabet {
            get {
                return this.temporaryPINCellAlphabetField;
            }
            set {
                this.temporaryPINCellAlphabetField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of characters in a temporary PIN cell.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> temporaryPINCellSize {
            get {
                return this.temporaryPINCellSizeField;
            }
            set {
                this.temporaryPINCellSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of cells in a temporary PIN challenge response.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<int> temporaryPINChallengeSize {
            get {
                return this.temporaryPINChallengeSizeField;
            }
            set {
                this.temporaryPINChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   A flag indicating if policy will allow the data signature operation to 
    ///   be included as part of a TOKENRO authentication request. A value of 
    ///   TRUE does not mean that a particular token supports data signature. 
    ///   This value will only be set for TOKENRO challenges. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<bool> allowDataSignature {
            get {
                return this.allowDataSignatureField;
            }
            set {
                this.allowDataSignatureField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines a challenge component used for grid authentication.
    ///   A Challenge is a single row/column pair corresponding to a cell in an 
    ///   Entrust IdentityGuard card grid. Note that the indexing method used 
    ///   for cards is zero-based, so the row can be in the range 0 to (number 
    ///   of rows - 1), and the column can be in the range 0 to (number of 
    ///   columns - 1). 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:commonV3")]
    public partial class Challenge {
        
        private int rowField;
        
        private int columnField;
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The row.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int Row {
            get {
                return this.rowField;
            }
            set {
                this.rowField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The column.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int Column {
            get {
                return this.columnField;
            }
            set {
                this.columnField = value;
            }
        }
    }
    
    /// <summary>
    ///   This structure defines the components returned as part of a grid 
    ///   challenge. It contains an array of Challenges which define the challenge 
    ///   the user must respond to, as well as additional data that describes 
    ///   the format of a valid challenge response. Note that the settings for 
    ///   what is a valid response are based on the most up-to-date policy 
    ///   settings, while the user's card may have been generated with older settings 
    ///   that mean the card is no longer valid according to the new ones. For 
    ///   example, if the user's card was generated with one character per 
    ///   cell, then the policy was changed to two characters per cell, the value 
    ///   in this structure for number of characters per cell would be two, 
    ///   even though the user's card only has one character per cell. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:commonV3")]
    public partial class ChallengeSet {
        
        private string cardCellAlphabetField;
        
        private int cardCellSizeField;
        
        private string[] cardSerialNumbersField;
        
        private Challenge[] challengeField;
        
        private string temporaryPinCellAlphabetField;
        
        private int temporaryPinCellSizeField;
        
        private int temporaryPinChallengeSizeField;
        
        private bool userHasTemporaryPinField;
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   This string includes all the characters allowed in a challenge 
    ///   response. This does not include cell replacements, where, for example, the 
    ///   character 'l' may automatically be replaced by the digit '1' by the 
    ///   server. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string cardCellAlphabet {
            get {
                return this.cardCellAlphabetField;
            }
            set {
                this.cardCellAlphabetField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of characters in a single card cell.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int cardCellSize {
            get {
                return this.cardCellSizeField;
            }
            set {
                this.cardCellSizeField = value;
            }
        }
        
    /// <datatype>
    ///   string[]
    /// </datatype>
    /// <value>
    ///   The list of serial numbers of cards that the user could use to 
    ///   authenticate. This will be null if the system policy settings do not allow 
    ///   returning of this value, the user has a temporary PIN but no active 
    ///   cards or for anonymous authentication. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public string[] cardSerialNumbers {
            get {
                return this.cardSerialNumbersField;
            }
            set {
                this.cardSerialNumbersField = value;
            }
        }
        
    /// <datatype>
    ///   Challenge[]
    /// </datatype>
    /// <value>
    ///   An array of Challenge components. This is the challenge that the user 
    ///   must successfully answer. 
    /// </value>
        [System.Xml.Serialization.XmlArrayAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=false)]
        public Challenge[] challenge {
            get {
                return this.challengeField;
            }
            set {
                this.challengeField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The characters allowed in a temporary PIN challenge response. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string temporaryPinCellAlphabet {
            get {
                return this.temporaryPinCellAlphabetField;
            }
            set {
                this.temporaryPinCellAlphabetField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of characters in a temporary PIN cell.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int temporaryPinCellSize {
            get {
                return this.temporaryPinCellSizeField;
            }
            set {
                this.temporaryPinCellSizeField = value;
            }
        }
        
    /// <datatype>
    ///   int
    /// </datatype>
    /// <value>
    ///   The number of cells in a temporary PIN challenge response.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public int temporaryPinChallengeSize {
            get {
                return this.temporaryPinChallengeSizeField;
            }
            set {
                this.temporaryPinChallengeSizeField = value;
            }
        }
        
    /// <datatype>
    ///   boolean
    /// </datatype>
    /// <value>
    ///   If true, the user currently has a temporary PIN assigned.
    ///   If the system does not allow returning of user data in the challenge 
    ///   set, this value will be false, regardless of whether or not the user 
    ///   actually has a temporary PIN. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool userHasTemporaryPin {
            get {
                return this.userHasTemporaryPinField;
            }
            set {
                this.userHasTemporaryPinField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the 2nd-factor authentication challenge returned for a login 
    ///   or changePassword request. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class LoginChallenge {
        
        private AuthenticationType typeField;
        
        private ChallengeSet gridChallengeField;
        
        private TokenChallenge tokenChallengeField;
        
    /// <datatype>
    ///   AuthenticationType
    /// </datatype>
    /// <value>
    ///   The type of the challenge. It will be one of GRID, TOKENRO or TOKENCR. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public AuthenticationType type {
            get {
                return this.typeField;
            }
            set {
                this.typeField = value;
            }
        }
        
    /// <datatype>
    ///   ChallengeSet
    /// </datatype>
    /// <value>
    ///   The grid challenge. This value will be set if the challenge type is 
    ///   GRID. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public ChallengeSet gridChallenge {
            get {
                return this.gridChallengeField;
            }
            set {
                this.gridChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   TokenChallenge
    /// </datatype>
    /// <value>
    ///   The token challenge. This value will be set if the challenge type is 
    ///   TOKENRO or TOKENCR. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public TokenChallenge tokenChallenge {
            get {
                return this.tokenChallengeField;
            }
            set {
                this.tokenChallengeField = value;
            }
        }
    }
    
    /// <summary>
    ///   Defines the information returned from a login or changePassword 
    ///   request. 
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public partial class LoginResult {
        
        private LoginState stateField;
        
        private string groupNameField;
        
        private string userNameField;
        
        private LoginChallenge loginChallengeField;
        
        private System.Nullable<System.DateTime> passwordExpiryDateField;
        
        private System.Nullable<System.DateTime> passwordAllowChangeAfterDateField;
        
        private CardData cardField;
        
        private TokenData tokenField;
        
    /// <datatype>
    ///   LoginState
    /// </datatype>
    /// <value>
    ///   The state of the login request.
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public LoginState state {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The group name of the administrator logging in.
    ///   This value will only be set if the administrator has completed logging 
    ///   in. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string groupName {
            get {
                return this.groupNameField;
            }
            set {
                this.groupNameField = value;
            }
        }
        
    /// <datatype>
    ///   string
    /// </datatype>
    /// <value>
    ///   The user name of the administrator logging in.
    ///   This value will only be set if the administrator has completed logging 
    ///   in. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public string userName {
            get {
                return this.userNameField;
            }
            set {
                this.userNameField = value;
            }
        }
        
    /// <datatype>
    ///   LoginChallenge
    /// </datatype>
    /// <value>
    ///   A challenge for second-factor authentication.
    ///   This value will only be set if the administrator has passed the 
    ///   first-phase password authentication and second-factor authentication is 
    ///   required for the administrator. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public LoginChallenge loginChallenge {
            get {
                return this.loginChallengeField;
            }
            set {
                this.loginChallengeField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date on which the user's password will expire. A value of Date(0) 
    ///   means the password will never expire. 
    ///   This value will be set if the administrator's password has been 
    ///   authenticated. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> passwordExpiryDate {
            get {
                return this.passwordExpiryDateField;
            }
            set {
                this.passwordExpiryDateField = value;
            }
        }
        
    /// <datatype>
    ///   dateTime
    /// </datatype>
    /// <value>
    ///   The date after which a password change will be allowed for the user, 
    ///   accounting for the minimum lifetime policy. 
    ///   This value will be set if the administrator's password has been 
    ///   authenticated. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public System.Nullable<System.DateTime> passwordAllowChangeAfterDate {
            get {
                return this.passwordAllowChangeAfterDateField;
            }
            set {
                this.passwordAllowChangeAfterDateField = value;
            }
        }
        
    /// <datatype>
    ///   CardData
    /// </datatype>
    /// <value>
    ///   The card used for second factor authentication.
    ///   This value will be set if the administrator has successfully used the 
    ///   card for second factor authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public CardData card {
            get {
                return this.cardField;
            }
            set {
                this.cardField = value;
            }
        }
        
    /// <datatype>
    ///   TokenData
    /// </datatype>
    /// <value>
    ///   The token used for second factor authentication.
    ///   This value will be set if the administrator has successfully used the 
    ///   token for second factor authentication. 
    /// </value>
        [System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable=true)]
        public TokenData token {
            get {
                return this.tokenField;
            }
            set {
                this.tokenField = value;
            }
        }
    }
    
    /// <summary>
    ///   The state of the current login.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:entrust.com:ig:adminV3:wsdl")]
    public enum LoginState {
        
    /// <value>
    ///   Login has been completed successfully.
    /// </value>
        COMPLETE,
        
    /// <value>
    ///   Password authentication succeeded, but second-factor authentication is 
    ///   required. 
    /// </value>
        NEED_SECOND_FACTOR,
        
    /// <value>
    ///   This state is a placeholder in case new states are added in future 
    ///   releases. If your application encounters this state it should be 
    ///   upgraded to use the most up-to-date version of the admin service. 
    /// </value>
        UNKNOWN,
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void loginCompletedEventHandler(object sender, loginCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class loginCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal loginCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public LoginResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LoginResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void logoutCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void changePasswordCompletedEventHandler(object sender, changePasswordCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class changePasswordCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal changePasswordCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public LoginResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LoginResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void keepAliveCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void pingCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void licenseGetCompletedEventHandler(object sender, licenseGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class licenseGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal licenseGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public LicenseInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LicenseInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void licenseSetCompletedEventHandler(object sender, licenseSetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class licenseSetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal licenseSetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public LicenseInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LicenseInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void licenseCheckCompletedEventHandler(object sender, licenseCheckCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class licenseCheckCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal licenseCheckCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public LicenseInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((LicenseInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ipLocationGetCompletedEventHandler(object sender, ipLocationGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ipLocationGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ipLocationGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public IPLocation Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((IPLocation)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void countryGetCompletedEventHandler(object sender, countryGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class countryGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal countryGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public CountryInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CountryInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void countryListCompletedEventHandler(object sender, countryListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class countryListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal countryListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public CountryInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CountryInfo[])(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void regionGetCompletedEventHandler(object sender, regionGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class regionGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal regionGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public RegionInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RegionInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void regionListCompletedEventHandler(object sender, regionListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class regionListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal regionListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public RegionInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RegionInfo[])(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void tokenVendorGetCompletedEventHandler(object sender, tokenVendorGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class tokenVendorGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal tokenVendorGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public TokenVendorInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TokenVendorInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void tokenVendorListCompletedEventHandler(object sender, tokenVendorListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class tokenVendorListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal tokenVendorListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public TokenVendorInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TokenVendorInfo[])(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void policyCreateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void policyDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void policyGetCompletedEventHandler(object sender, policyGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class policyGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal policyGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public PolicyInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PolicyInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void policySetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void policyListCompletedEventHandler(object sender, policyListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class policyListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal policyListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public PolicyInfoList Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PolicyInfoList)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userSpecGetCompletedEventHandler(object sender, userSpecGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userSpecGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userSpecGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserSpecInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserSpecInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void cardSpecGetCompletedEventHandler(object sender, cardSpecGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class cardSpecGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal cardSpecGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public CardSpecInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CardSpecInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void pinSpecGetCompletedEventHandler(object sender, pinSpecGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class pinSpecGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal pinSpecGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public PINSpecInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PINSpecInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void passwordRulesGetCompletedEventHandler(object sender, passwordRulesGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class passwordRulesGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal passwordRulesGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public PasswordRulesInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PasswordRulesInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void permissionListCompletedEventHandler(object sender, permissionListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class permissionListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal permissionListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public PermissionsList Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PermissionsList)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ownRoleGetCompletedEventHandler(object sender, ownRoleGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ownRoleGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ownRoleGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public RoleInfoList Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RoleInfoList)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void roleCreateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void roleDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void roleGetCompletedEventHandler(object sender, roleGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class roleGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal roleGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public RoleInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RoleInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void roleSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void roleListCompletedEventHandler(object sender, roleListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class roleListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal roleListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public RoleInfoList Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RoleInfoList)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void groupCreateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void groupDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void groupGetCompletedEventHandler(object sender, groupGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class groupGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal groupGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public GroupInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GroupInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void groupSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void groupListCompletedEventHandler(object sender, groupListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class groupListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal groupListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public GroupInfoList Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GroupInfoList)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void repositoryGetCompletedEventHandler(object sender, repositoryGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class repositoryGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal repositoryGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public RepositoryInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RepositoryInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void repositoryListCompletedEventHandler(object sender, repositoryListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class repositoryListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal repositoryListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public RepositoryInfoList Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((RepositoryInfoList)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userCreateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userGetCompletedEventHandler(object sender, userGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userGetOriginalIdCompletedEventHandler(object sender, userGetOriginalIdCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userGetOriginalIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userGetOriginalIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userListCompletedEventHandler(object sender, userListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserListResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserListResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void deliveryConfigListCompletedEventHandler(object sender, deliveryConfigListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class deliveryConfigListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal deliveryConfigListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public DeliveryConfigInfoList Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((DeliveryConfigInfoList)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userContactInfoCreateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userContactInfoDeleteCompletedEventHandler(object sender, userContactInfoDeleteCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userContactInfoDeleteCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userContactInfoDeleteCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userContactInfoGetCompletedEventHandler(object sender, userContactInfoGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userContactInfoGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userContactInfoGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public ContactInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ContactInfo[])(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userContactInfoSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPINCreateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPINDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPINGetCompletedEventHandler(object sender, userPINGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userPINGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userPINGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserPINInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserPINInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPINSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userMachineSecretCreateCompletedEventHandler(object sender, userMachineSecretCreateCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userMachineSecretCreateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userMachineSecretCreateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public MachineSecretInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachineSecretInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userMachineSecretDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userMachineSecretGetCompletedEventHandler(object sender, userMachineSecretGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userMachineSecretGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userMachineSecretGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public MachineSecretInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachineSecretInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userMachineSecretSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userMachineSecretListCompletedEventHandler(object sender, userMachineSecretListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userMachineSecretListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userMachineSecretListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public MachineSecretInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachineSecretInfo[])(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userOTPCreateCompletedEventHandler(object sender, userOTPCreateCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userOTPCreateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userOTPCreateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserOTPInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserOTPInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userOTPDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userOTPDeliverCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userOTPGetCompletedEventHandler(object sender, userOTPGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userOTPGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userOTPGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserOTPInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserOTPInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPasswordCreateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPasswordSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPasswordGetCompletedEventHandler(object sender, userPasswordGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userPasswordGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userPasswordGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserPasswordInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserPasswordInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPasswordDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPVNCreateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPVNSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPVNDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userPVNGetCompletedEventHandler(object sender, userPVNGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userPVNGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userPVNGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserPVNInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserPVNInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userCardCreateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userCardDeleteCompletedEventHandler(object sender, userCardDeleteCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userCardDeleteCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userCardDeleteCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userCardGetCompletedEventHandler(object sender, userCardGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userCardGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userCardGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserCardInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserCardInfo[])(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userCardSetCompletedEventHandler(object sender, userCardSetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userCardSetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userCardSetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userCardUnassignCompletedEventHandler(object sender, userCardUnassignCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userCardUnassignCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userCardUnassignCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userCardListCompletedEventHandler(object sender, userCardListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userCardListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userCardListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserCardListResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserCardListResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userCardExportCompletedEventHandler(object sender, userCardExportCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userCardExportCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userCardExportCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public CardExportResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CardExportResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenAssignCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenDeleteCompletedEventHandler(object sender, userTokenDeleteCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userTokenDeleteCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userTokenDeleteCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenGetCompletedEventHandler(object sender, userTokenGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userTokenGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userTokenGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserTokenInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserTokenInfo[])(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenSetCompletedEventHandler(object sender, userTokenSetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userTokenSetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userTokenSetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenUnassignCompletedEventHandler(object sender, userTokenUnassignCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userTokenUnassignCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userTokenUnassignCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenChallengeGetCompletedEventHandler(object sender, userTokenChallengeGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userTokenChallengeGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userTokenChallengeGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenAuthenticateCompletedEventHandler(object sender, userTokenAuthenticateCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userTokenAuthenticateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userTokenAuthenticateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenChallengeAuthenticateCompletedEventHandler(object sender, userTokenChallengeAuthenticateCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userTokenChallengeAuthenticateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userTokenChallengeAuthenticateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenUnlockCompletedEventHandler(object sender, userTokenUnlockCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userTokenUnlockCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userTokenUnlockCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserTokenUnlockResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserTokenUnlockResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void userTokenListCompletedEventHandler(object sender, userTokenListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class userTokenListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal userTokenListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public UserTokenListResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserTokenListResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void preproducedCardCreateCompletedEventHandler(object sender, preproducedCardCreateCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class preproducedCardCreateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal preproducedCardCreateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public PreproducedCardCreateResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PreproducedCardCreateResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void preproducedCardDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void preproducedCardGetCompletedEventHandler(object sender, preproducedCardGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class preproducedCardGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal preproducedCardGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public PreproducedCardInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PreproducedCardInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void preproducedCardSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void preproducedCardListCompletedEventHandler(object sender, preproducedCardListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class preproducedCardListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal preproducedCardListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public PreproducedCardListResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PreproducedCardListResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void preproducedCardExportCompletedEventHandler(object sender, preproducedCardExportCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class preproducedCardExportCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal preproducedCardExportCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public CardExportResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CardExportResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void tokenLoadCompletedEventHandler(object sender, tokenLoadCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class tokenLoadCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal tokenLoadCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public TokenLoadResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TokenLoadResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void tokenDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void tokenGetCompletedEventHandler(object sender, tokenGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class tokenGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal tokenGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public TokenInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TokenInfo)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void tokenSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void tokenListCompletedEventHandler(object sender, tokenListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class tokenListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal tokenListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public TokenListResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((TokenListResult)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void challengeGetCompletedEventHandler(object sender, challengeGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class challengeGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal challengeGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public Challenge[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Challenge[])(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void challengeAuthenticateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ipListAddCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ipListDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ipListGetCompletedEventHandler(object sender, ipListGetCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ipListGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ipListGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public IPListEntry Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((IPListEntry)(this.results[0]));
            }
        }
    }
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ipListListCompletedEventHandler(object sender, ipListListCompletedEventArgs e);
    
    ///  <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ipListListCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ipListListCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
    ///  <remarks/>
        public IPListListResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((IPListListResult)(this.results[0]));
            }
        }
    }
}
